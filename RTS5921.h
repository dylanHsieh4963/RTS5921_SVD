/*
 * The license belong to Realtek Semiconductor Corp. All the rights reserved.
 *
 * @file     RTS5921.h
 * @brief    CMSIS HeaderFile
 * @version  0.01
 * @date     04. July 2025
 * @note     Generated by SVDConv V3.3.42 on Friday, 04.07.2025 15:02:05
 *           from File 'RTS5921.svd',
 *           last modified on Friday, 04.07.2025 06:27:28
 */



/** @addtogroup Realtek Semiconductor Corp.
  * @{
  */


/** @addtogroup RTS5921
  * @{
  */


#ifndef RTS5921_H
#define RTS5921_H

#ifdef __cplusplus
extern "C" {
#endif


/** @addtogroup Configuration_of_CMSIS
  * @{
  */



/* =========================================================================================================================== */
/* ================                                Interrupt Number Definition                                ================ */
/* =========================================================================================================================== */

typedef enum {
/* ========================================  ARM ARMV8MBL Specific Interrupt Numbers  ======================================== */
  Reset_IRQn                = -15,              /*!< -15  Reset Vector, invoked on Power up and warm reset                     */
  NonMaskableInt_IRQn       = -14,              /*!< -14  Non maskable Interrupt, cannot be stopped or preempted               */
  HardFault_IRQn            = -13,              /*!< -13  Hard Fault, all classes of Fault                                     */
  SVCall_IRQn               =  -5,              /*!< -5 System Service Call via SVC instruction                                */
  PendSV_IRQn               =  -2,              /*!< -2 Pendable request for system service                                    */
  SysTick_IRQn              =  -1,              /*!< -1 System Tick Timer                                                      */
/* ==========================================  RTS5921 Specific Interrupt Numbers  =========================================== */
  GPIOA_IRQn                =   0,              /*!< 0  GPIO PORTA Interrupt                                                   */
  GPIOB_IRQn                =   1,              /*!< 1  GPIO PORTB Interrupt                                                   */
  GPIOC_IRQn                =   2,              /*!< 2  GPIO PORTC Interrupt                                                   */
  GPIOD_IRQn                =   3,              /*!< 3  GPIO PORTD Interrupt                                                   */
  GPIDE_IRQn                =   4,              /*!< 4  GPIO PORTE Interrupt                                                   */
  GPIOF_IRQn                =   5,              /*!< 5  GPIO PORTF Interrupt                                                   */
  GPIOG_IRQn                =   6,              /*!< 6  GPIO PORTG Interrupt                                                   */
  GPIOH_IRQn                =   7,              /*!< 7  GPIO PORTH Interrupt                                                   */
  DMA_IRQn                  =   8,              /*!< 8  DMA Controller Interrupt                                               */
  ITR_SPIC_IRQn             =   9,              /*!< 9  Internal SPIC Interrupt                                                */
  ETR_SPIC_IRQn             =  10,              /*!< 10 External SPIC Interrupt                                                */
  USB_IRQn                  =  12,              /*!< 12 USB OTG Interrupt                                                      */
  SPIM_IRQn                 =  13,              /*!< 13 SPI Master Interrupt                                                   */
  SPIS_IRQn                 =  14,              /*!< 14 SPI Slave Interrupt                                                    */
  UART_IRQn                 =  15,              /*!< 15 UART Interrupt                                                         */
  I2C0_IRQn                 =  16,              /*!< 16 I2C0 Interrupt                                                         */
  I2C1_IRQn                 =  17,              /*!< 17 I2C1 Interrupt                                                         */
  I2C2_IRQn                 =  18,              /*!< 18 I2C2 Interrupt                                                         */
  WDT_IRQn                  =  20,              /*!< 20 WDT Interrupt                                                          */
  TMR0_IRQn                 =  21,              /*!< 21 TMR0 Interrupt                                                         */
  TMR1_IRQn                 =  22,              /*!< 22 TMR1 Interrupt                                                         */
  TMR2_IRQn                 =  23,              /*!< 23 TMR2 Interrupt                                                         */
  TMR3_IRQn                 =  24,              /*!< 24 TMR3 Interrupt                                                         */
  DOTMTX0_IRQn              =  25,              /*!< 25 DOTMTX0 Interrupt                                                      */
  DOTMTX1_IRQn              =  26,              /*!< 26 DOTMTX1 Interrupt                                                      */
  STRIP0_IRQn               =  27,              /*!< 27 STRIP0 Interrupt                                                       */
  STRIP1_IRQn               =  28,              /*!< 28 STRIP1 Interrupt                                                       */
  STRIP2_IRQn               =  29,              /*!< 29 STRIP2 Interrupt                                                       */
  STRIP3_IRQn               =  30,              /*!< 30 STRIP3 Interrupt                                                       */
  STRIP4_IRQn               =  31,              /*!< 31 STRIP4 Interrupt                                                       */
  STRIP5_IRQn               =  32,              /*!< 32 STRIP5 Interrupt                                                       */
  STRIP6_IRQn               =  33,              /*!< 33 STRIP6 Interrupt                                                       */
  STRIP7_IRQn               =  34,              /*!< 34 STRIP7 Interrupt                                                       */
  STRIP8_IRQn               =  35,              /*!< 35 STRIP8 Interrupt                                                       */
  TACHO0_IRQn               =  36,              /*!< 36 TACHO0 Interrupt                                                       */
  TACHO1_IRQn               =  37,              /*!< 37 TACHO1 Interrupt                                                       */
  TACHO2_IRQn               =  38,              /*!< 38 TACHO2 Interrupt                                                       */
  TACHO3_IRQn               =  39               /*!< 39 TACHO3 Interrupt                                                       */
} IRQn_Type;



/* =========================================================================================================================== */
/* ================                           Processor and Core Peripheral Section                           ================ */
/* =========================================================================================================================== */

/* ===========================  Configuration of the ARM ARMV8MBL Processor and Core Peripherals  ============================ */
#define __ARMV8MBL_REV                 0x0000U  /*!< ARMV8MBL Core Revision                                                    */
#define __NVIC_PRIO_BITS               3        /*!< Number of Bits used for Priority Levels                                   */
#define __Vendor_SysTickConfig         0        /*!< Set to 1 if different SysTick Config is used                              */
#define __VTOR_PRESENT                 1        /*!< Set to 1 if CPU supports Vector Table Offset Register                     */
#define __MPU_PRESENT                  1        /*!< MPU present                                                               */
#define __FPU_PRESENT                  0        /*!< FPU present                                                               */
#define __SAUREGION_PRESENT            0        /*!< SAU region present                                                        */


/** @} */ /* End of group Configuration_of_CMSIS */

#include "core_armv8mbl.h"                      /*!< ARM ARMV8MBL processor and core peripherals                               */
#include "system_RTS5921.h"                     /*!< RTS5921 System                                                            */

#ifndef __IM                                    /*!< Fallback for older CMSIS versions                                         */
  #define __IM   __I
#endif
#ifndef __OM                                    /*!< Fallback for older CMSIS versions                                         */
  #define __OM   __O
#endif
#ifndef __IOM                                   /*!< Fallback for older CMSIS versions                                         */
  #define __IOM  __IO
#endif


/* ========================================  Start of section using anonymous unions  ======================================== */
#if defined (__CC_ARM)
  #pragma push
  #pragma anon_unions
#elif defined (__ICCARM__)
  #pragma language=extended
#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wc11-extensions"
  #pragma clang diagnostic ignored "-Wreserved-id-macro"
  #pragma clang diagnostic ignored "-Wgnu-anonymous-struct"
  #pragma clang diagnostic ignored "-Wnested-anon-types"
#elif defined (__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined (__TMS470__)
  /* anonymous unions are enabled by default */
#elif defined (__TASKING__)
  #pragma warning 586
#elif defined (__CSMC__)
  /* anonymous unions are enabled by default */
#else
  #warning Not supported compiler type
#endif


/* =========================================================================================================================== */
/* ================                            Device Specific Peripheral Section                             ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_peripherals
  * @{
  */



/* =========================================================================================================================== */
/* ================                                         ITR_SPIC                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Realtek RXI-312 SPI Controller (ITR_SPIC)
  */

typedef struct {                                /*!< (@ 0x40000000) ITR_SPIC Structure                                         */
  
  union {
    __IOM uint32_t CTRLR0;                      /*!< (@ 0x00000000) Control Register 0                                         */
    
    struct {
      __IOM uint32_t SIPOL      : 5;            /*!< [4..0] Configure SPI input lines                                          */
      __IOM uint32_t SIPOL_EN   : 1;            /*!< [5..5] Set to enable SIPOL functionality                                  */
      __IOM uint32_t SCPH       : 1;            /*!< [6..6] Indicate serial clock phase                                        */
      __IOM uint32_t SCPOL      : 1;            /*!< [7..7] Indicate serial clock polarity                                     */
      __IOM uint32_t TMOD       : 2;            /*!< [9..8] Indicate transfer mode                                             */
      __IOM uint32_t GCLK_DIS   : 1;            /*!< [10..10] Set to disable gated clock of icg cell                           */
            uint32_t            : 5;
      __IOM uint32_t ADDR_CH    : 2;            /*!< [17..16] Indicate channel number of address phase                         */
      __IOM uint32_t DATA_CH    : 2;            /*!< [19..18] Indicate channel number of data phase                            */
      __IOM uint32_t CMD_CH     : 2;            /*!< [21..20] Indicate channel number of command phase                         */
      __IOM uint32_t FAST_RD    : 1;            /*!< [22..22] Indicate whether to use fast read command in user mode           */
      __IOM uint32_t CK_MTIMES  : 5;            /*!< [27..23] Indicates the number of check times for FLASH busy
                                                     state                                                                     */
      __IOM uint32_t DDR_EN     : 3;            /*!< [30..28] Indicates DDR mode in CMD_CH/DATA_CH/ADDR_CH                     */
      __IOM uint32_t PRM_2ND_PHASE : 1;         /*!< [31..31] Indicate if Flash is in PRM (hi-performance read mode)
                                                     of 2nd phase                                                              */
    } CTRLR0_b;
  } ;
  
  union {
    __IOM uint32_t RX_NDF;                      /*!< (@ 0x00000004) Control Register 1                                         */
    
    struct {
      __IOM uint32_t NDF        : 16;           /*!< [15..0] Indicate a number of data frames. If Data-Split-Read
                                                     function enables, NDF can be set larger than FIFO size,
                                                     with a maximum size of 65535 bytes.                                       */
            uint32_t            : 16;
    } RX_NDF_b;
  } ;
  
  union {
    __IOM uint32_t SSIENR;                      /*!< (@ 0x00000008) SPIC Enable Register                                       */
    
    struct {
      __IOM uint32_t SPIC_EN    : 1;            /*!< [0..0] Set to enable SPIC                                                 */
      __IOM uint32_t ATCK_CMD   : 1;            /*!< [1..1] Sets to enable the check of flash busy status or timeout
                                                     before accepting new commands in User Mode. Disable this
                                                     if CTRLR0.SEQ_CMD is set.                                                 */
            uint32_t            : 2;
      __OM  uint32_t PGM_RST_TEST_EN : 1;       /*!< [4..4] Generates a warm reset pulse; for PGM RST testing only             */
            uint32_t            : 27;
    } SSIENR_b;
  } ;
  __IOM uint32_t  MWCR;                         /*!< (@ 0x0000000C) N/A                                                        */
  __IOM uint32_t  SER;                          /*!< (@ 0x00000010) Slave Enable Register                                      */
  
  union {
    __IOM uint32_t BAUDR;                       /*!< (@ 0x00000014) Baud Rate Select                                           */
    
    struct {
      __IOM uint32_t SCKDV      : 12;           /*!< [11..0] Define spi_sclk divider value. The frequency of spi_sclk
                                                     is derived from: Frequency of spi_sclk = Frequency of bus_clk
                                                     / (2*SCKDV).                                                              */
            uint32_t            : 20;
    } BAUDR_b;
  } ;
  
  union {
    __IOM uint32_t TXFTLR;                      /*!< (@ 0x00000018) Transmit FIFO Threshold level                              */
    
    struct {
      __IOM uint32_t TFT        : 5;            /*!< [4..0] Transmit FIFO threshold.                                           */
            uint32_t            : 27;
    } TXFTLR_b;
  } ;
  
  union {
    __IOM uint32_t RXFTLR;                      /*!< (@ 0x0000001C) Receive FIFO Threshold level                               */
    
    struct {
      __IOM uint32_t RFT        : 5;            /*!< [4..0] Receive FIFO threshold.                                            */
            uint32_t            : 27;
    } RXFTLR_b;
  } ;
  
  union {
    __IOM uint32_t TXFLR;                       /*!< (@ 0x00000020) Transmit FIFO level Register                               */
    
    struct {
      __IM  uint32_t TXFLR      : 6;            /*!< [5..0] Indicates the FIFO level of valid data during transmission.        */
            uint32_t            : 26;
    } TXFLR_b;
  } ;
  
  union {
    __IOM uint32_t RXFLR;                       /*!< (@ 0x00000024) Receive FIFO level Register                                */
    
    struct {
      __IM  uint32_t RXFLR      : 6;            /*!< [5..0] Indicates the FIFO level of valid data during reception.           */
            uint32_t            : 26;
    } RXFLR_b;
  } ;
  
  union {
    __IM  uint32_t SR;                          /*!< (@ 0x00000028) Status Register                                            */
    
    struct {
      __IM  uint32_t BUSY       : 1;            /*!< [0..0] SPIC busy flag.                                                    */
      __IM  uint32_t TFNF       : 1;            /*!< [1..1] Transmit FIFO not full status.                                     */
      __IM  uint32_t TFE        : 1;            /*!< [2..2] Transmit FIFO empty status.                                        */
      __IM  uint32_t RFNE       : 1;            /*!< [3..3] Receive FIFO not empty status.                                     */
      __IM  uint32_t RFF        : 1;            /*!< [4..4] Receive FIFO full status.                                          */
      __IM  uint32_t TXE        : 1;            /*!< [5..5] Transmission error indicator.                                      */
      __IM  uint32_t DCOL       : 1;            /*!< [6..6] Data collision or transmitting status.                             */
      __IM  uint32_t BOOT_FIN   : 1;            /*!< [7..7] Boot Finish status indicator.                                      */
            uint32_t            : 24;
    } SR_b;
  } ;
  
  union {
    __IOM uint32_t IMR;                         /*!< (@ 0x0000002C) Interrupt Mask Register                                    */
    
    struct {
      __IOM uint32_t TXEIM      : 1;            /*!< [0..0] Transmit FIFO empty interrupt mask.                                */
      __IOM uint32_t TXOIM      : 1;            /*!< [1..1] Transmit FIFO overflow interrupt mask.                             */
      __IOM uint32_t RXUIM      : 1;            /*!< [2..2] Receive FIFO underflow interrupt mask.                             */
      __IOM uint32_t RXOIM      : 1;            /*!< [3..3] Receive FIFO overflow interrupt mask.                              */
      __IOM uint32_t RXFIM      : 1;            /*!< [4..4] Receive FIFO full interrupt mask.                                  */
      __IOM uint32_t FSEIM      : 1;            /*!< [5..5] FIFO size error interrupt mask.                                    */
      __IOM uint32_t WBEIM      : 1;            /*!< [6..6] Write burst error interrupt mask.                                  */
      __IOM uint32_t BYEIM      : 1;            /*!< [7..7] Byte-Enable error interrupt mask.                                  */
      __IOM uint32_t ACEIM      : 1;            /*!< [8..8] Auto-check timeout error interrupt mask.                           */
      __IOM uint32_t TXSIM      : 1;            /*!< [9..9] Transmit split interrupt mask.                                     */
      __IOM uint32_t RXSIM      : 1;            /*!< [10..10] Transmit split interrupt mask.                                   */
      __IOM uint32_t ACSIM      : 1;            /*!< [11..11] Auto-check Flash Status raw interrupt mask.                      */
            uint32_t            : 20;
    } IMR_b;
  } ;
  
  union {
    __IM  uint32_t ISR;                         /*!< (@ 0x00000030) Interrupt Status Register                                  */
    
    struct {
      __IM  uint32_t TXEIS      : 1;            /*!< [0..0] Transmit FIFO empty interrupt status after masking. 1:
                                                     spi_txeir is active after masking. 0: spi_txeir is not
                                                     active after masking.                                                     */
      __IM  uint32_t TXOIS      : 1;            /*!< [1..1] Transmit FIFO overflow interrupt status after masking.
                                                     1: spi_txoir_r is active after masking. 0: spi_txoir_r
                                                     is not active after masking.                                              */
      __IM  uint32_t RXUIS      : 1;            /*!< [2..2] Receive FIFO underflow interrupt status after masking.
                                                     1: spi_rxuir_r is active after masking. 0: spi_rxuir_r
                                                     is not active after masking.                                              */
      __IM  uint32_t RXOIS      : 1;            /*!< [3..3] Receive FIFO overflow interrupt status after masking.
                                                     1: spi_rxoir_r is active after masking. 0: spi_rxoir_r
                                                     is not active after masking.                                              */
      __IM  uint32_t RXFIS      : 1;            /*!< [4..4] Receive FIFO full interrupt status after masking. 1:
                                                     spi_rxfir is active after masking. 0: spi_rxfir is not
                                                     active after masking.                                                     */
      __IM  uint32_t FSEIS      : 1;            /*!< [5..5] FIFO size error interrupts status after masking. 1: spi_fesir_r
                                                     is active after masking. 0: spi_fesir_r is not active after
                                                     masking.                                                                  */
      __IM  uint32_t WBEIS      : 1;            /*!< [6..6] Write burst error interrupt status after masking. 1:
                                                     spi_wbeir_r is active after masking. 0: spi_wbeir_r is
                                                     not active after masking.                                                 */
      __IM  uint32_t BYEIS      : 1;            /*!< [7..7] Byte-Enable error interrupts status after masking. 1:
                                                     spi_byeir_r is active after masking. 0: spi_byeir_r is
                                                     not active after masking.                                                 */
      __IM  uint32_t ACEIS      : 1;            /*!< [8..8] Auto-check timeout error status after masking. 1: spi_aceir_r
                                                     is active after masking. 0: spi_aceir_r is not active after
                                                     masking.                                                                  */
      __IM  uint32_t TXSIS      : 1;            /*!< [9..9] Transmit split interrupt status after masking. 1: spi_txsir_r
                                                     is active after masking. 0: spi_txsir_r is not active after
                                                     masking.                                                                  */
      __IM  uint32_t RXSIS      : 1;            /*!< [10..10] Receive split interrupt status after masking. 1: spi_rxsir_r
                                                     is active after masking. 0: spi_rxsir_r is not active after
                                                     masking.                                                                  */
      __IM  uint32_t ACSIS      : 1;            /*!< [11..11] Auto-check Flash Status after masking. 1: spi_aceir_r
                                                     is active after masking. 0: spi_aceir_r is not active after
                                                     masking.                                                                  */
            uint32_t            : 20;
    } ISR_b;
  } ;
  
  union {
    __IM  uint32_t RISR;                        /*!< (@ 0x00000034) Raw Interrupt Status Register                              */
    
    struct {
      __IM  uint32_t TXEIR      : 1;            /*!< [0..0] Transmit FIFO empty raw interrupt status prior to masking.
                                                     1: spi_txeir is active prior to masking. 0: spi_txeir is
                                                     not active prior to masking.                                              */
      __IM  uint32_t TXOIR      : 1;            /*!< [1..1] Transmit FIFO overflow raw interrupt status prior to
                                                     masking. 1: spi_txoir_r is active prior to masking. 0:
                                                     spi_txoir_r is not active prior to masking.                               */
      __IM  uint32_t RXUIR      : 1;            /*!< [2..2] Receive FIFO underflow raw interrupt status prior to
                                                     masking. 1: spi_rxuir_r is active prior to masking. 0:
                                                     spi_rxuir_r is not active prior to masking.                               */
      __IM  uint32_t RXOIR      : 1;            /*!< [3..3] Receive FIFO overflow raw interrupt status prior to masking.
                                                     1: spi_rxoir_r is active prior to masking. 0: spi_rxoir_r
                                                     is not active prior to masking.                                           */
      __IM  uint32_t RXFIR      : 1;            /*!< [4..4] Receive FIFO full raw interrupt status prior to masking.
                                                     1: spi_rxfir is active prior to masking. 0: spi_rxfir is
                                                     not active prior to masking.                                              */
      __IM  uint32_t FSEIR      : 1;            /*!< [5..5] FIFO size error raw interrupt status prior to masking.
                                                     1: spi_fseir_r is active prior to masking. 0: spi_fseir_r
                                                     is not active prior to masking.                                           */
      __IM  uint32_t WBEIR      : 1;            /*!< [6..6] Write burst error raw interrupt status prior to masking.
                                                     1: spi_wbeir_r is active prior to masking. 0: spi_wbeir_r
                                                     is not active prior to masking.                                           */
      __IM  uint32_t BYEIR      : 1;            /*!< [7..7] The Byte-Enable error interrupt raw status prior to masking.
                                                     1: spi_byeir_r is active prior to masking. 0: spi_byeir_r
                                                     is not active prior to masking.                                           */
      __IM  uint32_t ACEIR      : 1;            /*!< [8..8] Auto-check timeout error raw interrupt status prior to
                                                     masking. 1: spi_aceir_r is active prior to masking. 0:
                                                     spi_aceir_r is not active prior to masking.                               */
      __IM  uint32_t TXSIR      : 1;            /*!< [9..9] Transmit split interrupt status prior to masking. 1:
                                                     spi_txsir_r is active prior to masking. 0: spi_txsir_r
                                                     is not active prior to masking.                                           */
      __IM  uint32_t RXSIR      : 1;            /*!< [10..10] Receive split interrupt status prior to masking. 1:
                                                     spi_rxsir_r is active prior to masking. 0: spi_rxsir_r
                                                     is not active prior to masking.                                           */
      __IM  uint32_t ACSIR      : 1;            /*!< [11..11] Auto-check Flash Status raw interrupt status prior
                                                     to masking. 1: spi_acsir_r is active prior to masking.
                                                     0: spi_acsir_r is not active prior to masking.                            */
            uint32_t            : 20;
    } RISR_b;
  } ;
  __OM  uint32_t  TXOICR;                       /*!< (@ 0x00000038) Transmit FIFO Overflow Interrupt Clear Register            */
  __IM  uint32_t  RXOICR;                       /*!< (@ 0x0000003C) Receive FIFO Overflow Interrupt Clear Register             */
  __IM  uint32_t  RXUICR;                       /*!< (@ 0x00000040) Receive FIFO Underflow Interrupt Clear Register            */
  __OM  uint32_t  MSTICR;                       /*!< (@ 0x00000044) Master error Interrupt Clear Register                      */
  __OM  uint32_t  ICR;                          /*!< (@ 0x00000048) Interrupt Clear Register                                   */
  
  union {
    __IOM uint32_t DMACR;                       /*!< (@ 0x0000004C) DMA Control Register                                       */
    
    struct {
      __IOM uint32_t RX_DMAC_EN : 1;            /*!< [0..0] Receive DMA Enable. Enables/disables the receive FIFO
                                                     DMA channel. 0 = Receive DMA disabled, 1 = Receive DMA
                                                     enabled.                                                                  */
      __IOM uint32_t TX_DMAC_EN : 1;            /*!< [1..1] Transmit DMA Enable. Enables/disables the transmit FIFO
                                                     DMA channel. 0 = Transmit DMA disabled, 1 = Transmit DMA
                                                     enabled.                                                                  */
            uint32_t            : 30;
    } DMACR_b;
  } ;
  __IOM uint32_t  DMATDLR;                      /*!< (@ 0x00000050) DMA Transmit Data Level Register                           */
  __IOM uint32_t  DMARDLR;                      /*!< (@ 0x00000054) DMA Receive Data Level Register                            */
  __IM  uint32_t  IDR;                          /*!< (@ 0x00000058) Identification Register                                    */
  __IM  uint32_t  SPIC_VERSION;                 /*!< (@ 0x0000005C) SPIC version ID Register                                   */
  __IOM uint32_t  DR;                           /*!< (@ 0x00000060) Data Register                                              */
  __IM  uint32_t  RESERVED[15];
  __IOM uint32_t  DM_DR;                        /*!< (@ 0x000000A0) Data Mask Data Register                                    */
  __IM  uint32_t  RESERVED1[15];
  __IOM uint32_t  READ_FAST_SINGLE;             /*!< (@ 0x000000E0) Fast Read Data Command of SPI Flash                        */
  __IOM uint32_t  READ_DUAL_DATA;               /*!< (@ 0x000000E4) Dual Output Read Command of SPI Flash                      */
  __IOM uint32_t  READ_DUAL_ADDR_DATA;          /*!< (@ 0x000000E8) Dual I/O Read Command of SPI Flash                         */
  __IOM uint32_t  READ_QUAD_DATA;               /*!< (@ 0x000000EC) Quad Output Read Command of SPI Flash                      */
  
  union {
    __IOM uint32_t READ_QUAD_ADDR_DATA;         /*!< (@ 0x000000F0) Quad I/O Read Command of SPI Flash                         */
    
    struct {
      __IOM uint32_t RD_QUAD_IO_CMD : 8;        /*!< [7..0] SPI Flash command value for quad address and data read
                                                     command.                                                                  */
      __IOM uint32_t EXIT_PRM_DUM_LEN : 8;      /*!< [15..8] Extend the Exit PRM command if it is more than 1 byte.
                                                     It uses bus_clk as reference. For example, in QPI mode
                                                     (4-4-4), for FFFFFFFFh data cycle (4-byte data in 8 SPI
                                                     cycles), EXIT_PRM_CMD sends 1 byte (2 SPI cycles), and
                                                     EXIT_PRM_DUM_LEN extends 6 SPI cycles. (SPI cycles: 6 *
                                                     (2 * baud_rate)).                                                         */
      __IOM uint32_t PRM_VAL    : 8;            /*!< [23..16] High Performance Read Mode Value.                                */
      __IOM uint32_t EXIT_PRM_CMD : 8;          /*!< [31..24] Exit High Performance Read Mode command.                         */
    } READ_QUAD_ADDR_DATA_b;
  } ;
  __IOM uint32_t  WRITE_SINGLE;                 /*!< (@ 0x000000F4) Page Program Command of SPI Flash                          */
  __IOM uint32_t  WRITE_DUAL_DATA;              /*!< (@ 0x000000F8) Dual Data Input Program Command of SPI Flash               */
  __IOM uint32_t  WRITE_DUAL_ADDR_DATA;         /*!< (@ 0x000000FC) Dual Address and Data Output Read Command of
                                                                    SPI Flash                                                  */
  __IOM uint32_t  WRITE_QUAD_DATA;              /*!< (@ 0x00000100) Quad Data Input Program Command of SPI Flash               */
  __IOM uint32_t  WRITE_QUAD_ADDR_DATA;         /*!< (@ 0x00000104) Quad Address and Data Output Read Command of
                                                                    SPI Flash                                                  */
  
  union {
    __IOM uint32_t WRITE_ENABLE;                /*!< (@ 0x00000108) Write Enable Command of SPI Flash                          */
    
    struct {
      __IOM uint32_t WR_EN_CMD_1st_BYTE : 8;    /*!< [7..0] SPI Flash command value of the 1st byte of write enable.           */
      __IOM uint32_t WR_EN_CMD_2nd_BYTE : 8;    /*!< [15..8] SPI Flash command value of the 2nd byte of write enable.
                                                     Available only if DDR_EN configuration is defined.                        */
            uint32_t            : 16;
    } WRITE_ENABLE_b;
  } ;
  
  union {
    __IOM uint32_t READ_STATUS;                 /*!< (@ 0x0000010C) Read Status Command of SPI Flash                           */
    
    struct {
      __IOM uint32_t CMD_1ST_BYTE : 8;          /*!< [7..0] SPI Flash command value of the 1st byte of read status.            */
      __IOM uint32_t CMD_2ND_BYTE : 8;          /*!< [15..8] SPI Flash command value of the 2nd byte of read status.Available
                                                     only if DDR_EN is defined.                                                */
            uint32_t            : 11;
      __IOM uint32_t INTERVAL_EN : 1;           /*!< [27..27] Indicates SPI Flash read status with a 2-byte status
                                                     but checking only odd or even byte.                                       */
      __IOM uint32_t ADDR_SEL   : 1;            /*!< [28..28] Indicates SPI Flash read status with address and address
                                                     value.                                                                    */
      __IOM uint32_t ADDR_LEN   : 2;            /*!< [30..29] Indicates SPI Flash read status with address and address
                                                     length.Available only if DDR_EN is defined.                               */
      __IOM uint32_t ADDR_EN    : 1;            /*!< [31..31] Indicates SPI Flash read status with an address.                 */
    } READ_STATUS_b;
  } ;
  
  union {
    __IOM uint32_t CTRLR2;                      /*!< (@ 0x00000110) Control Register 2                                         */
    
    struct {
      __IOM uint32_t SO_DNUM    : 1;            /*!< [0..0] Indicates whether SO input pin of SPI Flash is connected
                                                     to spi_sout[0] or [1].                                                    */
      __IOM uint32_t WPN_SET    : 1;            /*!< [1..1] Implements the write protect function. If set to 1, WPn
                                                     is protected; otherwise, it is not.                                       */
      __IOM uint32_t WPN_DNUM   : 1;            /*!< [2..2] Indicates whether WPn input pin of SPI Flash is connected
                                                     to spi_sdata[2] or [3].                                                   */
      __IOM uint32_t SEQ_EN     : 1;            /*!< [3..3] Enables Data-Split Program/Read (FIFO size-independent
                                                     Program and Read).                                                        */
      __IOM uint32_t FIFO_ENTRY : 4;            /*!< [7..4] Indicates the valid entry of TX_FIFO if using SPIC_HAS_DMA
                                                     (NO_MERGE_FIFO).                                                          */
      __IOM uint32_t RX_FIFO_ENTRY : 4;         /*!< [11..8] Indicates the valid entry of RX FIFO if using SPIC_HAS_DMA
                                                     (NO_MERGE_FIFO).                                                          */
      __IOM uint32_t CS_ACTIVE_HOLD : 2;        /*!< [13..12] For Flash chip select active hold time after SCLK rising
                                                     edge. Refer to tSLCH/CHSH, tCSS/tCSH. Note: Wait up to
                                                     4 spic_clk cycles before CS becomes inactive.                             */
            uint32_t            : 18;
    } CTRLR2_b;
  } ;
  __IOM uint32_t  FBAUDR;                       /*!< (@ 0x00000114) Fast Baud Rate Select                                      */
  __IOM uint32_t  USER_LENGTH;                  /*!< (@ 0x00000118) User Length Register                                       */
  
  union {
    __IOM uint32_t AUTO_LENGTH;                 /*!< (@ 0x0000011C) Auto Address Length Register                               */
    
    struct {
      __IOM uint32_t RD_DUMMY_LENGTH : 12;      /*!< [11..0] Indicates delay cycles for receiving data, referenced
                                                     by bus_clk. Does not include cycles from pad to internal
                                                     SPIC.                                                                     */
      __IOM uint32_t IN_PHYSICAL_CYC : 4;       /*!< [15..12] Indicates how many SPIC CLK (bus_clk) cycles are from
                                                     the pad to the internal SPIC.                                             */
      __IOM uint32_t AUTO_ADDR_LENGTH : 2;      /*!< [17..16] Indicates the number of bytes address in read/write
                                                     command in auto mode. Can be set to 1, 2, or 3 bytes. A
                                                     setting of 0 transmits a 4-byte address. Ensure PRM_EN
                                                     in auto mode aligns with AUTO_ADDR_LENGTH.                                */
      __IOM uint32_t RDSR_DUMMY_LENGTH : 8;     /*!< [25..18] Indicates delay cycles for receiving data after Read
                                                     Status Register (RDSR) command in auto write or user mode
                                                     with auto check, referenced by bus_clk.                                   */
      __IOM uint32_t CS_H_RD_DUM_LEN : 2;       /*!< [27..26] Dummy cycle between sending read command to SPI Flash.
                                                     Similar handling to write command for avoiding CS high
                                                     time violations. Fine grain: CS high Read time = CS_H_RD_DUM_LEN
                                                     * bus_clk period Coarse grain: CS high Read time = (CS_H_WR_DUM_LEN
                                                     * bus_clk period) * 4, if CS_H_RD_DUM_LEN == 0                            */
      __IOM uint32_t CS_H_WR_DUM_LEN : 4;       /*!< [31..28] Dummy cycle between sending write command to SPI Flash.
                                                     Uses dummy cycles to avoid timing violation of CS high
                                                     time. Controls CS high Write time in either fine grain
                                                     or coarse grain. Fine grain: CS high Write time = CS_H_WR_DUM_LEN
                                                     * bus_clk period Coarse grain: CS high Write time = (CS_H_WR_DUM_LEN
                                                     * bus_clk period) * 4, if CS_H_RD_DUM_LEN == 0                            */
    } AUTO_LENGTH_b;
  } ;
  
  union {
    __IOM uint32_t VALID_CMD;                   /*!< (@ 0x00000120) Valid Command Register                                     */
    
    struct {
      __IOM uint32_t FRD_SINGLE : 1;            /*!< [0..0] Indicates that fast read command (1-1-1) is a valid command
                                                     to execute.                                                               */
      __IOM uint32_t RD_DUAL_I  : 1;            /*!< [1..1] Indicates that dual data read (1-1-2) is a valid command
                                                     to execute.                                                               */
      __IOM uint32_t RD_DUAL_IO : 1;            /*!< [2..2] Indicates that dual address/data read (1-2-2) is a valid
                                                     command to execute.                                                       */
      __IOM uint32_t RD_QUAD_O  : 1;            /*!< [3..3] Indicates that quad data read (1-1-4) is a valid command
                                                     to execute.                                                               */
      __IOM uint32_t RD_QUAD_IO : 1;            /*!< [4..4] Indicates that quad address/data read (1-4-4) is a valid
                                                     command to execute.                                                       */
      __IOM uint32_t WR_DUAL_I  : 1;            /*!< [5..5] Indicates that dual data write (1-1-2) is a valid command
                                                     to execute.                                                               */
      __IOM uint32_t WR_DUAL_II : 1;            /*!< [6..6] Indicates that dual address/data write (1-2-2) is a valid
                                                     command to execute.                                                       */
      __IOM uint32_t WR_QUAD_I  : 1;            /*!< [7..7] Indicates that quad data write (1-1-4) is a valid command
                                                     to execute.                                                               */
      __IOM uint32_t WR_QUAD_II : 1;            /*!< [8..8] Indicates that quad address/data write (1-4-4) is a valid
                                                     command to execute.                                                       */
      __IOM uint32_t WR_BLOCKING : 1;           /*!< [9..9] When set, ensures operations are blocking, and next operation
                                                     cannot proceed until FIFO is emptied. Otherwise, it is
                                                     non-blocking.                                                             */
            uint32_t            : 1;
      __IOM uint32_t PRM_EN     : 1;            /*!< [11..11] Enables SPIC performance read mode in Auto Mode. Uses
                                                     specific setup and exit flows to handle PRM.                              */
      __IOM uint32_t CTRLR0_CH  : 1;            /*!< [12..12] Configures SPIC to use CTRLR0 CMD_CH/DATA_CH/ADDR_CH
                                                     and DDR_EN fields in Auto mode. Otherwise, SPIC decodes
                                                     based on chosen VALID_CMD.                                                */
      __IOM uint32_t DUM_EN     : 1;            /*!< [13..13] Enables the use of a dummy byte (DUM_BYTE_VAL) following
                                                     the address in auto read. If PRM_EN is set, it uses PRM_Value
                                                     instead.                                                                  */
      __IOM uint32_t SEQ_TRANS_EN : 1;          /*!< [14..14] Enables read sequential transaction read function.
                                                     If two bus read transactions are sequential, SPIC accesses
                                                     the second transaction without resending Read CMD/ADDR/DUMMY.             */
            uint32_t            : 17;
    } VALID_CMD_b;
  } ;
  __IOM uint32_t  FLASH_SIZE;                   /*!< (@ 0x00000124) Flash Size Register                                        */
  
  union {
    __OM  uint32_t FLUSH_FIFO;                  /*!< (@ 0x00000128) Flush FIFO Register                                        */
    
    struct {
      __OM  uint32_t FLUSH_FIFO : 1;            /*!< [0..0] Clear all data in the FIFO upon writing to this field.             */
      __OM  uint32_t FLUSH_PGM_RST_FIFO : 1;    /*!< [1..1] Clear all data in the PGM_RST FIFO upon writing to this
                                                     field.                                                                    */
            uint32_t            : 30;
    } FLUSH_FIFO_b;
  } ;
  __IOM uint32_t  DUM_BYTE;                     /*!< (@ 0x0000012C) Dummy Byte Value                                           */
  __IOM uint32_t  TX_NDF;                       /*!< (@ 0x00000130) TX NDF                                                     */
  __IM  uint32_t  DEVICE_INFO;                  /*!< (@ 0x00000134) Device Info                                                */
  __IOM uint32_t  TPR0;                         /*!< (@ 0x00000138) Timing Parameters                                          */
  __IOM uint32_t  AUTO_LENGTH2;                 /*!< (@ 0x0000013C) Auto Address Length Register 2                             */
  __IOM uint32_t  TPR1;                         /*!< (@ 0x00000140) Timing Parameters Register 1                               */
  __IOM uint32_t  SLOT_STARVE;                  /*!< (@ 0x00000144) Slot starvation control register                           */
  __IOM uint32_t  PDEX_CTRL0;                   /*!< (@ 0x00000148) PDEX Ctrl Register 0                                       */
  __IOM uint32_t  PDEX_CTRL1;                   /*!< (@ 0x0000014C) PDEX Ctrl Register 1                                       */
  __IOM uint32_t  PDEX_CTRL2;                   /*!< (@ 0x00000150) PDEX Ctrl Register 2                                       */
  __IOM uint32_t  TPR2;                         /*!< (@ 0x00000154) Timing parameters Register 2                               */
  __IOM uint32_t  ICG_EN;                       /*!< (@ 0x00000158) Clock gating enable control register                       */
  __IOM uint32_t  WBUF_ID;                      /*!< (@ 0x0000015C) WBUF ID control register                                   */
  __IOM uint32_t  DCX_CTRL;                     /*!< (@ 0x00000160) LCDC DCX control register                                  */
  __IOM uint32_t  DCX_CMD;                      /*!< (@ 0x00000164) LCDC cmd phase DCX control bit value register              */
  __IOM uint32_t  DCX_ADDR;                     /*!< (@ 0x00000168) LCDC addr phase DCX control bit value register             */
  __IOM uint32_t  DCX_DATA;                     /*!< (@ 0x0000016C) LCDC data phase DCX control bit value register             */
  __IOM uint32_t  PAGE_CTRL0;                   /*!< (@ 0x00000170) NAND page ctrl Register 0                                  */
  __IOM uint32_t  PAGE_CTRL1;                   /*!< (@ 0x00000174) NAND page ctrl Register 1                                  */
  __IM  uint32_t  RESERVED2[2];
  __IOM uint32_t  ST_DR;                        /*!< (@ 0x00000180) Status Data Register                                       */
  __IM  uint32_t  RESERVED3[15];
  __IOM uint32_t  STFLR;                        /*!< (@ 0x000001C0) Status FIFO level Register                                 */
  __IM  uint32_t  RESERVED4[3];
  __IOM uint32_t  PAGE_READ;                    /*!< (@ 0x000001D0) Page Read Command of NAND Flash                            */
  __IM  uint32_t  RESERVED5[11];
  __IOM uint32_t  SEC_BASE_0;                   /*!< (@ 0x00000200) SEC region 0 base address register                         */
  __IOM uint32_t  SEC_END_0;                    /*!< (@ 0x00000204) SEC region 0 end address register                          */
  __IOM uint32_t  SEC_NONCE_0;                  /*!< (@ 0x00000208) SEC region 0 nonce register                                */
  __IM  uint32_t  RESERVED6[124];
  __IM  uint32_t  SEC_IDR;                      /*!< (@ 0x000003FC) SEC ID register                                            */
} SPIC_Type;                                    /*!< Size = 1024 (0x400)                                                       */



/* =========================================================================================================================== */
/* ================                                            DMA                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Realtek RXI-350 DMA Controller (DMA)
  */

typedef struct {                                /*!< (@ 0x40002000) DMA Structure                                              */
  __IOM uint32_t  SAR0;                         /*!< (@ 0x00000000) Channel 0 Source Address Register                          */
  __IM  uint32_t  CURR_SAR0;                    /*!< (@ 0x00000004) Channel 0 Current Source Address Register                  */
  __IOM uint32_t  DAR0;                         /*!< (@ 0x00000008) Channel 0 Destination Address Register                     */
  __IM  uint32_t  CURR_DAR0;                    /*!< (@ 0x0000000C) Channel 0 Current Destination Address Register             */
  __IOM uint32_t  LLP0_L;                       /*!< (@ 0x00000010) Channel 0 low-32bits Linked List Pointer Register          */
  __IOM uint32_t  LLP0_H;                       /*!< (@ 0x00000014) Channel 0 high-32bits Linked List Pointer Register         */
  
  union {
    __IOM uint32_t CTL0_L;                      /*!< (@ 0x00000018) Channel 0 low-32bits Control Register                      */
    
    struct {
      __IOM uint32_t INT_EN     : 1;            /*!< [0..0] Interrupt Enable Bit. Globally enables interrupt sources
                                                     for the channel.                                                          */
      __IOM uint32_t DST_TR_WIDTH : 3;          /*!< [3..1] Destination Transfer Width. Specifies width of data transfer
                                                     to destination.                                                           */
      __IOM uint32_t SRC_TR_WIDTH : 3;          /*!< [6..4] Source Transfer Width. Specifies width of data transfer
                                                     from source.                                                              */
      __IOM uint32_t DINC       : 2;            /*!< [8..7] Destination Address Increment. Indicates increment behavior
                                                     for destination address.                                                  */
      __IOM uint32_t SINC       : 2;            /*!< [10..9] Source Address Increment. Indicates increment behavior
                                                     for source address.                                                       */
      __IOM uint32_t DEST_MSIZE : 3;            /*!< [13..11] Number of data items per destination burst transaction.          */
      __IOM uint32_t SRC_MSIZE  : 3;            /*!< [16..14] Number of data items per source burst transaction.               */
      __IOM uint32_t SRC_GATHER_EN : 1;         /*!< [17..17] Enables gather on the source side if conditions in
                                                     address control align.                                                    */
      __IOM uint32_t DST_SCATTER_EN : 1;        /*!< [18..18] Enables scatter on the destination side if conditions
                                                     in address control align.                                                 */
            uint32_t            : 1;
      __IOM uint32_t TT_FC      : 4;            /*!< [23..20] Transfer Type and Flow Control. Supports multiple transfer
                                                     types, with specific flow control.                                        */
            uint32_t            : 3;
      __IOM uint32_t LLP_DST_EN : 1;            /*!< [27..27] Enables block chaining on the destination side if high
                                                     and LLPx_L.LOC is non-zero.                                               */
      __IOM uint32_t LLP_SRC_EN : 1;            /*!< [28..28] Enables block chaining on the source side if high and
                                                     LLPx_L.LOC is non-zero.                                                   */
            uint32_t            : 3;
    } CTL0_L_b;
  } ;
  
  union {
    __IOM uint32_t CTL0_H;                      /*!< (@ 0x0000001C) Channel 0 high-32bits Control Register                     */
    
    struct {
      __IOM uint32_t BLOCK_TS   : 32;           /*!< [31..0] Block Transfer Size. Configures single transaction counts
                                                     per block, subject to AXI beat mapping.                                   */
    } CTL0_H_b;
  } ;
  __IOM uint32_t  BLK_COUNTER_REG0;             /*!< (@ 0x00000020) Channel 0 32bits Block Counter Register                    */
  __IOM uint32_t  REPEAT_PATTERN0;              /*!< (@ 0x00000024) Channel 0 32bits Memory Repeat Pattern Register            */
  __IM  uint32_t  RESERVED[6];
  
  union {
    __IOM uint32_t CFG0_L;                      /*!< (@ 0x00000040) Channel 0 low-32bits Configuration Register                */
    
    struct {
      __IM  uint32_t INACTIVE   : 1;            /*!< [0..0] Indicates if the channel is inactive.                              */
      __IM  uint32_t SRC_PCTL_OVER : 1;         /*!< [1..1] DMA Source bus protocol finish indicator.                          */
      __IM  uint32_t DST_PCTL_OVER : 1;         /*!< [2..2] DMA destination bus protocol finish indicator.                     */
            uint32_t            : 1;
      __IOM uint32_t CH_PRIOR   : 4;            /*!< [7..4] Channel priority configuration.                                    */
      __IOM uint32_t CH_SUSP    : 1;            /*!< [8..8] Channel Suspend. Suspends all DMA data transfers from
                                                     the source until this bit is cleared.                                     */
      __IOM uint32_t FIFO_EMPTY : 1;            /*!< [9..9] Indicates if there is data left in the channel FIFO.               */
      __IOM uint32_t HS_SEL_DST : 1;            /*!< [10..10] Destination Software or Hardware Handshaking Select.             */
      __IOM uint32_t HS_SEL_SRC : 1;            /*!< [11..11] Source Software or Hardware Handshaking Select.                  */
            uint32_t            : 6;
      __IM  uint32_t DST_HS_POL : 1;            /*!< [18..18] Destination Handshaking Interface Polarity.                      */
      __IM  uint32_t SRC_HS_POL : 1;            /*!< [19..19] Source Handshaking Interface Polarity.                           */
            uint32_t            : 10;
      __IOM uint32_t RELOAD_SRC : 1;            /*!< [30..30] Automatic Source Reload. Reloads SARx register from
                                                     its initial value at the end of every block for multi-block
                                                     transfers.                                                                */
      __IOM uint32_t RELOAD_DST : 1;            /*!< [31..31] Automatic Destination Reload. Reloads DARx register
                                                     from its initial value at the end of every block for multi-block
                                                     transfers.                                                                */
    } CFG0_L_b;
  } ;
  
  union {
    __IOM uint32_t CFG0_H;                      /*!< (@ 0x00000044) Channel 0 high-32bits Configuration Register               */
    
    struct {
      __IOM uint32_t FCMODE     : 1;            /*!< [0..0] Flow Control Mode.                                                 */
            uint32_t            : 2;
      __IOM uint32_t PROTCTL    : 1;            /*!< [3..3] Protection Control bit for secure transfers.                       */
      __IOM uint32_t DIRECT_CTL_EN : 1;         /*!< [4..4] Direct Control for channel enabling.                               */
      __IOM uint32_t CONT_SAR   : 1;            /*!< [5..5] Continuous for SAR between single block.                           */
      __IOM uint32_t CONT_DAR   : 1;            /*!< [6..6] Continuous for DAR between single block.                           */
      __IOM uint32_t SRC_PER    : 4;            /*!< [10..7] Assigns a hardware handshaking interface for the source
                                                     of channel x.                                                             */
      __IOM uint32_t DEST_PER   : 4;            /*!< [14..11] Assigns a hardware handshaking interface for the destination
                                                     of channel x.                                                             */
      __IOM uint32_t Extended_SRC_PER1 : 1;     /*!< [15..15] Extended 4th bit of SRC_PER if hardware handshake interfaces
                                                     are configured to (16, 128].                                              */
      __IOM uint32_t Extended_DEST_PER1 : 1;    /*!< [16..16] Extended 4th bit of DEST_PER if hardware handshake
                                                     interfaces are configured to (16, 128].                                   */
      __IOM uint32_t Extended_SRC_PER2 : 1;     /*!< [17..17] Extended 5th bit of SRC_PER if hardware handshake interfaces
                                                     are configured to (32, 128].                                              */
      __IOM uint32_t Extended_DEST_PER2 : 1;    /*!< [18..18] Extended 5th bit of DEST_PER if hardware handshake
                                                     interfaces are configured to (32, 128].                                   */
      __IOM uint32_t Extended_SRC_PER3 : 1;     /*!< [19..19] Extended 6th bit of SRC_PER if hardware handshake interfaces
                                                     are configured to (64, 128].                                              */
      __IOM uint32_t Extended_DEST_PER3 : 1;    /*!< [20..20] Extended 6th bit of DEST_PER if hardware handshake
                                                     interfaces are configured to (64, 128].                                   */
            uint32_t            : 11;
    } CFG0_H_b;
  } ;
  
  union {
    __IOM uint32_t SGR0_L;                      /*!< (@ 0x00000048) Channel 0 low-32bits Source Gather Register                */
    
    struct {
      __IOM uint32_t SGI        : 20;           /*!< [19..0] Source gather interval.                                           */
      __IOM uint32_t SGC        : 12;           /*!< [31..20] Source gather count. Source contiguous transfer count
                                                     between successive gather boundaries.                                     */
    } SGR0_L_b;
  } ;
  
  union {
    __IOM uint32_t SGR0_H;                      /*!< (@ 0x0000004C) Channel 0 high-32bits Source Gather Register               */
    
    struct {
      __IOM uint32_t SGSN       : 16;           /*!< [15..0] Source gather circular streaming number. Enables circular
                                                     gather feature if set greater than 1.                                     */
      __IM  uint32_t BLOCK_TS_L : 16;           /*!< [31..16] Low 16-bits of Block Transfer Size. Indicates the total
                                                     number of single transactions per block transfer.                         */
    } SGR0_H_b;
  } ;
  __IOM uint32_t  DSR0_L;                       /*!< (@ 0x00000050) Channel 0 low-32bits Destination Scatter Register          */
  __IOM uint32_t  DSR0_H;                       /*!< (@ 0x00000054) Channel 0 high-32bits Destination Scatter Register         */
  __IOM uint32_t  SAR1;                         /*!< (@ 0x00000058) Channel 1 Source Address Register                          */
  __IM  uint32_t  CURR_SAR1;                    /*!< (@ 0x0000005C) Channel 1 Current Source Address Register                  */
  __IOM uint32_t  DAR1;                         /*!< (@ 0x00000060) Channel 1 Destination Address Register                     */
  __IM  uint32_t  CURR_DAR1;                    /*!< (@ 0x00000064) Channel 1 Current Destination Address Register             */
  __IOM uint32_t  LLP1_L;                       /*!< (@ 0x00000068) Channel 1 low-32bits Linked List Pointer Register          */
  __IOM uint32_t  LLP1_H;                       /*!< (@ 0x0000006C) Channel 1 high-32bits Linked List Pointer Register         */
  
  union {
    __IOM uint32_t CTL1_L;                      /*!< (@ 0x00000070) Channel 1 low-32bits Control Register                      */
    
    struct {
      __IOM uint32_t INT_EN     : 1;            /*!< [0..0] Interrupt Enable Bit. Globally enables interrupt sources
                                                     for the channel.                                                          */
      __IOM uint32_t DST_TR_WIDTH : 3;          /*!< [3..1] Destination Transfer Width. Specifies width of data transfer
                                                     to destination.                                                           */
      __IOM uint32_t SRC_TR_WIDTH : 3;          /*!< [6..4] Source Transfer Width. Specifies width of data transfer
                                                     from source.                                                              */
      __IOM uint32_t DINC       : 2;            /*!< [8..7] Destination Address Increment. Indicates increment behavior
                                                     for destination address.                                                  */
      __IOM uint32_t SINC       : 2;            /*!< [10..9] Source Address Increment. Indicates increment behavior
                                                     for source address.                                                       */
      __IOM uint32_t DEST_MSIZE : 3;            /*!< [13..11] Number of data items per destination burst transaction.          */
      __IOM uint32_t SRC_MSIZE  : 3;            /*!< [16..14] Number of data items per source burst transaction.               */
      __IOM uint32_t SRC_GATHER_EN : 1;         /*!< [17..17] Enables gather on the source side if conditions in
                                                     address control align.                                                    */
      __IOM uint32_t DST_SCATTER_EN : 1;        /*!< [18..18] Enables scatter on the destination side if conditions
                                                     in address control align.                                                 */
            uint32_t            : 1;
      __IOM uint32_t TT_FC      : 4;            /*!< [23..20] Transfer Type and Flow Control. Supports multiple transfer
                                                     types, with specific flow control.                                        */
            uint32_t            : 3;
      __IOM uint32_t LLP_DST_EN : 1;            /*!< [27..27] Enables block chaining on the destination side if high
                                                     and LLPx_L.LOC is non-zero.                                               */
      __IOM uint32_t LLP_SRC_EN : 1;            /*!< [28..28] Enables block chaining on the source side if high and
                                                     LLPx_L.LOC is non-zero.                                                   */
            uint32_t            : 3;
    } CTL1_L_b;
  } ;
  
  union {
    __IOM uint32_t CTL1_H;                      /*!< (@ 0x00000074) Channel 1 low-32bits Control Register                      */
    
    struct {
      __IOM uint32_t BLOCK_TS   : 32;           /*!< [31..0] Block Transfer Size. Configures single transaction counts
                                                     per block, subject to AXI beat mapping.                                   */
    } CTL1_H_b;
  } ;
  __IOM uint32_t  BLK_COUNTER_REG1;             /*!< (@ 0x00000078) Channel 1 32bits Block Counter Register                    */
  __IOM uint32_t  REPEAT_PATTERN1;              /*!< (@ 0x0000007C) Channel 1 32bits Memory Repeat Pattern Register            */
  __IM  uint32_t  RESERVED1[6];
  
  union {
    __IOM uint32_t CFG1_L;                      /*!< (@ 0x00000098) Channel 1 low-32bits Configuration Register                */
    
    struct {
      __IM  uint32_t INACTIVE   : 1;            /*!< [0..0] Indicates if the channel is inactive.                              */
      __IM  uint32_t SRC_PCTL_OVER : 1;         /*!< [1..1] DMA Source bus protocol finish indicator.                          */
      __IM  uint32_t DST_PCTL_OVER : 1;         /*!< [2..2] DMA destination bus protocol finish indicator.                     */
            uint32_t            : 1;
      __IOM uint32_t CH_PRIOR   : 4;            /*!< [7..4] Channel priority configuration.                                    */
      __IOM uint32_t CH_SUSP    : 1;            /*!< [8..8] Channel Suspend. Suspends all DMA data transfers from
                                                     the source until this bit is cleared.                                     */
      __IOM uint32_t FIFO_EMPTY : 1;            /*!< [9..9] Indicates if there is data left in the channel FIFO.               */
      __IOM uint32_t HS_SEL_DST : 1;            /*!< [10..10] Destination Software or Hardware Handshaking Select.             */
      __IOM uint32_t HS_SEL_SRC : 1;            /*!< [11..11] Source Software or Hardware Handshaking Select.                  */
            uint32_t            : 6;
      __IM  uint32_t DST_HS_POL : 1;            /*!< [18..18] Destination Handshaking Interface Polarity.                      */
      __IM  uint32_t SRC_HS_POL : 1;            /*!< [19..19] Source Handshaking Interface Polarity.                           */
            uint32_t            : 10;
      __IOM uint32_t RELOAD_SRC : 1;            /*!< [30..30] Automatic Source Reload. Reloads SARx register from
                                                     its initial value at the end of every block for multi-block
                                                     transfers.                                                                */
      __IOM uint32_t RELOAD_DST : 1;            /*!< [31..31] Automatic Destination Reload. Reloads DARx register
                                                     from its initial value at the end of every block for multi-block
                                                     transfers.                                                                */
    } CFG1_L_b;
  } ;
  
  union {
    __IOM uint32_t CFG1_H;                      /*!< (@ 0x0000009C) Channel 1 high-32bits Configuration Register               */
    
    struct {
      __IOM uint32_t FCMODE     : 1;            /*!< [0..0] Flow Control Mode.                                                 */
            uint32_t            : 2;
      __IOM uint32_t PROTCTL    : 1;            /*!< [3..3] Protection Control bit for secure transfers.                       */
      __IOM uint32_t DIRECT_CTL_EN : 1;         /*!< [4..4] Direct Control for channel enabling.                               */
      __IOM uint32_t CONT_SAR   : 1;            /*!< [5..5] Continuous for SAR between single block.                           */
      __IOM uint32_t CONT_DAR   : 1;            /*!< [6..6] Continuous for DAR between single block.                           */
      __IOM uint32_t SRC_PER    : 4;            /*!< [10..7] Assigns a hardware handshaking interface for the source
                                                     of channel x.                                                             */
      __IOM uint32_t DEST_PER   : 4;            /*!< [14..11] Assigns a hardware handshaking interface for the destination
                                                     of channel x.                                                             */
      __IOM uint32_t Extended_SRC_PER1 : 1;     /*!< [15..15] Extended 4th bit of SRC_PER if hardware handshake interfaces
                                                     are configured to (16, 128].                                              */
      __IOM uint32_t Extended_DEST_PER1 : 1;    /*!< [16..16] Extended 4th bit of DEST_PER if hardware handshake
                                                     interfaces are configured to (16, 128].                                   */
      __IOM uint32_t Extended_SRC_PER2 : 1;     /*!< [17..17] Extended 5th bit of SRC_PER if hardware handshake interfaces
                                                     are configured to (32, 128].                                              */
      __IOM uint32_t Extended_DEST_PER2 : 1;    /*!< [18..18] Extended 5th bit of DEST_PER if hardware handshake
                                                     interfaces are configured to (32, 128].                                   */
      __IOM uint32_t Extended_SRC_PER3 : 1;     /*!< [19..19] Extended 6th bit of SRC_PER if hardware handshake interfaces
                                                     are configured to (64, 128].                                              */
      __IOM uint32_t Extended_DEST_PER3 : 1;    /*!< [20..20] Extended 6th bit of DEST_PER if hardware handshake
                                                     interfaces are configured to (64, 128].                                   */
            uint32_t            : 11;
    } CFG1_H_b;
  } ;
  
  union {
    __IOM uint32_t SGR1_L;                      /*!< (@ 0x000000A0) Channel 1 Source Gather Configuration Register             */
    
    struct {
      __IOM uint32_t SGI        : 20;           /*!< [19..0] Source gather interval.                                           */
      __IOM uint32_t SGC        : 12;           /*!< [31..20] Source gather count. Source contiguous transfer count
                                                     between successive gather boundaries.                                     */
    } SGR1_L_b;
  } ;
  
  union {
    __IOM uint32_t SGR1_H;                      /*!< (@ 0x000000A4) Channel 1 Source Gather High Configuration Register        */
    
    struct {
      __IOM uint32_t SGSN       : 16;           /*!< [15..0] Source gather circular streaming number. Enables circular
                                                     gather feature if set greater than 1.                                     */
      __IM  uint32_t BLOCK_TS_L : 16;           /*!< [31..16] Low 16-bits of Block Transfer Size. Indicates the total
                                                     number of single transactions per block transfer.                         */
    } SGR1_H_b;
  } ;
  __IOM uint32_t  DSR1_L;                       /*!< (@ 0x000000A8) Channel 1 low-32bits Destination Scatter Register          */
  __IOM uint32_t  DSR1_H;                       /*!< (@ 0x000000AC) Channel 1 high-32bits Destination Scatter Register         */
  __IOM uint32_t  SAR2;                         /*!< (@ 0x000000B0) Channel 2 Source Address Register                          */
  __IM  uint32_t  CURR_SAR2;                    /*!< (@ 0x000000B4) Channel 2 Current Source Address Register                  */
  __IOM uint32_t  DAR2;                         /*!< (@ 0x000000B8) Channel 2 Destination Address Register                     */
  __IM  uint32_t  CURR_DAR2;                    /*!< (@ 0x000000BC) Channel 2 Current Destination Address Register             */
  __IOM uint32_t  LLP2_L;                       /*!< (@ 0x000000C0) Channel 2 low-32bits Linked List Pointer Register          */
  __IOM uint32_t  LLP2_H;                       /*!< (@ 0x000000C4) Channel 2 high-32bits Linked List Pointer Register         */
  
  union {
    __IOM uint32_t CTL2_L;                      /*!< (@ 0x000000C8) Channel 2 low-32bits Control Register                      */
    
    struct {
      __IOM uint32_t INT_EN     : 1;            /*!< [0..0] Interrupt Enable Bit. Globally enables interrupt sources
                                                     for the channel.                                                          */
      __IOM uint32_t DST_TR_WIDTH : 3;          /*!< [3..1] Destination Transfer Width. Specifies width of data transfer
                                                     to destination.                                                           */
      __IOM uint32_t SRC_TR_WIDTH : 3;          /*!< [6..4] Source Transfer Width. Specifies width of data transfer
                                                     from source.                                                              */
      __IOM uint32_t DINC       : 2;            /*!< [8..7] Destination Address Increment. Indicates increment behavior
                                                     for destination address.                                                  */
      __IOM uint32_t SINC       : 2;            /*!< [10..9] Source Address Increment. Indicates increment behavior
                                                     for source address.                                                       */
      __IOM uint32_t DEST_MSIZE : 3;            /*!< [13..11] Number of data items per destination burst transaction.          */
      __IOM uint32_t SRC_MSIZE  : 3;            /*!< [16..14] Number of data items per source burst transaction.               */
      __IOM uint32_t SRC_GATHER_EN : 1;         /*!< [17..17] Enables gather on the source side if conditions in
                                                     address control align.                                                    */
      __IOM uint32_t DST_SCATTER_EN : 1;        /*!< [18..18] Enables scatter on the destination side if conditions
                                                     in address control align.                                                 */
            uint32_t            : 1;
      __IOM uint32_t TT_FC      : 4;            /*!< [23..20] Transfer Type and Flow Control. Supports multiple transfer
                                                     types, with specific flow control.                                        */
            uint32_t            : 3;
      __IOM uint32_t LLP_DST_EN : 1;            /*!< [27..27] Enables block chaining on the destination side if high
                                                     and LLPx_L.LOC is non-zero.                                               */
      __IOM uint32_t LLP_SRC_EN : 1;            /*!< [28..28] Enables block chaining on the source side if high and
                                                     LLPx_L.LOC is non-zero.                                                   */
            uint32_t            : 3;
    } CTL2_L_b;
  } ;
  
  union {
    __IOM uint32_t CTL2_H;                      /*!< (@ 0x000000CC) Channel 2 high-32bits Control Register                     */
    
    struct {
      __IOM uint32_t BLOCK_TS   : 32;           /*!< [31..0] Block Transfer Size. Configures single transaction counts
                                                     per block, subject to AXI beat mapping.                                   */
    } CTL2_H_b;
  } ;
  __IOM uint32_t  BLK_COUNTER_REG2;             /*!< (@ 0x000000D0) Channel 2 32bits Block Counter Register                    */
  __IOM uint32_t  REPEAT_PATTERN2;              /*!< (@ 0x000000D4) Channel 2 32bits Memory Repeat Pattern Register            */
  __IM  uint32_t  RESERVED2[6];
  
  union {
    __IOM uint32_t CFG2_L;                      /*!< (@ 0x000000F0) Channel 2 low-32bits Configuration Register                */
    
    struct {
      __IM  uint32_t INACTIVE   : 1;            /*!< [0..0] Indicates if the channel is inactive.                              */
      __IM  uint32_t SRC_PCTL_OVER : 1;         /*!< [1..1] DMA Source bus protocol finish indicator.                          */
      __IM  uint32_t DST_PCTL_OVER : 1;         /*!< [2..2] DMA destination bus protocol finish indicator.                     */
            uint32_t            : 1;
      __IOM uint32_t CH_PRIOR   : 4;            /*!< [7..4] Channel priority configuration.                                    */
      __IOM uint32_t CH_SUSP    : 1;            /*!< [8..8] Channel Suspend. Suspends all DMA data transfers from
                                                     the source until this bit is cleared.                                     */
      __IOM uint32_t FIFO_EMPTY : 1;            /*!< [9..9] Indicates if there is data left in the channel FIFO.               */
      __IOM uint32_t HS_SEL_DST : 1;            /*!< [10..10] Destination Software or Hardware Handshaking Select.             */
      __IOM uint32_t HS_SEL_SRC : 1;            /*!< [11..11] Source Software or Hardware Handshaking Select.                  */
            uint32_t            : 6;
      __IM  uint32_t DST_HS_POL : 1;            /*!< [18..18] Destination Handshaking Interface Polarity.                      */
      __IM  uint32_t SRC_HS_POL : 1;            /*!< [19..19] Source Handshaking Interface Polarity.                           */
            uint32_t            : 10;
      __IOM uint32_t RELOAD_SRC : 1;            /*!< [30..30] Automatic Source Reload. Reloads SARx register from
                                                     its initial value at the end of every block for multi-block
                                                     transfers.                                                                */
      __IOM uint32_t RELOAD_DST : 1;            /*!< [31..31] Automatic Destination Reload. Reloads DARx register
                                                     from its initial value at the end of every block for multi-block
                                                     transfers.                                                                */
    } CFG2_L_b;
  } ;
  
  union {
    __IOM uint32_t CFG2_H;                      /*!< (@ 0x000000F4) Channel 2 high-32bits Configuration Register               */
    
    struct {
      __IOM uint32_t FCMODE     : 1;            /*!< [0..0] Flow Control Mode.                                                 */
            uint32_t            : 2;
      __IOM uint32_t PROTCTL    : 1;            /*!< [3..3] Protection Control bit for secure transfers.                       */
      __IOM uint32_t DIRECT_CTL_EN : 1;         /*!< [4..4] Direct Control for channel enabling.                               */
      __IOM uint32_t CONT_SAR   : 1;            /*!< [5..5] Continuous for SAR between single block.                           */
      __IOM uint32_t CONT_DAR   : 1;            /*!< [6..6] Continuous for DAR between single block.                           */
      __IOM uint32_t SRC_PER    : 4;            /*!< [10..7] Assigns a hardware handshaking interface for the source
                                                     of channel x.                                                             */
      __IOM uint32_t DEST_PER   : 4;            /*!< [14..11] Assigns a hardware handshaking interface for the destination
                                                     of channel x.                                                             */
      __IOM uint32_t Extended_SRC_PER1 : 1;     /*!< [15..15] Extended 4th bit of SRC_PER if hardware handshake interfaces
                                                     are configured to (16, 128].                                              */
      __IOM uint32_t Extended_DEST_PER1 : 1;    /*!< [16..16] Extended 4th bit of DEST_PER if hardware handshake
                                                     interfaces are configured to (16, 128].                                   */
      __IOM uint32_t Extended_SRC_PER2 : 1;     /*!< [17..17] Extended 5th bit of SRC_PER if hardware handshake interfaces
                                                     are configured to (32, 128].                                              */
      __IOM uint32_t Extended_DEST_PER2 : 1;    /*!< [18..18] Extended 5th bit of DEST_PER if hardware handshake
                                                     interfaces are configured to (32, 128].                                   */
      __IOM uint32_t Extended_SRC_PER3 : 1;     /*!< [19..19] Extended 6th bit of SRC_PER if hardware handshake interfaces
                                                     are configured to (64, 128].                                              */
      __IOM uint32_t Extended_DEST_PER3 : 1;    /*!< [20..20] Extended 6th bit of DEST_PER if hardware handshake
                                                     interfaces are configured to (64, 128].                                   */
            uint32_t            : 11;
    } CFG2_H_b;
  } ;
  
  union {
    __IOM uint32_t SGR2_L;                      /*!< (@ 0x000000F8) Channel 2 Source Gather Configuration Register             */
    
    struct {
      __IOM uint32_t SGI        : 20;           /*!< [19..0] Source gather interval.                                           */
      __IOM uint32_t SGC        : 12;           /*!< [31..20] Source gather count. Source contiguous transfer count
                                                     between successive gather boundaries.                                     */
    } SGR2_L_b;
  } ;
  
  union {
    __IOM uint32_t SGR2_H;                      /*!< (@ 0x000000FC) Channel 2 Source Gather High Configuration Register        */
    
    struct {
      __IOM uint32_t SGSN       : 16;           /*!< [15..0] Source gather circular streaming number. Enables circular
                                                     gather feature if set greater than 1.                                     */
      __IM  uint32_t BLOCK_TS_L : 16;           /*!< [31..16] Low 16-bits of Block Transfer Size. Indicates the total
                                                     number of single transactions per block transfer.                         */
    } SGR2_H_b;
  } ;
  __IOM uint32_t  DSR2_L;                       /*!< (@ 0x00000100) Channel 2 low-32bits Destination Scatter Register          */
  __IOM uint32_t  DSR2_H;                       /*!< (@ 0x00000104) Channel 2 high-32bits Destination Scatter Register         */
  __IOM uint32_t  SAR3;                         /*!< (@ 0x00000108) Channel 3 Source Address Register                          */
  __IM  uint32_t  CURR_SAR3;                    /*!< (@ 0x0000010C) Channel 3 Current Source Address Register                  */
  __IOM uint32_t  DAR3;                         /*!< (@ 0x00000110) Channel 3 Destination Address Register                     */
  __IM  uint32_t  CURR_DAR3;                    /*!< (@ 0x00000114) Channel 3 Current Destination Address Register             */
  __IOM uint32_t  LLP3_L;                       /*!< (@ 0x00000118) Channel 3 low-32bits Linked List Pointer Register          */
  __IOM uint32_t  LLP3_H;                       /*!< (@ 0x0000011C) Channel 3 high-32bits Linked List Pointer Register         */
  
  union {
    __IOM uint32_t CTL3_L;                      /*!< (@ 0x00000120) Channel 3 low-32bits Control Register                      */
    
    struct {
      __IOM uint32_t INT_EN     : 1;            /*!< [0..0] Interrupt Enable Bit. Globally enables interrupt sources
                                                     for the channel.                                                          */
      __IOM uint32_t DST_TR_WIDTH : 3;          /*!< [3..1] Destination Transfer Width. Specifies width of data transfer
                                                     to destination.                                                           */
      __IOM uint32_t SRC_TR_WIDTH : 3;          /*!< [6..4] Source Transfer Width. Specifies width of data transfer
                                                     from source.                                                              */
      __IOM uint32_t DINC       : 2;            /*!< [8..7] Destination Address Increment. Indicates increment behavior
                                                     for destination address.                                                  */
      __IOM uint32_t SINC       : 2;            /*!< [10..9] Source Address Increment. Indicates increment behavior
                                                     for source address.                                                       */
      __IOM uint32_t DEST_MSIZE : 3;            /*!< [13..11] Number of data items per destination burst transaction.          */
      __IOM uint32_t SRC_MSIZE  : 3;            /*!< [16..14] Number of data items per source burst transaction.               */
      __IOM uint32_t SRC_GATHER_EN : 1;         /*!< [17..17] Enables gather on the source side if conditions in
                                                     address control align.                                                    */
      __IOM uint32_t DST_SCATTER_EN : 1;        /*!< [18..18] Enables scatter on the destination side if conditions
                                                     in address control align.                                                 */
            uint32_t            : 1;
      __IOM uint32_t TT_FC      : 4;            /*!< [23..20] Transfer Type and Flow Control. Supports multiple transfer
                                                     types, with specific flow control.                                        */
            uint32_t            : 3;
      __IOM uint32_t LLP_DST_EN : 1;            /*!< [27..27] Enables block chaining on the destination side if high
                                                     and LLPx_L.LOC is non-zero.                                               */
      __IOM uint32_t LLP_SRC_EN : 1;            /*!< [28..28] Enables block chaining on the source side if high and
                                                     LLPx_L.LOC is non-zero.                                                   */
            uint32_t            : 3;
    } CTL3_L_b;
  } ;
  
  union {
    __IOM uint32_t CTL3_H;                      /*!< (@ 0x00000124) Channel 3 high-32bits Control Register                     */
    
    struct {
      __IOM uint32_t BLOCK_TS   : 32;           /*!< [31..0] Block Transfer Size. Configures single transaction counts
                                                     per block, subject to AXI beat mapping.                                   */
    } CTL3_H_b;
  } ;
  __IOM uint32_t  BLK_COUNTER_REG3;             /*!< (@ 0x00000128) Channel 3 32bits Block Counter Register                    */
  __IOM uint32_t  REPEAT_PATTERN3;              /*!< (@ 0x0000012C) Channel 3 32bits Memory Repeat Pattern Register            */
  __IM  uint32_t  RESERVED3[6];
  
  union {
    __IOM uint32_t CFG3_L;                      /*!< (@ 0x00000148) Channel 3 low-32bits Configuration Register                */
    
    struct {
      __IM  uint32_t INACTIVE   : 1;            /*!< [0..0] Indicates if the channel is inactive.                              */
      __IM  uint32_t SRC_PCTL_OVER : 1;         /*!< [1..1] DMA Source bus protocol finish indicator.                          */
      __IM  uint32_t DST_PCTL_OVER : 1;         /*!< [2..2] DMA destination bus protocol finish indicator.                     */
            uint32_t            : 1;
      __IOM uint32_t CH_PRIOR   : 4;            /*!< [7..4] Channel priority configuration.                                    */
      __IOM uint32_t CH_SUSP    : 1;            /*!< [8..8] Channel Suspend. Suspends all DMA data transfers from
                                                     the source until this bit is cleared.                                     */
      __IOM uint32_t FIFO_EMPTY : 1;            /*!< [9..9] Indicates if there is data left in the channel FIFO.               */
      __IOM uint32_t HS_SEL_DST : 1;            /*!< [10..10] Destination Software or Hardware Handshaking Select.             */
      __IOM uint32_t HS_SEL_SRC : 1;            /*!< [11..11] Source Software or Hardware Handshaking Select.                  */
            uint32_t            : 6;
      __IM  uint32_t DST_HS_POL : 1;            /*!< [18..18] Destination Handshaking Interface Polarity.                      */
      __IM  uint32_t SRC_HS_POL : 1;            /*!< [19..19] Source Handshaking Interface Polarity.                           */
            uint32_t            : 10;
      __IOM uint32_t RELOAD_SRC : 1;            /*!< [30..30] Automatic Source Reload. Reloads SARx register from
                                                     its initial value at the end of every block for multi-block
                                                     transfers.                                                                */
      __IOM uint32_t RELOAD_DST : 1;            /*!< [31..31] Automatic Destination Reload. Reloads DARx register
                                                     from its initial value at the end of every block for multi-block
                                                     transfers.                                                                */
    } CFG3_L_b;
  } ;
  
  union {
    __IOM uint32_t CFG3_H;                      /*!< (@ 0x0000014C) Channel 3 high-32bits Configuration Register               */
    
    struct {
      __IOM uint32_t FCMODE     : 1;            /*!< [0..0] Flow Control Mode.                                                 */
            uint32_t            : 2;
      __IOM uint32_t PROTCTL    : 1;            /*!< [3..3] Protection Control bit for secure transfers.                       */
      __IOM uint32_t DIRECT_CTL_EN : 1;         /*!< [4..4] Direct Control for channel enabling.                               */
      __IOM uint32_t CONT_SAR   : 1;            /*!< [5..5] Continuous for SAR between single block.                           */
      __IOM uint32_t CONT_DAR   : 1;            /*!< [6..6] Continuous for DAR between single block.                           */
      __IOM uint32_t SRC_PER    : 4;            /*!< [10..7] Assigns a hardware handshaking interface for the source
                                                     of channel x.                                                             */
      __IOM uint32_t DEST_PER   : 4;            /*!< [14..11] Assigns a hardware handshaking interface for the destination
                                                     of channel x.                                                             */
      __IOM uint32_t Extended_SRC_PER1 : 1;     /*!< [15..15] Extended 4th bit of SRC_PER if hardware handshake interfaces
                                                     are configured to (16, 128].                                              */
      __IOM uint32_t Extended_DEST_PER1 : 1;    /*!< [16..16] Extended 4th bit of DEST_PER if hardware handshake
                                                     interfaces are configured to (16, 128].                                   */
      __IOM uint32_t Extended_SRC_PER2 : 1;     /*!< [17..17] Extended 5th bit of SRC_PER if hardware handshake interfaces
                                                     are configured to (32, 128].                                              */
      __IOM uint32_t Extended_DEST_PER2 : 1;    /*!< [18..18] Extended 5th bit of DEST_PER if hardware handshake
                                                     interfaces are configured to (32, 128].                                   */
      __IOM uint32_t Extended_SRC_PER3 : 1;     /*!< [19..19] Extended 6th bit of SRC_PER if hardware handshake interfaces
                                                     are configured to (64, 128].                                              */
      __IOM uint32_t Extended_DEST_PER3 : 1;    /*!< [20..20] Extended 6th bit of DEST_PER if hardware handshake
                                                     interfaces are configured to (64, 128].                                   */
            uint32_t            : 11;
    } CFG3_H_b;
  } ;
  
  union {
    __IOM uint32_t SGR3_L;                      /*!< (@ 0x00000150) Channel 3 Source Gather Configuration Register             */
    
    struct {
      __IOM uint32_t SGI        : 20;           /*!< [19..0] Source gather interval.                                           */
      __IOM uint32_t SGC        : 12;           /*!< [31..20] Source gather count. Source contiguous transfer count
                                                     between successive gather boundaries.                                     */
    } SGR3_L_b;
  } ;
  
  union {
    __IOM uint32_t SGR3_H;                      /*!< (@ 0x00000154) Channel 3 Source Gather High Configuration Register        */
    
    struct {
      __IOM uint32_t SGSN       : 16;           /*!< [15..0] Source gather circular streaming number. Enables circular
                                                     gather feature if set greater than 1.                                     */
      __IM  uint32_t BLOCK_TS_L : 16;           /*!< [31..16] Low 16-bits of Block Transfer Size. Indicates the total
                                                     number of single transactions per block transfer.                         */
    } SGR3_H_b;
  } ;
  __IOM uint32_t  DSR3_L;                       /*!< (@ 0x00000158) Channel 3 low-32bits Destination Scatter Register          */
  __IOM uint32_t  DSR3_H;                       /*!< (@ 0x0000015C) Channel 3 high-32bits Destination Scatter Register         */
  __IOM uint32_t  SAR4;                         /*!< (@ 0x00000160) Channel 4 Source Address Register                          */
  __IM  uint32_t  CURR_SAR4;                    /*!< (@ 0x00000164) Channel 4 Current Source Address Register                  */
  __IOM uint32_t  DAR4;                         /*!< (@ 0x00000168) Channel 4 Destination Address Register                     */
  __IM  uint32_t  CURR_DAR4;                    /*!< (@ 0x0000016C) Channel 4 Current Destination Address Register             */
  __IOM uint32_t  LLP4_L;                       /*!< (@ 0x00000170) Channel 4 low-32bits Linked List Pointer Register          */
  __IOM uint32_t  LLP4_H;                       /*!< (@ 0x00000174) Channel 4 high-32bits Linked List Pointer Register         */
  
  union {
    __IOM uint32_t CTL4_L;                      /*!< (@ 0x00000178) Channel 4 low-32bits Control Register                      */
    
    struct {
      __IOM uint32_t INT_EN     : 1;            /*!< [0..0] Interrupt Enable Bit. Globally enables interrupt sources
                                                     for the channel.                                                          */
      __IOM uint32_t DST_TR_WIDTH : 3;          /*!< [3..1] Destination Transfer Width. Specifies width of data transfer
                                                     to destination.                                                           */
      __IOM uint32_t SRC_TR_WIDTH : 3;          /*!< [6..4] Source Transfer Width. Specifies width of data transfer
                                                     from source.                                                              */
      __IOM uint32_t DINC       : 2;            /*!< [8..7] Destination Address Increment. Indicates increment behavior
                                                     for destination address.                                                  */
      __IOM uint32_t SINC       : 2;            /*!< [10..9] Source Address Increment. Indicates increment behavior
                                                     for source address.                                                       */
      __IOM uint32_t DEST_MSIZE : 3;            /*!< [13..11] Number of data items per destination burst transaction.          */
      __IOM uint32_t SRC_MSIZE  : 3;            /*!< [16..14] Number of data items per source burst transaction.               */
      __IOM uint32_t SRC_GATHER_EN : 1;         /*!< [17..17] Enables gather on the source side if conditions in
                                                     address control align.                                                    */
      __IOM uint32_t DST_SCATTER_EN : 1;        /*!< [18..18] Enables scatter on the destination side if conditions
                                                     in address control align.                                                 */
            uint32_t            : 1;
      __IOM uint32_t TT_FC      : 4;            /*!< [23..20] Transfer Type and Flow Control. Supports multiple transfer
                                                     types, with specific flow control.                                        */
            uint32_t            : 3;
      __IOM uint32_t LLP_DST_EN : 1;            /*!< [27..27] Enables block chaining on the destination side if high
                                                     and LLPx_L.LOC is non-zero.                                               */
      __IOM uint32_t LLP_SRC_EN : 1;            /*!< [28..28] Enables block chaining on the source side if high and
                                                     LLPx_L.LOC is non-zero.                                                   */
            uint32_t            : 3;
    } CTL4_L_b;
  } ;
  
  union {
    __IOM uint32_t CTL4_H;                      /*!< (@ 0x0000017C) Channel 4 high-32bits Control Register                     */
    
    struct {
      __IOM uint32_t BLOCK_TS   : 32;           /*!< [31..0] Block Transfer Size. Configures single transaction counts
                                                     per block, subject to AXI beat mapping.                                   */
    } CTL4_H_b;
  } ;
  __IOM uint32_t  BLK_COUNTER_REG4;             /*!< (@ 0x00000180) Channel 4 32bits Block Counter Register                    */
  __IOM uint32_t  REPEAT_PATTERN4;              /*!< (@ 0x00000184) Channel 4 32bits Memory Repeat Pattern Register            */
  __IM  uint32_t  RESERVED4[6];
  
  union {
    __IOM uint32_t CFG4_L;                      /*!< (@ 0x000001A0) Channel 4 low-32bits Configuration Register                */
    
    struct {
      __IM  uint32_t INACTIVE   : 1;            /*!< [0..0] Indicates if the channel is inactive.                              */
      __IM  uint32_t SRC_PCTL_OVER : 1;         /*!< [1..1] DMA Source bus protocol finish indicator.                          */
      __IM  uint32_t DST_PCTL_OVER : 1;         /*!< [2..2] DMA destination bus protocol finish indicator.                     */
            uint32_t            : 1;
      __IOM uint32_t CH_PRIOR   : 4;            /*!< [7..4] Channel priority configuration.                                    */
      __IOM uint32_t CH_SUSP    : 1;            /*!< [8..8] Channel Suspend. Suspends all DMA data transfers from
                                                     the source until this bit is cleared.                                     */
      __IOM uint32_t FIFO_EMPTY : 1;            /*!< [9..9] Indicates if there is data left in the channel FIFO.               */
      __IOM uint32_t HS_SEL_DST : 1;            /*!< [10..10] Destination Software or Hardware Handshaking Select.             */
      __IOM uint32_t HS_SEL_SRC : 1;            /*!< [11..11] Source Software or Hardware Handshaking Select.                  */
            uint32_t            : 6;
      __IM  uint32_t DST_HS_POL : 1;            /*!< [18..18] Destination Handshaking Interface Polarity.                      */
      __IM  uint32_t SRC_HS_POL : 1;            /*!< [19..19] Source Handshaking Interface Polarity.                           */
            uint32_t            : 10;
      __IOM uint32_t RELOAD_SRC : 1;            /*!< [30..30] Automatic Source Reload. Reloads SARx register from
                                                     its initial value at the end of every block for multi-block
                                                     transfers.                                                                */
      __IOM uint32_t RELOAD_DST : 1;            /*!< [31..31] Automatic Destination Reload. Reloads DARx register
                                                     from its initial value at the end of every block for multi-block
                                                     transfers.                                                                */
    } CFG4_L_b;
  } ;
  
  union {
    __IOM uint32_t CFG4_H;                      /*!< (@ 0x000001A4) Channel 4 high-32bits Configuration Register               */
    
    struct {
      __IOM uint32_t FCMODE     : 1;            /*!< [0..0] Flow Control Mode.                                                 */
            uint32_t            : 2;
      __IOM uint32_t PROTCTL    : 1;            /*!< [3..3] Protection Control bit for secure transfers.                       */
      __IOM uint32_t DIRECT_CTL_EN : 1;         /*!< [4..4] Direct Control for channel enabling.                               */
      __IOM uint32_t CONT_SAR   : 1;            /*!< [5..5] Continuous for SAR between single block.                           */
      __IOM uint32_t CONT_DAR   : 1;            /*!< [6..6] Continuous for DAR between single block.                           */
      __IOM uint32_t SRC_PER    : 4;            /*!< [10..7] Assigns a hardware handshaking interface for the source
                                                     of channel x.                                                             */
      __IOM uint32_t DEST_PER   : 4;            /*!< [14..11] Assigns a hardware handshaking interface for the destination
                                                     of channel x.                                                             */
      __IOM uint32_t Extended_SRC_PER1 : 1;     /*!< [15..15] Extended 4th bit of SRC_PER if hardware handshake interfaces
                                                     are configured to (16, 128].                                              */
      __IOM uint32_t Extended_DEST_PER1 : 1;    /*!< [16..16] Extended 4th bit of DEST_PER if hardware handshake
                                                     interfaces are configured to (16, 128].                                   */
      __IOM uint32_t Extended_SRC_PER2 : 1;     /*!< [17..17] Extended 5th bit of SRC_PER if hardware handshake interfaces
                                                     are configured to (32, 128].                                              */
      __IOM uint32_t Extended_DEST_PER2 : 1;    /*!< [18..18] Extended 5th bit of DEST_PER if hardware handshake
                                                     interfaces are configured to (32, 128].                                   */
      __IOM uint32_t Extended_SRC_PER3 : 1;     /*!< [19..19] Extended 6th bit of SRC_PER if hardware handshake interfaces
                                                     are configured to (64, 128].                                              */
      __IOM uint32_t Extended_DEST_PER3 : 1;    /*!< [20..20] Extended 6th bit of DEST_PER if hardware handshake
                                                     interfaces are configured to (64, 128].                                   */
            uint32_t            : 11;
    } CFG4_H_b;
  } ;
  
  union {
    __IOM uint32_t SGR4_L;                      /*!< (@ 0x000001A8) Channel 4 Source Gather Configuration Register             */
    
    struct {
      __IOM uint32_t SGI        : 20;           /*!< [19..0] Source gather interval.                                           */
      __IOM uint32_t SGC        : 12;           /*!< [31..20] Source gather count. Source contiguous transfer count
                                                     between successive gather boundaries.                                     */
    } SGR4_L_b;
  } ;
  
  union {
    __IOM uint32_t SGR4_H;                      /*!< (@ 0x000001AC) Channel 4 Source Gather High Configuration Register        */
    
    struct {
      __IOM uint32_t SGSN       : 16;           /*!< [15..0] Source gather circular streaming number. Enables circular
                                                     gather feature if set greater than 1.                                     */
      __IM  uint32_t BLOCK_TS_L : 16;           /*!< [31..16] Low 16-bits of Block Transfer Size. Indicates the total
                                                     number of single transactions per block transfer.                         */
    } SGR4_H_b;
  } ;
  __IOM uint32_t  DSR4_L;                       /*!< (@ 0x000001B0) Channel 4 low-32bits Destination Scatter Register          */
  __IOM uint32_t  DSR4_H;                       /*!< (@ 0x000001B4) Channel 4 high-32bits Destination Scatter Register         */
  __IOM uint32_t  SAR5;                         /*!< (@ 0x000001B8) Channel 5 Source Address Register                          */
  __IM  uint32_t  CURR_SAR5;                    /*!< (@ 0x000001BC) Channel 5 Current Source Address Register                  */
  __IOM uint32_t  DAR5;                         /*!< (@ 0x000001C0) Channel 5 Destination Address Register                     */
  __IM  uint32_t  CURR_DAR5;                    /*!< (@ 0x000001C4) Channel 5 Current Destination Address Register             */
  __IOM uint32_t  LLP5_L;                       /*!< (@ 0x000001C8) Channel 5 low-32bits Linked List Pointer Register          */
  __IOM uint32_t  LLP5_H;                       /*!< (@ 0x000001CC) Channel 5 high-32bits Linked List Pointer Register         */
  
  union {
    __IOM uint32_t CTL5_L;                      /*!< (@ 0x000001D0) Channel 5 low-32bits Control Register                      */
    
    struct {
      __IOM uint32_t INT_EN     : 1;            /*!< [0..0] Interrupt Enable Bit. Globally enables interrupt sources
                                                     for the channel.                                                          */
      __IOM uint32_t DST_TR_WIDTH : 3;          /*!< [3..1] Destination Transfer Width. Specifies width of data transfer
                                                     to destination.                                                           */
      __IOM uint32_t SRC_TR_WIDTH : 3;          /*!< [6..4] Source Transfer Width. Specifies width of data transfer
                                                     from source.                                                              */
      __IOM uint32_t DINC       : 2;            /*!< [8..7] Destination Address Increment. Indicates increment behavior
                                                     for destination address.                                                  */
      __IOM uint32_t SINC       : 2;            /*!< [10..9] Source Address Increment. Indicates increment behavior
                                                     for source address.                                                       */
      __IOM uint32_t DEST_MSIZE : 3;            /*!< [13..11] Number of data items per destination burst transaction.          */
      __IOM uint32_t SRC_MSIZE  : 3;            /*!< [16..14] Number of data items per source burst transaction.               */
      __IOM uint32_t SRC_GATHER_EN : 1;         /*!< [17..17] Enables gather on the source side if conditions in
                                                     address control align.                                                    */
      __IOM uint32_t DST_SCATTER_EN : 1;        /*!< [18..18] Enables scatter on the destination side if conditions
                                                     in address control align.                                                 */
            uint32_t            : 1;
      __IOM uint32_t TT_FC      : 4;            /*!< [23..20] Transfer Type and Flow Control. Supports multiple transfer
                                                     types, with specific flow control.                                        */
            uint32_t            : 3;
      __IOM uint32_t LLP_DST_EN : 1;            /*!< [27..27] Enables block chaining on the destination side if high
                                                     and LLPx_L.LOC is non-zero.                                               */
      __IOM uint32_t LLP_SRC_EN : 1;            /*!< [28..28] Enables block chaining on the source side if high and
                                                     LLPx_L.LOC is non-zero.                                                   */
            uint32_t            : 3;
    } CTL5_L_b;
  } ;
  
  union {
    __IOM uint32_t CTL5_H;                      /*!< (@ 0x000001D4) Channel 5 high-32bits Control Register                     */
    
    struct {
      __IOM uint32_t BLOCK_TS   : 32;           /*!< [31..0] Block Transfer Size. Configures single transaction counts
                                                     per block, subject to AXI beat mapping.                                   */
    } CTL5_H_b;
  } ;
  __IOM uint32_t  BLK_COUNTER_REG5;             /*!< (@ 0x000001D8) Channel 5 32bits Block Counter Register                    */
  __IOM uint32_t  REPEAT_PATTERN5;              /*!< (@ 0x000001DC) Channel 5 32bits Memory Repeat Pattern Register            */
  __IM  uint32_t  RESERVED5[6];
  
  union {
    __IOM uint32_t CFG5_L;                      /*!< (@ 0x000001F8) Channel 5 low-32bits Configuration Register                */
    
    struct {
      __IM  uint32_t INACTIVE   : 1;            /*!< [0..0] Indicates if the channel is inactive.                              */
      __IM  uint32_t SRC_PCTL_OVER : 1;         /*!< [1..1] DMA Source bus protocol finish indicator.                          */
      __IM  uint32_t DST_PCTL_OVER : 1;         /*!< [2..2] DMA destination bus protocol finish indicator.                     */
            uint32_t            : 1;
      __IOM uint32_t CH_PRIOR   : 4;            /*!< [7..4] Channel priority configuration.                                    */
      __IOM uint32_t CH_SUSP    : 1;            /*!< [8..8] Channel Suspend. Suspends all DMA data transfers from
                                                     the source until this bit is cleared.                                     */
      __IOM uint32_t FIFO_EMPTY : 1;            /*!< [9..9] Indicates if there is data left in the channel FIFO.               */
      __IOM uint32_t HS_SEL_DST : 1;            /*!< [10..10] Destination Software or Hardware Handshaking Select.             */
      __IOM uint32_t HS_SEL_SRC : 1;            /*!< [11..11] Source Software or Hardware Handshaking Select.                  */
            uint32_t            : 6;
      __IM  uint32_t DST_HS_POL : 1;            /*!< [18..18] Destination Handshaking Interface Polarity.                      */
      __IM  uint32_t SRC_HS_POL : 1;            /*!< [19..19] Source Handshaking Interface Polarity.                           */
            uint32_t            : 10;
      __IOM uint32_t RELOAD_SRC : 1;            /*!< [30..30] Automatic Source Reload. Reloads SARx register from
                                                     its initial value at the end of every block for multi-block
                                                     transfers.                                                                */
      __IOM uint32_t RELOAD_DST : 1;            /*!< [31..31] Automatic Destination Reload. Reloads DARx register
                                                     from its initial value at the end of every block for multi-block
                                                     transfers.                                                                */
    } CFG5_L_b;
  } ;
  
  union {
    __IOM uint32_t CFG5_H;                      /*!< (@ 0x000001FC) Channel 5 high-32bits Configuration Register               */
    
    struct {
      __IOM uint32_t FCMODE     : 1;            /*!< [0..0] Flow Control Mode.                                                 */
            uint32_t            : 2;
      __IOM uint32_t PROTCTL    : 1;            /*!< [3..3] Protection Control bit for secure transfers.                       */
      __IOM uint32_t DIRECT_CTL_EN : 1;         /*!< [4..4] Direct Control for channel enabling.                               */
      __IOM uint32_t CONT_SAR   : 1;            /*!< [5..5] Continuous for SAR between single block.                           */
      __IOM uint32_t CONT_DAR   : 1;            /*!< [6..6] Continuous for DAR between single block.                           */
      __IOM uint32_t SRC_PER    : 4;            /*!< [10..7] Assigns a hardware handshaking interface for the source
                                                     of channel x.                                                             */
      __IOM uint32_t DEST_PER   : 4;            /*!< [14..11] Assigns a hardware handshaking interface for the destination
                                                     of channel x.                                                             */
      __IOM uint32_t Extended_SRC_PER1 : 1;     /*!< [15..15] Extended 4th bit of SRC_PER if hardware handshake interfaces
                                                     are configured to (16, 128].                                              */
      __IOM uint32_t Extended_DEST_PER1 : 1;    /*!< [16..16] Extended 4th bit of DEST_PER if hardware handshake
                                                     interfaces are configured to (16, 128].                                   */
      __IOM uint32_t Extended_SRC_PER2 : 1;     /*!< [17..17] Extended 5th bit of SRC_PER if hardware handshake interfaces
                                                     are configured to (32, 128].                                              */
      __IOM uint32_t Extended_DEST_PER2 : 1;    /*!< [18..18] Extended 5th bit of DEST_PER if hardware handshake
                                                     interfaces are configured to (32, 128].                                   */
      __IOM uint32_t Extended_SRC_PER3 : 1;     /*!< [19..19] Extended 6th bit of SRC_PER if hardware handshake interfaces
                                                     are configured to (64, 128].                                              */
      __IOM uint32_t Extended_DEST_PER3 : 1;    /*!< [20..20] Extended 6th bit of DEST_PER if hardware handshake
                                                     interfaces are configured to (64, 128].                                   */
            uint32_t            : 11;
    } CFG5_H_b;
  } ;
  
  union {
    __IOM uint32_t SGR5_L;                      /*!< (@ 0x00000200) Channel 5 Source Gather Configuration Register             */
    
    struct {
      __IOM uint32_t SGI        : 20;           /*!< [19..0] Source gather interval.                                           */
      __IOM uint32_t SGC        : 12;           /*!< [31..20] Source gather count. Source contiguous transfer count
                                                     between successive gather boundaries.                                     */
    } SGR5_L_b;
  } ;
  
  union {
    __IOM uint32_t SGR5_H;                      /*!< (@ 0x00000204) Channel 5 Source Gather High Configuration Register        */
    
    struct {
      __IOM uint32_t SGSN       : 16;           /*!< [15..0] Source gather circular streaming number. Enables circular
                                                     gather feature if set greater than 1.                                     */
      __IM  uint32_t BLOCK_TS_L : 16;           /*!< [31..16] Low 16-bits of Block Transfer Size. Indicates the total
                                                     number of single transactions per block transfer.                         */
    } SGR5_H_b;
  } ;
  __IOM uint32_t  DSR5_L;                       /*!< (@ 0x00000208) Channel 5 low-32bits Destination Scatter Register          */
  __IOM uint32_t  DSR5_H;                       /*!< (@ 0x0000020C) Channel 5 high-32bits Destination Scatter Register         */
  __IOM uint32_t  SAR6;                         /*!< (@ 0x00000210) Channel 6 Source Address Register                          */
  __IM  uint32_t  CURR_SAR6;                    /*!< (@ 0x00000214) Channel 6 Current Source Address Register                  */
  __IOM uint32_t  DAR6;                         /*!< (@ 0x00000218) Channel 6 Destination Address Register                     */
  __IM  uint32_t  CURR_DAR6;                    /*!< (@ 0x0000021C) Channel 6 Current Destination Address Register             */
  __IOM uint32_t  LLP6_L;                       /*!< (@ 0x00000220) Channel 6 low-32bits Linked List Pointer Register          */
  __IOM uint32_t  LLP6_H;                       /*!< (@ 0x00000224) Channel 6 high-32bits Linked List Pointer Register         */
  
  union {
    __IOM uint32_t CTL6_L;                      /*!< (@ 0x00000228) Channel 6 low-32bits Control Register                      */
    
    struct {
      __IOM uint32_t INT_EN     : 1;            /*!< [0..0] Interrupt Enable Bit. Globally enables interrupt sources
                                                     for the channel.                                                          */
      __IOM uint32_t DST_TR_WIDTH : 3;          /*!< [3..1] Destination Transfer Width. Specifies width of data transfer
                                                     to destination.                                                           */
      __IOM uint32_t SRC_TR_WIDTH : 3;          /*!< [6..4] Source Transfer Width. Specifies width of data transfer
                                                     from source.                                                              */
      __IOM uint32_t DINC       : 2;            /*!< [8..7] Destination Address Increment. Indicates increment behavior
                                                     for destination address.                                                  */
      __IOM uint32_t SINC       : 2;            /*!< [10..9] Source Address Increment. Indicates increment behavior
                                                     for source address.                                                       */
      __IOM uint32_t DEST_MSIZE : 3;            /*!< [13..11] Number of data items per destination burst transaction.          */
      __IOM uint32_t SRC_MSIZE  : 3;            /*!< [16..14] Number of data items per source burst transaction.               */
      __IOM uint32_t SRC_GATHER_EN : 1;         /*!< [17..17] Enables gather on the source side if conditions in
                                                     address control align.                                                    */
      __IOM uint32_t DST_SCATTER_EN : 1;        /*!< [18..18] Enables scatter on the destination side if conditions
                                                     in address control align.                                                 */
            uint32_t            : 1;
      __IOM uint32_t TT_FC      : 4;            /*!< [23..20] Transfer Type and Flow Control. Supports multiple transfer
                                                     types, with specific flow control.                                        */
            uint32_t            : 3;
      __IOM uint32_t LLP_DST_EN : 1;            /*!< [27..27] Enables block chaining on the destination side if high
                                                     and LLPx_L.LOC is non-zero.                                               */
      __IOM uint32_t LLP_SRC_EN : 1;            /*!< [28..28] Enables block chaining on the source side if high and
                                                     LLPx_L.LOC is non-zero.                                                   */
            uint32_t            : 3;
    } CTL6_L_b;
  } ;
  
  union {
    __IOM uint32_t CTL6_H;                      /*!< (@ 0x0000022C) Channel 6 high-32bits Control Register                     */
    
    struct {
      __IOM uint32_t BLOCK_TS   : 32;           /*!< [31..0] Block Transfer Size. Configures single transaction counts
                                                     per block, subject to AXI beat mapping.                                   */
    } CTL6_H_b;
  } ;
  __IOM uint32_t  BLK_COUNTER_REG6;             /*!< (@ 0x00000230) Channel 6 32bits Block Counter Register                    */
  __IOM uint32_t  REPEAT_PATTERN6;              /*!< (@ 0x00000234) Channel 6 32bits Memory Repeat Pattern Register            */
  __IM  uint32_t  RESERVED6[6];
  
  union {
    __IOM uint32_t CFG6_L;                      /*!< (@ 0x00000250) Channel 6 low-32bits Configuration Register                */
    
    struct {
      __IM  uint32_t INACTIVE   : 1;            /*!< [0..0] Indicates if the channel is inactive.                              */
      __IM  uint32_t SRC_PCTL_OVER : 1;         /*!< [1..1] DMA Source bus protocol finish indicator.                          */
      __IM  uint32_t DST_PCTL_OVER : 1;         /*!< [2..2] DMA destination bus protocol finish indicator.                     */
            uint32_t            : 1;
      __IOM uint32_t CH_PRIOR   : 4;            /*!< [7..4] Channel priority configuration.                                    */
      __IOM uint32_t CH_SUSP    : 1;            /*!< [8..8] Channel Suspend. Suspends all DMA data transfers from
                                                     the source until this bit is cleared.                                     */
      __IOM uint32_t FIFO_EMPTY : 1;            /*!< [9..9] Indicates if there is data left in the channel FIFO.               */
      __IOM uint32_t HS_SEL_DST : 1;            /*!< [10..10] Destination Software or Hardware Handshaking Select.             */
      __IOM uint32_t HS_SEL_SRC : 1;            /*!< [11..11] Source Software or Hardware Handshaking Select.                  */
            uint32_t            : 6;
      __IM  uint32_t DST_HS_POL : 1;            /*!< [18..18] Destination Handshaking Interface Polarity.                      */
      __IM  uint32_t SRC_HS_POL : 1;            /*!< [19..19] Source Handshaking Interface Polarity.                           */
            uint32_t            : 10;
      __IOM uint32_t RELOAD_SRC : 1;            /*!< [30..30] Automatic Source Reload. Reloads SARx register from
                                                     its initial value at the end of every block for multi-block
                                                     transfers.                                                                */
      __IOM uint32_t RELOAD_DST : 1;            /*!< [31..31] Automatic Destination Reload. Reloads DARx register
                                                     from its initial value at the end of every block for multi-block
                                                     transfers.                                                                */
    } CFG6_L_b;
  } ;
  
  union {
    __IOM uint32_t CFG6_H;                      /*!< (@ 0x00000254) Channel 6 high-32bits Configuration Register               */
    
    struct {
      __IOM uint32_t FCMODE     : 1;            /*!< [0..0] Flow Control Mode.                                                 */
            uint32_t            : 2;
      __IOM uint32_t PROTCTL    : 1;            /*!< [3..3] Protection Control bit for secure transfers.                       */
      __IOM uint32_t DIRECT_CTL_EN : 1;         /*!< [4..4] Direct Control for channel enabling.                               */
      __IOM uint32_t CONT_SAR   : 1;            /*!< [5..5] Continuous for SAR between single block.                           */
      __IOM uint32_t CONT_DAR   : 1;            /*!< [6..6] Continuous for DAR between single block.                           */
      __IOM uint32_t SRC_PER    : 4;            /*!< [10..7] Assigns a hardware handshaking interface for the source
                                                     of channel x.                                                             */
      __IOM uint32_t DEST_PER   : 4;            /*!< [14..11] Assigns a hardware handshaking interface for the destination
                                                     of channel x.                                                             */
      __IOM uint32_t Extended_SRC_PER1 : 1;     /*!< [15..15] Extended 4th bit of SRC_PER if hardware handshake interfaces
                                                     are configured to (16, 128].                                              */
      __IOM uint32_t Extended_DEST_PER1 : 1;    /*!< [16..16] Extended 4th bit of DEST_PER if hardware handshake
                                                     interfaces are configured to (16, 128].                                   */
      __IOM uint32_t Extended_SRC_PER2 : 1;     /*!< [17..17] Extended 5th bit of SRC_PER if hardware handshake interfaces
                                                     are configured to (32, 128].                                              */
      __IOM uint32_t Extended_DEST_PER2 : 1;    /*!< [18..18] Extended 5th bit of DEST_PER if hardware handshake
                                                     interfaces are configured to (32, 128].                                   */
      __IOM uint32_t Extended_SRC_PER3 : 1;     /*!< [19..19] Extended 6th bit of SRC_PER if hardware handshake interfaces
                                                     are configured to (64, 128].                                              */
      __IOM uint32_t Extended_DEST_PER3 : 1;    /*!< [20..20] Extended 6th bit of DEST_PER if hardware handshake
                                                     interfaces are configured to (64, 128].                                   */
            uint32_t            : 11;
    } CFG6_H_b;
  } ;
  
  union {
    __IOM uint32_t SGR6_L;                      /*!< (@ 0x00000258) Channel 6 Source Gather Configuration Register             */
    
    struct {
      __IOM uint32_t SGI        : 20;           /*!< [19..0] Source gather interval.                                           */
      __IOM uint32_t SGC        : 12;           /*!< [31..20] Source gather count. Source contiguous transfer count
                                                     between successive gather boundaries.                                     */
    } SGR6_L_b;
  } ;
  
  union {
    __IOM uint32_t SGR6_H;                      /*!< (@ 0x0000025C) Channel 6 Source Gather High Configuration Register        */
    
    struct {
      __IOM uint32_t SGSN       : 16;           /*!< [15..0] Source gather circular streaming number. Enables circular
                                                     gather feature if set greater than 1.                                     */
      __IM  uint32_t BLOCK_TS_L : 16;           /*!< [31..16] Low 16-bits of Block Transfer Size. Indicates the total
                                                     number of single transactions per block transfer.                         */
    } SGR6_H_b;
  } ;
  __IM  uint32_t  RESERVED7[2];
  __IOM uint32_t  SAR7;                         /*!< (@ 0x00000268) Channel 7 Source Address Register                          */
  __IM  uint32_t  CURR_SAR7;                    /*!< (@ 0x0000026C) Channel 7 Current Source Address Register                  */
  __IOM uint32_t  DAR7;                         /*!< (@ 0x00000270) Channel 7 Destination Address Register                     */
  __IM  uint32_t  CURR_DAR7;                    /*!< (@ 0x00000274) Channel 7 Current Destination Address Register             */
  __IOM uint32_t  LLP7_L;                       /*!< (@ 0x00000278) Channel 7 low-32bits Linked List Pointer Register          */
  __IOM uint32_t  LLP7_H;                       /*!< (@ 0x0000027C) Channel 7 high-32bits Linked List Pointer Register         */
  
  union {
    __IOM uint32_t CTL7_L;                      /*!< (@ 0x00000280) Channel 7 low-32bits Control Register                      */
    
    struct {
      __IOM uint32_t INT_EN     : 1;            /*!< [0..0] Interrupt Enable Bit. Globally enables interrupt sources
                                                     for the channel.                                                          */
      __IOM uint32_t DST_TR_WIDTH : 3;          /*!< [3..1] Destination Transfer Width. Specifies width of data transfer
                                                     to destination.                                                           */
      __IOM uint32_t SRC_TR_WIDTH : 3;          /*!< [6..4] Source Transfer Width. Specifies width of data transfer
                                                     from source.                                                              */
      __IOM uint32_t DINC       : 2;            /*!< [8..7] Destination Address Increment. Indicates increment behavior
                                                     for destination address.                                                  */
      __IOM uint32_t SINC       : 2;            /*!< [10..9] Source Address Increment. Indicates increment behavior
                                                     for source address.                                                       */
      __IOM uint32_t DEST_MSIZE : 3;            /*!< [13..11] Number of data items per destination burst transaction.          */
      __IOM uint32_t SRC_MSIZE  : 3;            /*!< [16..14] Number of data items per source burst transaction.               */
      __IOM uint32_t SRC_GATHER_EN : 1;         /*!< [17..17] Enables gather on the source side if conditions in
                                                     address control align.                                                    */
      __IOM uint32_t DST_SCATTER_EN : 1;        /*!< [18..18] Enables scatter on the destination side if conditions
                                                     in address control align.                                                 */
            uint32_t            : 1;
      __IOM uint32_t TT_FC      : 4;            /*!< [23..20] Transfer Type and Flow Control. Supports multiple transfer
                                                     types, with specific flow control.                                        */
            uint32_t            : 3;
      __IOM uint32_t LLP_DST_EN : 1;            /*!< [27..27] Enables block chaining on the destination side if high
                                                     and LLPx_L.LOC is non-zero.                                               */
      __IOM uint32_t LLP_SRC_EN : 1;            /*!< [28..28] Enables block chaining on the source side if high and
                                                     LLPx_L.LOC is non-zero.                                                   */
            uint32_t            : 3;
    } CTL7_L_b;
  } ;
  
  union {
    __IOM uint32_t CTL7_H;                      /*!< (@ 0x00000284) Channel 7 high-32bits Control Register                     */
    
    struct {
      __IOM uint32_t BLOCK_TS   : 32;           /*!< [31..0] Block Transfer Size. Configures single transaction counts
                                                     per block, subject to AXI beat mapping.                                   */
    } CTL7_H_b;
  } ;
  __IOM uint32_t  BLK_COUNTER_REG7;             /*!< (@ 0x00000288) Channel 7 32bits Block Counter Register                    */
  __IOM uint32_t  REPEAT_PATTERN7;              /*!< (@ 0x0000028C) Channel 7 32bits Memory Repeat Pattern Register            */
  __IM  uint32_t  RESERVED8[6];
  
  union {
    __IOM uint32_t CFG7_L;                      /*!< (@ 0x000002A8) Channel 7 low-32bits Configuration Register                */
    
    struct {
      __IM  uint32_t INACTIVE   : 1;            /*!< [0..0] Indicates if the channel is inactive.                              */
      __IM  uint32_t SRC_PCTL_OVER : 1;         /*!< [1..1] DMA Source bus protocol finish indicator.                          */
      __IM  uint32_t DST_PCTL_OVER : 1;         /*!< [2..2] DMA destination bus protocol finish indicator.                     */
            uint32_t            : 1;
      __IOM uint32_t CH_PRIOR   : 4;            /*!< [7..4] Channel priority configuration.                                    */
      __IOM uint32_t CH_SUSP    : 1;            /*!< [8..8] Channel Suspend. Suspends all DMA data transfers from
                                                     the source until this bit is cleared.                                     */
      __IOM uint32_t FIFO_EMPTY : 1;            /*!< [9..9] Indicates if there is data left in the channel FIFO.               */
      __IOM uint32_t HS_SEL_DST : 1;            /*!< [10..10] Destination Software or Hardware Handshaking Select.             */
      __IOM uint32_t HS_SEL_SRC : 1;            /*!< [11..11] Source Software or Hardware Handshaking Select.                  */
            uint32_t            : 6;
      __IM  uint32_t DST_HS_POL : 1;            /*!< [18..18] Destination Handshaking Interface Polarity.                      */
      __IM  uint32_t SRC_HS_POL : 1;            /*!< [19..19] Source Handshaking Interface Polarity.                           */
            uint32_t            : 10;
      __IOM uint32_t RELOAD_SRC : 1;            /*!< [30..30] Automatic Source Reload. Reloads SARx register from
                                                     its initial value at the end of every block for multi-block
                                                     transfers.                                                                */
      __IOM uint32_t RELOAD_DST : 1;            /*!< [31..31] Automatic Destination Reload. Reloads DARx register
                                                     from its initial value at the end of every block for multi-block
                                                     transfers.                                                                */
    } CFG7_L_b;
  } ;
  
  union {
    __IOM uint32_t CFG7_H;                      /*!< (@ 0x000002AC) Channel 7 high-32bits Configuration Register               */
    
    struct {
      __IOM uint32_t FCMODE     : 1;            /*!< [0..0] Flow Control Mode.                                                 */
            uint32_t            : 2;
      __IOM uint32_t PROTCTL    : 1;            /*!< [3..3] Protection Control bit for secure transfers.                       */
      __IOM uint32_t DIRECT_CTL_EN : 1;         /*!< [4..4] Direct Control for channel enabling.                               */
      __IOM uint32_t CONT_SAR   : 1;            /*!< [5..5] Continuous for SAR between single block.                           */
      __IOM uint32_t CONT_DAR   : 1;            /*!< [6..6] Continuous for DAR between single block.                           */
      __IOM uint32_t SRC_PER    : 4;            /*!< [10..7] Assigns a hardware handshaking interface for the source
                                                     of channel x.                                                             */
      __IOM uint32_t DEST_PER   : 4;            /*!< [14..11] Assigns a hardware handshaking interface for the destination
                                                     of channel x.                                                             */
      __IOM uint32_t Extended_SRC_PER1 : 1;     /*!< [15..15] Extended 4th bit of SRC_PER if hardware handshake interfaces
                                                     are configured to (16, 128].                                              */
      __IOM uint32_t Extended_DEST_PER1 : 1;    /*!< [16..16] Extended 4th bit of DEST_PER if hardware handshake
                                                     interfaces are configured to (16, 128].                                   */
      __IOM uint32_t Extended_SRC_PER2 : 1;     /*!< [17..17] Extended 5th bit of SRC_PER if hardware handshake interfaces
                                                     are configured to (32, 128].                                              */
      __IOM uint32_t Extended_DEST_PER2 : 1;    /*!< [18..18] Extended 5th bit of DEST_PER if hardware handshake
                                                     interfaces are configured to (32, 128].                                   */
      __IOM uint32_t Extended_SRC_PER3 : 1;     /*!< [19..19] Extended 6th bit of SRC_PER if hardware handshake interfaces
                                                     are configured to (64, 128].                                              */
      __IOM uint32_t Extended_DEST_PER3 : 1;    /*!< [20..20] Extended 6th bit of DEST_PER if hardware handshake
                                                     interfaces are configured to (64, 128].                                   */
            uint32_t            : 11;
    } CFG7_H_b;
  } ;
  
  union {
    __IOM uint32_t SGR7_L;                      /*!< (@ 0x000002B0) Channel 7 Source Gather Configuration Register             */
    
    struct {
      __IOM uint32_t SGI        : 20;           /*!< [19..0] Source gather interval.                                           */
      __IOM uint32_t SGC        : 12;           /*!< [31..20] Source gather count. Source contiguous transfer count
                                                     between successive gather boundaries.                                     */
    } SGR7_L_b;
  } ;
  
  union {
    __IOM uint32_t SGR7_H;                      /*!< (@ 0x000002B4) Channel 7 Source Gather High Configuration Register        */
    
    struct {
      __IOM uint32_t SGSN       : 16;           /*!< [15..0] Source gather circular streaming number. Enables circular
                                                     gather feature if set greater than 1.                                     */
      __IM  uint32_t BLOCK_TS_L : 16;           /*!< [31..16] Low 16-bits of Block Transfer Size. Indicates the total
                                                     number of single transactions per block transfer.                         */
    } SGR7_H_b;
  } ;
  __IOM uint32_t  DSR7_L;                       /*!< (@ 0x000002B8) Channel 7 low-32bits Destination Scatter Register          */
  __IOM uint32_t  DSR7_H;                       /*!< (@ 0x000002BC) Channel 7 high-32bits Destination Scatter Register         */
  __IM  uint32_t  RAWTFR_L;                     /*!< (@ 0x000002C0) Raw Status for IntTfr Interrupt                            */
  __IM  uint32_t  RAWTFR_H;                     /*!< (@ 0x000002C4) Raw Status for Blk Counter Register                        */
  __IM  uint32_t  RAWBLOCK_L;                   /*!< (@ 0x000002C8) Raw Status for IntBlock Interrupt                          */
  __IM  uint32_t  RAWBLOCK_H;                   /*!< (@ 0x000002CC) Raw Status for Int_1_2_Block if defined                    */
  __IM  uint32_t  RAWERR_L;                     /*!< (@ 0x000002D0) Raw Status for IntErr Interrupt (protocol error)           */
  __IM  uint32_t  RESERVED9[4];
  __IM  uint32_t  RAWERR_H;                     /*!< (@ 0x000002E4) Raw Status for non-secure access secure register
                                                                    error if defined                                           */
  __IM  uint32_t  RESERVED10;
  __IM  uint32_t  STATUSTFR_L;                  /*!< (@ 0x000002EC) Status for IntTfr Interrupt                                */
  __IM  uint32_t  STATUSTFR_H;                  /*!< (@ 0x000002F0) Status for Blk Counter Interrupt                           */
  __IM  uint32_t  RESERVED11;
  __IM  uint32_t  STATUSBLOCK_L;                /*!< (@ 0x000002F8) Status for IntBlock Interrupt                              */
  __IM  uint32_t  RESERVED12[3];
  __IM  uint32_t  STATUSERR_L;                  /*!< (@ 0x00000308) Status for IntErr Interrupt (protocol error)               */
  __IM  uint32_t  RESERVED13;
  __IOM uint32_t  MASKTFR_L;                    /*!< (@ 0x00000310) Mask for IntTfr Interrupt                                  */
  __IOM uint32_t  MASKTFR_H;                    /*!< (@ 0x00000314) Mask for Blk Counter Interrupt                             */
  __IOM uint32_t  MASKBLOCK_L;                  /*!< (@ 0x00000318) Mask for IntBlock Interrupt                                */
  __IOM uint32_t  MASKBLOCK_H;                  /*!< (@ 0x0000031C) Mask for Int_1_2_Block if defined                          */
  __IM  uint32_t  RESERVED14[4];
  __IOM uint32_t  MASKERR_L;                    /*!< (@ 0x00000330) Mask for IntErr Interrupt                                  */
  __IOM uint32_t  MASKERR_H;                    /*!< (@ 0x00000334) Mask for non-secure access secure register error
                                                                    if defined                                                 */
  __IM  uint32_t  RESERVED15[10];
  
  union {
    __IM  uint32_t STATUSINT_L;                 /*!< (@ 0x00000360) Combined Interrupt Status (Low) Register                   */
    
    struct {
      __IM  uint32_t Tfr        : 1;            /*!< [0..0] OR of the contents of StatusTfr_L register.                        */
      __IM  uint32_t Block      : 1;            /*!< [1..1] OR of the contents of StatusBlock register.                        */
            uint32_t            : 2;
      __IM  uint32_t Error      : 1;            /*!< [4..4] OR of the contents of StatusErr register.                          */
      __IM  uint32_t Block_1_2  : 1;            /*!< [5..5] Reserved Condition: OR of the Status_1_2_Block register
                                                     contents if DMAC_1_2_BLK_TRANSFER_INT is defined. Otherwise,
                                                     0.                                                                        */
      __IM  uint32_t Block_Counter : 1;         /*!< [6..6] Reserved Condition: OR of the StatusTfr_H register contents
                                                     if DMAC_CHx_SUPPORT_BLK_COUNTER is defined. Otherwise,
                                                     0.                                                                        */
            uint32_t            : 25;
    } STATUSINT_L_b;
  } ;
  __IM  uint32_t  STATUSINT_H;                  /*!< (@ 0x00000364) Combined Interrupt Status (High) Register                  */
  __IM  uint32_t  RESERVED16[12];
  __IOM uint32_t  DMACFGREG;                    /*!< (@ 0x00000398) DMA Configuration Register                                 */
  __IM  uint32_t  RESERVED17;
  
  union {
    __IOM uint32_t CHENREG;                     /*!< (@ 0x000003A0) DMA low-32bits Channel Enable Register                     */
    
    struct {
      __IOM uint32_t CH_EN      : 8;            /*!< [7..0] Enables/Disables the channel. Setting this bit enables
                                                     a channel; clearing it disables the channel. - 0 = Disable
                                                     the Channel - 1 = Enable the Channel The CHENREG_L.CH_EN
                                                     bit is automatically cleared by hardware after the last
                                                     AXI transfer of the DMA transfer to the destination has
                                                     completed. Software can poll this bit to determine when
                                                     the channel is available for a new DMA transfer.                          */
      __IOM uint32_t CH_EN_WE   : 8;            /*!< [15..8] Channel enable write enable.                                      */
            uint32_t            : 16;
    } CHENREG_b;
  } ;
} DMAC_Type;                                    /*!< Size = 932 (0x3a4)                                                        */



/* =========================================================================================================================== */
/* ================                                         USB_CORE                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief USB OTG Controller (USB_CORE)
  */

typedef struct {                                /*!< (@ 0x40040000) USB_CORE Structure                                         */
  
  union {
    __IOM uint32_t GOTGCTL;                     /*!< (@ 0x00000000) Control and Status Register                                */
    
    struct {
      __IM  uint32_t SesReqScs  : 1;            /*!< [0..0] Session Request Success                                            */
      __IOM uint32_t SesReq     : 1;            /*!< [1..1] Session Request                                                    */
      __IOM uint32_t VbvalidOvEn : 1;           /*!< [2..2] VBUS Valid Override Enable                                         */
      __IOM uint32_t VbvalidOvVal : 1;          /*!< [3..3] VBUS Valid OverrideValue (VbvalidOvVal)                            */
      __IOM uint32_t AvalidOvEn : 1;            /*!< [4..4] A-Peripheral Session Valid Override Enable                         */
      __IOM uint32_t AvalidOvVal : 1;           /*!< [5..5] A-Peripheral Session Valid OverrideValue (AvalidOvVal)             */
      __IOM uint32_t BvalidOvEn : 1;            /*!< [6..6] B-Peripheral Session Valid Override Enable                         */
      __IOM uint32_t BvalidOvVal : 1;           /*!< [7..7] B-Peripheral Session Valid OverrideValue (BvalidOvVal)             */
      __IM  uint32_t HstNegScs  : 1;            /*!< [8..8] Host Negotiation Success (HstNegScs)                               */
      __IOM uint32_t HNPReq     : 1;            /*!< [9..9] HNP Request (HNPReq)                                               */
      __IOM uint32_t HstSetHNPEn : 1;           /*!< [10..10] Host Set HNP Enable (HstSetHNPEn)                                */
      __IOM uint32_t DevHNPEn   : 1;            /*!< [11..11] Device HNP Enabled (DevHNPEn)                                    */
      __IOM uint32_t EHEn       : 1;            /*!< [12..12] Embedded Host Enable (EHEn)                                      */
            uint32_t            : 2;
      __IOM uint32_t DbnceFltrBypass : 1;       /*!< [15..15] Debounce Filter Bypass                                           */
      __IM  uint32_t ConIDSts   : 1;            /*!< [16..16] Connector ID Status                                              */
      __IM  uint32_t DbncTime   : 1;            /*!< [17..17] Debounce Time                                                    */
      __IM  uint32_t ASesVld    : 1;            /*!< [18..18] A-session Valid                                                  */
      __IM  uint32_t BSesVld    : 1;            /*!< [19..19] B-session Valid                                                  */
      __IOM uint32_t OTGVer     : 1;            /*!< [20..20] OTG Version                                                      */
      __IM  uint32_t CurMod     : 1;            /*!< [21..21] Current Mode of Operation                                        */
      __IM  uint32_t MultValIdBC : 5;           /*!< [26..22] Multi Valued ID pin (MultValIdBC)                                */
      __IOM uint32_t ChirpEn    : 1;            /*!< [27..27] Core asserting chirp_on before sending an actual Chirp
                                                     K signal on USB.                                                          */
            uint32_t            : 3;
      __IOM uint32_t Testmode_corr_eUSB2 : 1;   /*!< [31..31] Correction for eUSB2 PHY during Test mode                        */
    } GOTGCTL_b;
  } ;
  
  union {
    __IOM uint32_t GOTGINT;                     /*!< (@ 0x00000004) Interrupt Register                                         */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t SesEndDet  : 1;            /*!< [2..2] Session End Detected                                               */
            uint32_t            : 5;
      __IOM uint32_t SesReqSucStsChng : 1;      /*!< [8..8] Session Request Success Status Change                              */
      __IOM uint32_t HstNegSucStsChng : 1;      /*!< [9..9] Host Negotiation Success Status Change                             */
            uint32_t            : 7;
      __IOM uint32_t HstNegDet  : 1;            /*!< [17..17] Host Negotiation Detected                                        */
      __IOM uint32_t ADevTOUTChg : 1;           /*!< [18..18] A-Device Timeout Change                                          */
      __IOM uint32_t DbnceDone  : 1;            /*!< [19..19] Debounce Done                                                    */
      __IOM uint32_t MultValIpChng : 1;         /*!< [20..20] Indicates change in ACA pin value                                */
            uint32_t            : 11;
    } GOTGINT_b;
  } ;
  
  union {
    __IOM uint32_t GAHBCFG;                     /*!< (@ 0x00000008) AHB Configuration Register                                 */
    
    struct {
      __IOM uint32_t GlblIntrMsk : 1;           /*!< [0..0] Global Interrupt Mask                                              */
      __IOM uint32_t HBstLen    : 4;            /*!< [4..1] Burst Length/Type                                                  */
      __IOM uint32_t DMAEn      : 1;            /*!< [5..5] DMA Enable                                                         */
            uint32_t            : 1;
      __IOM uint32_t NPTxFEmpLvl : 1;           /*!< [7..7] Non-Periodic TxFIFO Empty Level                                    */
      __IOM uint32_t PTxFEmpLvl : 1;            /*!< [8..8] Periodic TxFIFO Empty Level                                        */
            uint32_t            : 12;
      __IOM uint32_t RemMemSupp : 1;            /*!< [21..21] Remote Memory Support                                            */
      __IOM uint32_t NotiAllDmaWrit : 1;        /*!< [22..22] Notify All DMA Write Transactions                                */
      __IOM uint32_t AHBSingle  : 1;            /*!< [23..23] AHB Single Support                                               */
      __IOM uint32_t InvDescEndianess : 1;      /*!< [24..24] Invert Descriptor Endianess                                      */
            uint32_t            : 7;
    } GAHBCFG_b;
  } ;
  
  union {
    __IOM uint32_t GUSBCFG;                     /*!< (@ 0x0000000C) USB Configuration Register                                 */
    
    struct {
      __IOM uint32_t TOutCal    : 3;            /*!< [2..0] HS/FS Timeout Calibration                                          */
      __IOM uint32_t PHYIf      : 1;            /*!< [3..3] PHY Interface                                                      */
      __IOM uint32_t ULPI_UTMI_Sel : 1;         /*!< [4..4] ULPI or UTMI+ Select                                               */
      __IOM uint32_t FSIntf     : 1;            /*!< [5..5] Full-Speed Serial Interface Select                                 */
      __IOM uint32_t PHYSel     : 1;            /*!< [6..6] PHY Selection                                                      */
      __IOM uint32_t DDRSel     : 1;            /*!< [7..7] ULPI DDR Select                                                    */
      __IOM uint32_t SRPCap     : 1;            /*!< [8..8] SRP-Capable                                                        */
      __IOM uint32_t HNPCap     : 1;            /*!< [9..9] HNP-Capable                                                        */
      __IOM uint32_t USBTrdTim  : 4;            /*!< [13..10] USB Turnaround Time                                              */
            uint32_t            : 1;
      __IOM uint32_t PhyLPwrClkSel : 1;         /*!< [15..15] PHY Low-Power Clock Select                                       */
      __IOM uint32_t OtgI2CSel  : 1;            /*!< [16..16] UTMIFS or I2C Interface Select                                   */
      __IOM uint32_t ULPIFsLs   : 1;            /*!< [17..17] ULPI FS/LS Select                                                */
      __IOM uint32_t ULPIAutoRes : 1;           /*!< [18..18] ULPI Auto Resume                                                 */
      __IOM uint32_t ULPIClkSusM : 1;           /*!< [19..19] ULPI Clock SuspendM                                              */
      __IOM uint32_t ULPIExtVbusDrv : 1;        /*!< [20..20] ULPI External VBUS Drive                                         */
      __IOM uint32_t ULPIExtVbusIndicator : 1;  /*!< [21..21] ULPI External VBUS Indicator                                     */
      __IOM uint32_t TermSelDLPulse : 1;        /*!< [22..22] TermSel DLine Pulsing Selection                                  */
      __IOM uint32_t Complement : 1;            /*!< [23..23] Indicator Complement Controls                                    */
      __IOM uint32_t Indicator  : 1;            /*!< [24..24] Indicator Pass Through                                           */
      __IOM uint32_t ULPI       : 1;            /*!< [25..25] ULPI Interface Protect Disable                                   */
      __IOM uint32_t IC_USBCap  : 1;            /*!< [26..26] IC_USB-Capable PHY Interface Selection                           */
      __IOM uint32_t IC_USBTrafCtl : 1;         /*!< [27..27] IC_USB-TrafficPullRemove Control                                 */
      __IOM uint32_t TxEndDelay : 1;            /*!< [28..28] Tx End Delay                                                     */
      __IOM uint32_t ForceHstMode : 1;          /*!< [29..29] Force Host Mode                                                  */
      __IOM uint32_t ForceDevMode : 1;          /*!< [30..30] Force Device Mode                                                */
      __IOM uint32_t CorruptTxPkt : 1;          /*!< [31..31] Corrupt Tx packet                                                */
    } GUSBCFG_b;
  } ;
  
  union {
    __IOM uint32_t GRSTCTL;                     /*!< (@ 0x00000010) Reset Register                                             */
    
    struct {
      __IOM uint32_t CSftRst    : 1;            /*!< [0..0] Core Soft Reset                                                    */
      __IOM uint32_t PIUFSSftRst : 1;           /*!< [1..1] PIU FS Soft Reset                                                  */
      __IOM uint32_t FrmCntrRst : 1;            /*!< [2..2] Host Frame Counter Reset                                           */
      __IOM uint32_t INTknQFlsh : 1;            /*!< [3..3] IN Token Queue Flush                                               */
      __IOM uint32_t RxFFlsh    : 1;            /*!< [4..4] RxFIFO Flush                                                       */
      __IOM uint32_t TxFFlsh    : 1;            /*!< [5..5] TxFIFO Flush                                                       */
      __IOM uint32_t TxFNum     : 5;            /*!< [10..6] TxFIFO Number                                                     */
            uint32_t            : 18;
      __IOM uint32_t CSftRstDone : 1;           /*!< [29..29] Core Soft Reset Done                                             */
      __IM  uint32_t DMAReq     : 1;            /*!< [30..30] DMA Request Signal                                               */
      __IM  uint32_t AHBIdle    : 1;            /*!< [31..31] AHB Master Idle                                                  */
    } GRSTCTL_b;
  } ;
  
  union {
    __IOM uint32_t GINTSTS;                     /*!< (@ 0x00000014) Interrupt Register                                         */
    
    struct {
      __IM  uint32_t CurMod     : 1;            /*!< [0..0] Current Mode of Operation                                          */
      __IOM uint32_t ModeMis    : 1;            /*!< [1..1] Mode Mismatch Interrupt                                            */
      __IM  uint32_t OTGInt     : 1;            /*!< [2..2] OTG Interrupt                                                      */
      __IOM uint32_t Sof        : 1;            /*!< [3..3] Start of (micro)Frame                                              */
      __IM  uint32_t RxFLvl     : 1;            /*!< [4..4] RxFIFO Non-Empty                                                   */
      __IM  uint32_t NPTxFEmp   : 1;            /*!< [5..5] Non-periodic TxFIFO Empty                                          */
      __IM  uint32_t GINNakEff  : 1;            /*!< [6..6] Global IN Non-periodic NAK Effective                               */
      __IM  uint32_t GOUTNakEff : 1;            /*!< [7..7] Global OUT NAK Effective                                           */
      __IOM uint32_t ULPICKINT  : 1;            /*!< [8..8] ULPI Carkit Interrupt                                              */
      __IOM uint32_t I2CINT     : 1;            /*!< [9..9] I2C Interrupt                                                      */
      __IOM uint32_t ErlySusp   : 1;            /*!< [10..10] Early Suspend                                                    */
      __IOM uint32_t USBSusp    : 1;            /*!< [11..11] USB Suspend                                                      */
      __IOM uint32_t USBRst     : 1;            /*!< [12..12] USB Reset                                                        */
      __IOM uint32_t EnumDone   : 1;            /*!< [13..13] Enumeration Done                                                 */
      __IOM uint32_t ISOOutDrop : 1;            /*!< [14..14] Isochronous OUT Packet Dropped Interrupt                         */
      __IOM uint32_t EOPF       : 1;            /*!< [15..15] End of Periodic Frame Interrupt                                  */
      __IOM uint32_t RstrDoneInt : 1;           /*!< [16..16] Restore Done Interrupt                                           */
      __IOM uint32_t EPMis      : 1;            /*!< [17..17] Endpoint Mismatch Interrupt                                      */
      __IM  uint32_t IEPInt     : 1;            /*!< [18..18] IN Endpoints Interrupt                                           */
      __IM  uint32_t OEPInt     : 1;            /*!< [19..19] OUT Endpoints Interrupt                                          */
      __IOM uint32_t incompISOIN : 1;           /*!< [20..20] Incomplete Isochronous IN Transfer                               */
      __IOM uint32_t incomplP   : 1;            /*!< [21..21] Incomplete Periodic Transfer                                     */
      __IOM uint32_t FetSusp    : 1;            /*!< [22..22] Data Fetch Suspended                                             */
      __IOM uint32_t ResetDet   : 1;            /*!< [23..23] Reset Detected Interrupt                                         */
      __IM  uint32_t PrtInt     : 1;            /*!< [24..24] Host Port Interrupt                                              */
      __IM  uint32_t HChInt     : 1;            /*!< [25..25] Host Channels Interrupt                                          */
      __IM  uint32_t PTxFEmp    : 1;            /*!< [26..26] Periodic TxFIFO Empty                                            */
      __IOM uint32_t LPM_Int    : 1;            /*!< [27..27] LPM Transaction Received Interrupt                               */
      __IOM uint32_t ConIDStsChng : 1;          /*!< [28..28] Connector ID Status Change                                       */
      __IOM uint32_t DisconnInt : 1;            /*!< [29..29] Disconnect Detected Interrupt                                    */
      __IOM uint32_t SessReqInt : 1;            /*!< [30..30] Session Request/New Session Detected Interrupt                   */
      __IOM uint32_t WkUpInt    : 1;            /*!< [31..31] Resume/Remote Wakeup Detected Interrupt                          */
    } GINTSTS_b;
  } ;
  
  union {
    __IOM uint32_t GINTMSK;                     /*!< (@ 0x00000018) Interrupt Mask Register                                    */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t ModeMisMsk : 1;            /*!< [1..1] Mode Mismatch Interrupt Mask                                       */
      __IOM uint32_t OTGIntMsk  : 1;            /*!< [2..2] OTG Interrupt Mask                                                 */
      __IOM uint32_t SofMsk     : 1;            /*!< [3..3] Start of Frame Mask                                                */
      __IOM uint32_t RxFLvlMsk  : 1;            /*!< [4..4] Receive FIFO Non-Empty Mask                                        */
      __IOM uint32_t NPTxFEmpMsk : 1;           /*!< [5..5] Non-periodic TxFIFO Empty Mask                                     */
      __IOM uint32_t GINNakEffMsk : 1;          /*!< [6..6] Global Non-periodic IN NAK Effective Mask, Device only             */
      __IOM uint32_t GOUTNakEffMsk : 1;         /*!< [7..7] Global OUT NAK Effective Mask, Device only                         */
      __IOM uint32_t ULPICKINTMsk : 1;          /*!< [8..8] ULPI Carkit Interrupt Mask                                         */
      __IOM uint32_t I2CIntMsk  : 1;            /*!< [9..9] I2C Interrupt Mask                                                 */
      __IOM uint32_t ErlySuspMsk : 1;           /*!< [10..10] Early Suspend Mask, Device only                                  */
      __IOM uint32_t USBSuspMsk : 1;            /*!< [11..11] USB Suspend Mask, Device only                                    */
      __IOM uint32_t USBRstMsk  : 1;            /*!< [12..12] USB Reset Mask, Device only                                      */
      __IOM uint32_t EnumDoneMsk : 1;           /*!< [13..13] Enumeration Done Mask, Device only                               */
      __IOM uint32_t ISOOutDropMsk : 1;         /*!< [14..14] Isochronous OUT Packet Dropped Interrupt Mask, Device
                                                     only                                                                      */
      __IOM uint32_t EOPFMsk    : 1;            /*!< [15..15] End of Periodic Frame Interrupt Mask, Device only                */
      __IOM uint32_t RstrDoneIntMsk : 1;        /*!< [16..16] Restore Done Interrupt Mask                                      */
      __IOM uint32_t EPMisMsk   : 1;            /*!< [17..17] Endpoint Mismatch Interrupt Mask, Device only                    */
      __IOM uint32_t IEPIntMsk  : 1;            /*!< [18..18] IN Endpoints Interrupt Mask, Device only                         */
      __IOM uint32_t OEPIntMsk  : 1;            /*!< [19..19] OUT Endpoints Interrupt Mask, Device only                        */
      __IOM uint32_t incompISOINMsk : 1;        /*!< [20..20] Incomplete Isochronous IN Transfer Mask, Device only             */
      __IOM uint32_t incomplPMsK : 1;           /*!< [21..21] Incomplete Periodic Transfer Mask, Host only                     */
      __IOM uint32_t FetSuspMsk : 1;            /*!< [22..22] Data Fetch Suspended Mask, Device only                           */
      __IOM uint32_t ResetDetMsk : 1;           /*!< [23..23] Reset Detected Interrupt Mask, Device only                       */
      __IOM uint32_t PrtIntMsk  : 1;            /*!< [24..24] Host Port Interrupt Mask, Host only                              */
      __IOM uint32_t HChIntMsk  : 1;            /*!< [25..25] Host Channels Interrupt Mask, Host only                          */
      __IOM uint32_t PTxFEmpMsk : 1;            /*!< [26..26] Periodic TxFIFO Empty Mask, Host only                            */
      __IOM uint32_t LPM_IntMsk : 1;            /*!< [27..27] LPM Transaction Received Interrupt Mask                          */
      __IOM uint32_t ConIDStsChngMsk : 1;       /*!< [28..28] Connector ID Status Change Mask                                  */
      __IOM uint32_t DisconnIntMsk : 1;         /*!< [29..29] Disconnect Detected Interrupt Mask                               */
      __IOM uint32_t SessReqIntMsk : 1;         /*!< [30..30] Session Request/New Session Detected Interrupt Mask              */
      __IOM uint32_t WkUpIntMsk : 1;            /*!< [31..31] Resume/Remote Wakeup Detected Interrupt Mask                     */
    } GINTMSK_b;
  } ;
  
  union {
    __IM  uint32_t GRXSTSR;                     /*!< (@ 0x0000001C) Receive Status Debug Read Register                         */
    
    struct {
      __IM  uint32_t ChNum      : 4;            /*!< [3..0] Channel Number / Endpoint Number                                   */
      __IM  uint32_t BCnt       : 11;           /*!< [14..4] Byte Count                                                        */
      __IM  uint32_t DPID       : 2;            /*!< [16..15] Data PID                                                         */
      __IM  uint32_t PktSts     : 4;            /*!< [20..17] Packet Status                                                    */
      __IM  uint32_t FN         : 4;            /*!< [24..21] Frame Number (Device only)                                       */
            uint32_t            : 7;
    } GRXSTSR_b;
  } ;
  
  union {
    __IM  uint32_t GRXSTSP;                     /*!< (@ 0x00000020) Receive Status Read/Pop Register                           */
    
    struct {
      __IM  uint32_t ChNum      : 4;            /*!< [3..0] Channel Number / Endpoint Number                                   */
      __IM  uint32_t BCnt       : 11;           /*!< [14..4] Byte Count                                                        */
      __IM  uint32_t DPID       : 2;            /*!< [16..15] Data PID                                                         */
      __IM  uint32_t PktSts     : 4;            /*!< [20..17] Packet Status                                                    */
      __IM  uint32_t FN         : 4;            /*!< [24..21] Frame Number (Device only)                                       */
            uint32_t            : 7;
    } GRXSTSP_b;
  } ;
  __IOM uint32_t  GRXFSIZ;                      /*!< (@ 0x00000024) Receive FIFO Size Register                                 */
  
  union {
    __IOM uint32_t GNPTXFSIZ;                   /*!< (@ 0x00000028) Non-periodic Transmit FIFO Size Register                   */
    
    struct {
      __IOM uint32_t NPTxFStAddr : 11;          /*!< [10..0] Non-periodic Transmit RAM Start Address                           */
            uint32_t            : 5;
      __IOM uint32_t NPTxFDep   : 11;           /*!< [26..16] Non-periodic TxFIFO Depth                                        */
            uint32_t            : 5;
    } GNPTXFSIZ_b;
  } ;
  
  union {
    __IM  uint32_t GNPTXSTS;                    /*!< (@ 0x0000002C) Non-periodic Transmit FIFO/Queue Status Register           */
    
    struct {
      __IM  uint32_t NPTxFSpcAvail : 16;        /*!< [15..0] Non-periodic TxFIFO Space Available                               */
      __IM  uint32_t NPTxQSpcAvail : 8;         /*!< [23..16] Non-periodic Transmit Request Queue Space Available              */
      __IM  uint32_t NPTxQTop   : 7;            /*!< [30..24] Top of the Non-periodic Transmit Request Queue                   */
            uint32_t            : 1;
    } GNPTXSTS_b;
  } ;
  __IOM uint32_t  GI2CCTL;                      /*!< (@ 0x00000030) I2C Access Register                                        */
  
  union {
    __IOM uint32_t GPVNDCTL;                    /*!< (@ 0x00000034) PHY Vendor Control Register                                */
    
    struct {
      __IOM uint32_t RegData    : 8;            /*!< [7..0] Register Data                                                      */
      __IOM uint32_t VCtrl      : 8;            /*!< [15..8] UTMI+ Vendor Control Register Address                             */
      __IOM uint32_t RegAddr    : 6;            /*!< [21..16] Register Address                                                 */
      __IOM uint32_t RegWr      : 1;            /*!< [22..22] Register Write                                                   */
            uint32_t            : 2;
      __IOM uint32_t NewRegReq  : 1;            /*!< [25..25] New Register Request                                             */
      __IM  uint32_t VStsBsy    : 1;            /*!< [26..26] VStatus Busy                                                     */
      __IOM uint32_t VStsDone   : 1;            /*!< [27..27] VStatus Done                                                     */
            uint32_t            : 3;
      __IOM uint32_t DisUlpiDrvr : 1;           /*!< [31..31] Disable ULPI Drivers                                             */
    } GPVNDCTL_b;
  } ;
  __IOM uint32_t  GGPIO;                        /*!< (@ 0x00000038) General Purpose Input/Output Register                      */
  __IOM uint32_t  GUID;                         /*!< (@ 0x0000003C) User ID Register                                           */
  __IM  uint32_t  GSNPSID;                      /*!< (@ 0x00000040) Synopsys ID Register                                       */
  __IM  uint32_t  GHWCFG1;                      /*!< (@ 0x00000044) User Hardware Configuration 1 Register                     */
  
  union {
    __IM  uint32_t GHWCFG2;                     /*!< (@ 0x00000048) User Hardware Configuration 2 Register                     */
    
    struct {
      __IM  uint32_t OtgMode    : 3;            /*!< [2..0] Mode of Operation                                                  */
      __IM  uint32_t OtgArch    : 2;            /*!< [4..3] Architecture                                                       */
      __IM  uint32_t SingPnt    : 1;            /*!< [5..5] Point-to-Point                                                     */
      __IM  uint32_t HSPhyType  : 2;            /*!< [7..6] High-Speed PHY Interface Type                                      */
      __IM  uint32_t FSPhyType  : 2;            /*!< [9..8] Full-Speed PHY Interface Type                                      */
      __IM  uint32_t NumDevEps  : 4;            /*!< [13..10] Number of Device Endpoints                                       */
      __IM  uint32_t NumHstChnl : 4;            /*!< [17..14] Number of Host Channels                                          */
      __IM  uint32_t PerioSupport : 1;          /*!< [18..18] Periodic OUT Channels Supported in Host Mode                     */
      __IM  uint32_t DynFifoSizing : 1;         /*!< [19..19] Dynamic FIFO Sizing Enabled                                      */
      __IM  uint32_t MultiProcIntrpt : 1;       /*!< [20..20] Multi Processor Interrupt Enabled                                */
            uint32_t            : 1;
      __IM  uint32_t NPTxQDepth : 2;            /*!< [23..22] Non-periodic Request Queue Depth                                 */
      __IM  uint32_t PTxQDepth  : 2;            /*!< [25..24] Host Mode Periodic Request Queue Depth                           */
      __IM  uint32_t TknQDepth  : 5;            /*!< [30..26] Device Mode IN Token Sequence Learning Queue Depth               */
      __IM  uint32_t OTG_ENABLE_IC_USB : 1;     /*!< [31..31] IC_USB mode specified for mode of operation                      */
    } GHWCFG2_b;
  } ;
  
  union {
    __IM  uint32_t GHWCFG3;                     /*!< (@ 0x0000004C) User Hardware Configuration 3 Register                     */
    
    struct {
      __IM  uint32_t XferSizeWidth : 4;         /*!< [3..0] Width of Transfer Size Counters                                    */
      __IM  uint32_t PktSizeWidth : 3;          /*!< [6..4] Width of Packet Size Counters                                      */
      __IM  uint32_t OtgEn      : 1;            /*!< [7..7] OTG Function Enabled                                               */
      __IM  uint32_t I2CIntSel  : 1;            /*!< [8..8] I2C Interface Selection                                            */
      __IM  uint32_t VndctlSupt : 1;            /*!< [9..9] Vendor Control Interface Support                                   */
      __IM  uint32_t OptFeature : 1;            /*!< [10..10] Optional Features Removed                                        */
      __IM  uint32_t RstType    : 1;            /*!< [11..11] Reset Style for Clocked Blocks                                   */
      __IM  uint32_t ADPSupport : 1;            /*!< [12..12] ADP Logic Support                                                */
      __IM  uint32_t HSICMode   : 1;            /*!< [13..13] HSIC Mode                                                        */
      __IM  uint32_t BCSupport  : 1;            /*!< [14..14] Battery Charger Support                                          */
      __IM  uint32_t LPMMode    : 1;            /*!< [15..15] LPM Mode                                                         */
      __IM  uint32_t DfifoDepth : 16;           /*!< [31..16] DFIFO Depth                                                      */
    } GHWCFG3_b;
  } ;
  
  union {
    __IM  uint32_t GHWCFG4;                     /*!< (@ 0x00000050) User Hardware Configuration 4 Register                     */
    
    struct {
      __IM  uint32_t NumDevPerioEps : 4;        /*!< [3..0] Number of Device Mode Periodic IN Endpoints                        */
      __IM  uint32_t PartialPwrDn : 1;          /*!< [4..4] Enable Partial Power Down                                          */
      __IM  uint32_t AhbFreq    : 1;            /*!< [5..5] Minimum AHB Frequency Less Than 60 MHz                             */
      __IM  uint32_t Hibernation : 1;           /*!< [6..6] Enable Hibernation                                                 */
      __IM  uint32_t ExtendedHibernation : 1;   /*!< [7..7] Enable Hibernation                                                 */
            uint32_t            : 1;
      __IM  uint32_t EnhancedLPMSupt1 : 1;      /*!< [9..9] Enhanced LPM Support1                                              */
      __IM  uint32_t ServIntFlow : 1;           /*!< [10..10] Service Interval Flow                                            */
      __IM  uint32_t ipgisocSupt : 1;           /*!< [11..11] Interpacket Gap ISOC OUT Worst-case Support                      */
      __IM  uint32_t ACGSupt    : 1;            /*!< [12..12] Active Clock Gating Support                                      */
      __IM  uint32_t EnhancedLPMSupt : 1;       /*!< [13..13] Enhanced LPM Support                                             */
      __IM  uint32_t PhyDataWidth : 2;          /*!< [15..14] UTMI+ PHY/ULPI-to-Internal UTMI+ Wrapper Data Width              */
      __IM  uint32_t NumCtlEps  : 4;            /*!< [19..16] Number of Device Mode Control Endpoints in Addition
                                                     to Endpoint 0                                                             */
      __IM  uint32_t IddgFltr   : 1;            /*!< [20..20] IDDIG Filter Enabled                                             */
      __IM  uint32_t VBusValidFltr : 1;         /*!< [21..21] VBUS Valid Filter Enabled                                        */
      __IM  uint32_t AValidFltr : 1;            /*!< [22..22] a_valid filter enabled                                           */
      __IM  uint32_t BValidFltr : 1;            /*!< [23..23] b_valid filter enabled                                           */
      __IM  uint32_t SessEndFltr : 1;           /*!< [24..24] Session end filter enabled                                       */
      __IM  uint32_t DedFifoMode : 1;           /*!< [25..25] Enable Dedicated Transmit FIFO for device IN Endpoints           */
      __IM  uint32_t INEps      : 4;            /*!< [29..26] Number of Device Mode IN Endpoints Including Control
                                                     Endpoints                                                                 */
      __IM  uint32_t DescDMAEnabled : 1;        /*!< [30..30] Scatter/Gather DMA configuration enabled                         */
      __IM  uint32_t DescDMA    : 1;            /*!< [31..31] Scatter/Gather DMA configuration                                 */
    } GHWCFG4_b;
  } ;
  
  union {
    __IOM uint32_t GLPMCFG;                     /*!< (@ 0x00000054) LPM Config Register                                        */
    
    struct {
      __IOM uint32_t LPMCap     : 1;            /*!< [0..0] LPM-Capable                                                        */
      __IOM uint32_t AppL1Res   : 1;            /*!< [1..1] LPM response programmed by application                             */
      __IOM uint32_t HIRD       : 4;            /*!< [5..2] Host-Initiated Resume Duration                                     */
      __IOM uint32_t bRemoteWake : 1;           /*!< [6..6] RemoteWakeEnable                                                   */
      __IOM uint32_t EnblSlpM   : 1;            /*!< [7..7] Enable utmi_sleep_n                                                */
      __IOM uint32_t HIRD_Thres : 5;            /*!< [12..8] BESL/HIRD Threshold                                               */
      __IOM uint32_t CoreL1Res  : 2;            /*!< [14..13] LPM Response                                                     */
      __IOM uint32_t SlpSts     : 1;            /*!< [15..15] Port Sleep Status                                                */
      __IOM uint32_t L1ResumeOK : 1;            /*!< [16..16] Sleep State Resume OK                                            */
      __IOM uint32_t LPM_Chnl_Indx : 4;         /*!< [20..17] LPM Channel Index                                                */
      __IOM uint32_t LPM_Retry_Cnt : 3;         /*!< [23..21] LPM Retry Count                                                  */
      __IOM uint32_t SndLPM     : 1;            /*!< [24..24] Send LPM Transaction                                             */
      __IM  uint32_t LPM_RetryCnt_Sts : 3;      /*!< [27..25] LPM Retry Count Status                                           */
      __IOM uint32_t LPM_EnBESL : 1;            /*!< [28..28] LPM Enable BESL                                                  */
      __IOM uint32_t LPM_RestoreSlpSts : 1;     /*!< [29..29] LPM Restore Sleep Status                                         */
      __IOM uint32_t HSICCon    : 1;            /*!< [30..30] HSIC-Connect                                                     */
      __IOM uint32_t InvSelHsic : 1;            /*!< [31..31] HSIC-Invert Select HSIC                                          */
    } GLPMCFG_b;
  } ;
  
  union {
    __IOM uint32_t GPWRDN;                      /*!< (@ 0x00000058) Global Power Down Register                                 */
    
    struct {
      __IOM uint32_t PMUIntSel  : 1;            /*!< [0..0] PMU Interrupt Select                                               */
      __IOM uint32_t PMUActv    : 1;            /*!< [1..1] PMU Active                                                         */
      __IOM uint32_t Restore    : 1;            /*!< [2..2] Restore.                                                           */
      __IOM uint32_t PwrDnClmp  : 1;            /*!< [3..3] Power Down Clamp                                                   */
      __IOM uint32_t PwrDnRst_n : 1;            /*!< [4..4] Power Down ResetN                                                  */
      __IOM uint32_t PwrDnSwtch : 1;            /*!< [5..5] Power Down Switch                                                  */
      __IOM uint32_t DisableVBUS : 1;           /*!< [6..6] Disable VBUS                                                       */
      __IOM uint32_t LnStsChng  : 1;            /*!< [7..7] Line State Change                                                  */
      __IOM uint32_t LineStageChangeMsk : 1;    /*!< [8..8] Line State Change Mask                                             */
      __IOM uint32_t ResetDetected : 1;         /*!< [9..9] Reset Detected                                                     */
      __IOM uint32_t ResetDetMsk : 1;           /*!< [10..10] Reset Detect Mask                                                */
      __IOM uint32_t DisconnectDetect : 1;      /*!< [11..11] Disconnect Detect                                                */
      __IOM uint32_t DisconnectDetectMsk : 1;   /*!< [12..12] Disconnect Detect Mask                                           */
      __IOM uint32_t ConnectDet : 1;            /*!< [13..13] Connect Detect                                                   */
      __IOM uint32_t ConnDetMsk : 1;            /*!< [14..14] Connect Detect Mask                                              */
      __IOM uint32_t SRPDetect  : 1;            /*!< [15..15] SRP Detect                                                       */
      __IOM uint32_t SRPDetectMsk : 1;          /*!< [16..16] SRP Detect Mask                                                  */
      __IOM uint32_t StsChngInt : 1;            /*!< [17..17] Status Change Interrupt                                          */
      __IOM uint32_t StsChngIntMsk : 1;         /*!< [18..18] Status Change Interrupt Mask                                     */
      __IM  uint32_t LineState  : 2;            /*!< [20..19] LineState.                                                       */
      __IM  uint32_t IDDIG      : 1;            /*!< [21..21] Status of signal IDDIG                                           */
      __IM  uint32_t BSessVld   : 1;            /*!< [22..22] B Session Valid                                                  */
      __IOM uint32_t ADPInt     : 1;            /*!< [23..23] ADP Interrupt                                                    */
      __IOM uint32_t MultValIdBC : 5;           /*!< [28..24] MultValIdBC                                                      */
            uint32_t            : 3;
    } GPWRDN_b;
  } ;
  
  union {
    __IOM uint32_t GDFIFOCFG;                   /*!< (@ 0x0000005C) Global DFIFO Configuration Register                        */
    
    struct {
      __IOM uint32_t GDFIFOCfg  : 16;           /*!< [15..0] GDFIFO Configuration                                              */
      __IOM uint32_t EPInfoBaseAddr : 16;       /*!< [31..16] Start address of the EP info controller                          */
    } GDFIFOCFG_b;
  } ;
  
  union {
    __IOM uint32_t GADPCTL;                     /*!< (@ 0x00000060) ADP Timer, Control and Status Register                     */
    
    struct {
      __IOM uint32_t PrbDschg   : 2;            /*!< [1..0] Probe Discharge                                                    */
      __IOM uint32_t PrbDelta   : 2;            /*!< [3..2] Probe Delta                                                        */
      __IOM uint32_t PrbPer     : 2;            /*!< [5..4] Probe Period                                                       */
      __IM  uint32_t RTIM       : 11;           /*!< [16..6] RAMP TIME                                                         */
      __IOM uint32_t EnaPrb     : 1;            /*!< [17..17] Enable Probe                                                     */
      __IOM uint32_t EnaSns     : 1;            /*!< [18..18] Enable Sense                                                     */
      __IOM uint32_t ADPRes     : 1;            /*!< [19..19] ADP Reset                                                        */
      __IOM uint32_t ADPEn      : 1;            /*!< [20..20] ADP Enable                                                       */
      __IOM uint32_t AdpPrbInt  : 1;            /*!< [21..21] ADP Probe Interrupt                                              */
      __IOM uint32_t AdpSnsInt  : 1;            /*!< [22..22] ADP Sense Interrupt                                              */
      __IOM uint32_t AdpToutInt : 1;            /*!< [23..23] ADP Timeout Interrupt                                            */
      __IOM uint32_t AdpPrbIntMsk : 1;          /*!< [24..24] ADP Probe Interrupt Mask                                         */
      __IOM uint32_t AdpSnsIntMsk : 1;          /*!< [25..25] ADP Sense Interrupt Mask                                         */
      __IOM uint32_t AdpToutMsk : 1;            /*!< [26..26] ADP Timeout Interrupt Mask                                       */
      __IOM uint32_t AR         : 2;            /*!< [28..27] Access Request                                                   */
            uint32_t            : 3;
    } GADPCTL_b;
  } ;
  
  union {
    __IOM uint32_t GREFCLK;                     /*!< (@ 0x00000064) ref_clk Control Register                                   */
    
    struct {
      __IOM uint32_t SOF_CNT_WKUP_ALERT : 10;   /*!< [9..0] Number of SOF's for wakeup alert                                   */
            uint32_t            : 4;
      __IOM uint32_t RefclkMode : 1;            /*!< [14..14] Refclk Mode of Operation                                         */
      __IOM uint32_t REFCLKPER  : 17;           /*!< [31..15] Period of ref_clk in terms of pico seconds                       */
    } GREFCLK_b;
  } ;
  
  union {
    __IOM uint32_t GINTMSK2;                    /*!< (@ 0x00000068) Interrupt Mask Register 2                                  */
    
    struct {
      __IOM uint32_t WkUpAlertIntMsk : 1;       /*!< [0..0] Remote WakeUp Alert Interrupt Mask                                 */
            uint32_t            : 31;
    } GINTMSK2_b;
  } ;
  
  union {
    __IOM uint32_t GINTSTS2;                    /*!< (@ 0x0000006C) Interrupt Register 2                                       */
    
    struct {
      __IOM uint32_t WkUpAlertInt : 1;          /*!< [0..0] Remote WakeUp Alert Interrupt                                      */
            uint32_t            : 31;
    } GINTSTS2_b;
  } ;
  __IM  uint32_t  RESERVED[36];
  __IOM uint32_t  HPTXFSIZ;                     /*!< (@ 0x00000100) Host Periodic Transmit FIFO Size Register                  */
  __IOM uint32_t  DIEPTXF[15];                  /*!< (@ 0x00000104) Device IN Endpoint Transmit FIFO Size Register             */
} USB_OTG_CORE_Type;                            /*!< Size = 320 (0x140)                                                        */



/* =========================================================================================================================== */
/* ================                                         USB_HOST                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief USB OTG Host Controller (USB_HOST)
  */

typedef struct {                                /*!< (@ 0x40040400) USB_HOST Structure                                         */
  __IOM uint32_t  HCFG;                         /*!< (@ 0x00000000) Host Configuration Register                                */
  __IOM uint32_t  HFIR;                         /*!< (@ 0x00000004) Host Frame Interval Register                               */
  __IM  uint32_t  HFNUM;                        /*!< (@ 0x00000008) Host Frame Number/Frame Time Remaining Register            */
  __IM  uint32_t  RESERVED;
  __IM  uint32_t  HPTXSTS;                      /*!< (@ 0x00000010) Host Periodic Transmit FIFO/Queue Status Register          */
  __IM  uint32_t  HAINT;                        /*!< (@ 0x00000014) Host All Channels Interrupt Register                       */
  __IOM uint32_t  HAINTMSK;                     /*!< (@ 0x00000018) Host All Channels Interrupt Mask Register                  */
  __IOM uint32_t  HFLBAddr;                     /*!< (@ 0x0000001C) Host Frame List Base Address Register                      */
  __IM  uint32_t  RESERVED1[8];
  __IOM uint32_t  HPRT;                         /*!< (@ 0x00000040) Host Port Control and Status Register                      */
  __IM  uint32_t  RESERVED2[47];
  __IOM uint32_t  HCCHAR0;                      /*!< (@ 0x00000100) Host Channel 0 Characteristics Register                    */
  __IOM uint32_t  HCSPLT0;                      /*!< (@ 0x00000104) Host Channel 0 Split Control Register                      */
  __IOM uint32_t  HCINT0;                       /*!< (@ 0x00000108) Host Channel 0 Interrupt Register                          */
  __IOM uint32_t  HCINTMSK0;                    /*!< (@ 0x0000010C) Host Channel 0 Interrupt Mask Register                     */
  __IOM uint32_t  HCTSIZ0;                      /*!< (@ 0x00000110) Host Channel 0 Transfer Size Register                      */
  __IM  uint32_t  RESERVED3[3];
  __IOM uint32_t  HCCHAR1;                      /*!< (@ 0x00000120) Host Channel 1 Characteristics Register                    */
  __IOM uint32_t  HCSPLT1;                      /*!< (@ 0x00000124) Host Channel 1 Split Control Register                      */
  __IOM uint32_t  HCINT1;                       /*!< (@ 0x00000128) Host Channel 1 Interrupt Register                          */
  __IOM uint32_t  HCINTMSK1;                    /*!< (@ 0x0000012C) Host Channel 1 Interrupt Mask Register                     */
  __IOM uint32_t  HCTSIZ1;                      /*!< (@ 0x00000130) Host Channel 1 Transfer Size Register                      */
  __IM  uint32_t  RESERVED4[3];
  __IOM uint32_t  HCCHAR2;                      /*!< (@ 0x00000140) Host Channel 2 Characteristics Register                    */
  __IOM uint32_t  HCSPLT2;                      /*!< (@ 0x00000144) Host Channel 2 Split Control Register                      */
  __IOM uint32_t  HCINT2;                       /*!< (@ 0x00000148) Host Channel 2 Interrupt Register                          */
  __IOM uint32_t  HCINTMSK2;                    /*!< (@ 0x0000014C) Host Channel 2 Interrupt Mask Register                     */
  __IOM uint32_t  HCTSIZ2;                      /*!< (@ 0x00000150) Host Channel 2 Transfer Size Register                      */
  __IM  uint32_t  RESERVED5[3];
  __IOM uint32_t  HCCHAR3;                      /*!< (@ 0x00000160) Host Channel 3 Characteristics Register                    */
  __IOM uint32_t  HCSPLT3;                      /*!< (@ 0x00000164) Host Channel 3 Split Control Register                      */
  __IOM uint32_t  HCINT3;                       /*!< (@ 0x00000168) Host Channel 3 Interrupt Register                          */
  __IOM uint32_t  HCINTMSK3;                    /*!< (@ 0x0000016C) Host Channel 3 Interrupt Mask Register                     */
  __IOM uint32_t  HCTSIZ3;                      /*!< (@ 0x00000170) Host Channel 3 Transfer Size Register                      */
} USB_OTG_HOST_Type;                            /*!< Size = 372 (0x174)                                                        */



/* =========================================================================================================================== */
/* ================                                        USB_DEVICE                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief USB OTG Device Controller (USB_DEVICE)
  */

typedef struct {                                /*!< (@ 0x40040800) USB_DEVICE Structure                                       */
  __IOM uint32_t  DCFG;                         /*!< (@ 0x00000000) Device Configuration Register                              */
  __IOM uint32_t  DCTL;                         /*!< (@ 0x00000004) Device Control Register                                    */
  __IOM uint32_t  DSTS;                         /*!< (@ 0x00000008) Device Status Register                                     */
  __IM  uint32_t  RESERVED;
  __IOM uint32_t  DIEPMSK;                      /*!< (@ 0x00000010) Device IN Endpoint Common Interrupt Mask Register          */
  __IOM uint32_t  DOEPMSK;                      /*!< (@ 0x00000014) Device OUT Endpoint Common Interrupt Mask Register         */
  __IOM uint32_t  DAINT;                        /*!< (@ 0x00000018) Device All Endpoints Interrupt Register                    */
  __IOM uint32_t  DAINTMSK;                     /*!< (@ 0x0000001C) Device All Endpoints Interrupt Mask Register               */
  __IM  uint32_t  RESERVED1[2];
  __IOM uint32_t  DVBUSDIS;                     /*!< (@ 0x00000028) Device VBUS Discharge Time Register                        */
  __IOM uint32_t  DVBUSPULSE;                   /*!< (@ 0x0000002C) Device VBUS Pulsing Time Register                          */
  __IOM uint32_t  DTHRCTL;                      /*!< (@ 0x00000030) Device Threshold Control Register                          */
  __IOM uint32_t  DIEPEMPMSK;                   /*!< (@ 0x00000034) Device IN Endpoint FIFO Empty Interrupt Mask
                                                                    Register                                                   */
  __IOM uint32_t  DEACHINT;                     /*!< (@ 0x00000038) Device Each Endpoints Interrupt Register                   */
  __IOM uint32_t  DEACHINTMSK0;                 /*!< (@ 0x0000003C) Device Each Endpoints Interrupt Mask Register              */
  __IOM uint32_t  DIEPTXF[16];                  /*!< (@ 0x00000040) Device Each IN Endpoint Interrupt Registers                */
  __IOM uint32_t  DOEPEACHMSK[16];              /*!< (@ 0x00000080) Device Each OUT Endpoint Interrupt Registers               */
} USB_OTG_DEVICE_Type;                          /*!< Size = 192 (0xc0)                                                         */



/* =========================================================================================================================== */
/* ================                                         USB_IN_EP                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief USB OTG IN-Endpoint Controller (USB_IN_EP)
  */

typedef struct {                                /*!< (@ 0x40040900) USB_IN_EP Structure                                        */
  __IOM uint32_t  DIEPCTL0;                     /*!< (@ 0x00000000) Device Control IN Endpoint 0 Control Register              */
  __IM  uint32_t  RESERVED;
  __IOM uint32_t  DIEPINT0;                     /*!< (@ 0x00000008) Device IN Endpoint 0 Interrupt Register                    */
  __IM  uint32_t  RESERVED1;
  __IOM uint32_t  DIEPTSIZ0;                    /*!< (@ 0x00000010) Device IN Endpoint 0 Transfer Size Register                */
  __IOM uint32_t  DIEPDMA0;                     /*!< (@ 0x00000014) Device IN Endpoint 0 DMA Address Register                  */
  __IM  uint32_t  DTXFSTS0;                     /*!< (@ 0x00000018) Device IN Endpoint 0 Transmit FIFO Status Register         */
  __IOM uint32_t  DIEPDMAB0;                    /*!< (@ 0x0000001C) Device IN Endpoint 0 Buffer Address Register               */
  __IOM uint32_t  DIEPCTL1;                     /*!< (@ 0x00000020) Device Control IN Endpoint 1 Control Register              */
  __IM  uint32_t  RESERVED2;
  __IOM uint32_t  DIEPINT1;                     /*!< (@ 0x00000028) Device IN Endpoint 1 Interrupt Register                    */
  __IM  uint32_t  RESERVED3;
  __IOM uint32_t  DIEPTSIZ1;                    /*!< (@ 0x00000030) Device IN Endpoint 1 Transfer Size Register                */
  __IOM uint32_t  DIEPDMA1;                     /*!< (@ 0x00000034) Device IN Endpoint 1 DMA Address Register                  */
  __IM  uint32_t  DTXFSTS1;                     /*!< (@ 0x00000038) Device IN Endpoint 1 Transmit FIFO Status Register         */
  __IOM uint32_t  DIEPDMAB1;                    /*!< (@ 0x0000003C) Device IN Endpoint 1 Buffer Address Register               */
  __IOM uint32_t  DIEPCTL2;                     /*!< (@ 0x00000040) Device Control IN Endpoint 2 Control Register              */
  __IM  uint32_t  RESERVED4;
  __IOM uint32_t  DIEPINT2;                     /*!< (@ 0x00000048) Device IN Endpoint 2 Interrupt Register                    */
  __IM  uint32_t  RESERVED5;
  __IOM uint32_t  DIEPTSIZ2;                    /*!< (@ 0x00000050) Device IN Endpoint 2 Transfer Size Register                */
  __IOM uint32_t  DIEPDMA2;                     /*!< (@ 0x00000054) Device IN Endpoint 2 DMA Address Register                  */
  __IM  uint32_t  DTXFSTS2;                     /*!< (@ 0x00000058) Device IN Endpoint 2 Transmit FIFO Status Register         */
  __IOM uint32_t  DIEPDMAB2;                    /*!< (@ 0x0000005C) Device IN Endpoint 2 Buffer Address Register               */
  __IOM uint32_t  DIEPCTL3;                     /*!< (@ 0x00000060) Device Control IN Endpoint 3 Control Register              */
  __IM  uint32_t  RESERVED6;
  __IOM uint32_t  DIEPINT3;                     /*!< (@ 0x00000068) Device IN Endpoint 3 Interrupt Register                    */
  __IM  uint32_t  RESERVED7;
  __IOM uint32_t  DIEPTSIZ3;                    /*!< (@ 0x00000070) Device IN Endpoint 3 Transfer Size Register                */
  __IOM uint32_t  DIEPDMA3;                     /*!< (@ 0x00000074) Device IN Endpoint 3 DMA Address Register                  */
  __IM  uint32_t  DTXFSTS3;                     /*!< (@ 0x00000078) Device IN Endpoint 3 Transmit FIFO Status Register         */
  __IOM uint32_t  DIEPDMAB3;                    /*!< (@ 0x0000007C) Device IN Endpoint 3 Buffer Address Register               */
  __IOM uint32_t  DIEPCTL4;                     /*!< (@ 0x00000080) Device Control IN Endpoint 4 Control Register              */
  __IM  uint32_t  RESERVED8;
  __IOM uint32_t  DIEPINT4;                     /*!< (@ 0x00000088) Device IN Endpoint 4 Interrupt Register                    */
  __IM  uint32_t  RESERVED9;
  __IOM uint32_t  DIEPTSIZ4;                    /*!< (@ 0x00000090) Device IN Endpoint 4 Transfer Size Register                */
  __IOM uint32_t  DIEPDMA4;                     /*!< (@ 0x00000094) Device IN Endpoint 4 DMA Address Register                  */
  __IM  uint32_t  DTXFSTS4;                     /*!< (@ 0x00000098) Device IN Endpoint 4 Transmit FIFO Status Register         */
  __IOM uint32_t  DIEPDMAB4;                    /*!< (@ 0x0000009C) Device IN Endpoint 4 Buffer Address Register               */
  __IOM uint32_t  DIEPCTL5;                     /*!< (@ 0x000000A0) Device Control IN Endpoint 5 Control Register              */
  __IM  uint32_t  RESERVED10;
  __IOM uint32_t  DIEPINT5;                     /*!< (@ 0x000000A8) Device IN Endpoint 5 Interrupt Register                    */
  __IM  uint32_t  RESERVED11;
  __IOM uint32_t  DIEPTSIZ5;                    /*!< (@ 0x000000B0) Device IN Endpoint 5 Transfer Size Register                */
  __IOM uint32_t  DIEPDMA5;                     /*!< (@ 0x000000B4) Device IN Endpoint 5 DMA Address Register                  */
  __IM  uint32_t  DTXFSTS5;                     /*!< (@ 0x000000B8) Device IN Endpoint 5 Transmit FIFO Status Register         */
  __IOM uint32_t  DIEPDMAB5;                    /*!< (@ 0x000000BC) Device IN Endpoint 5 Buffer Address Register               */
  __IOM uint32_t  DIEPCTL6;                     /*!< (@ 0x000000C0) Device Control IN Endpoint 6 Control Register              */
  __IM  uint32_t  RESERVED12;
  __IOM uint32_t  DIEPINT6;                     /*!< (@ 0x000000C8) Device IN Endpoint 6 Interrupt Register                    */
  __IM  uint32_t  RESERVED13;
  __IOM uint32_t  DIEPTSIZ6;                    /*!< (@ 0x000000D0) Device IN Endpoint 6 Transfer Size Register                */
  __IOM uint32_t  DIEPDMA6;                     /*!< (@ 0x000000D4) Device IN Endpoint 6 DMA Address Register                  */
  __IM  uint32_t  DTXFSTS6;                     /*!< (@ 0x000000D8) Device IN Endpoint 6 Transmit FIFO Status Register         */
  __IOM uint32_t  DIEPDMAB6;                    /*!< (@ 0x000000DC) Device IN Endpoint 6 Buffer Address Register               */
  __IOM uint32_t  DIEPCTL7;                     /*!< (@ 0x000000E0) Device Control IN Endpoint 7 Control Register              */
  __IM  uint32_t  RESERVED14;
  __IOM uint32_t  DIEPINT7;                     /*!< (@ 0x000000E8) Device IN Endpoint 7 Interrupt Register                    */
  __IM  uint32_t  RESERVED15;
  __IOM uint32_t  DIEPTSIZ7;                    /*!< (@ 0x000000F0) Device IN Endpoint 7 Transfer Size Register                */
  __IOM uint32_t  DIEPDMA7;                     /*!< (@ 0x000000F4) Device IN Endpoint 7 DMA Address Register                  */
  __IM  uint32_t  DTXFSTS7;                     /*!< (@ 0x000000F8) Device IN Endpoint 7 Transmit FIFO Status Register         */
  __IOM uint32_t  DIEPDMAB7;                    /*!< (@ 0x000000FC) Device IN Endpoint 7 Buffer Address Register               */
  __IOM uint32_t  DIEPCTL8;                     /*!< (@ 0x00000100) Device Control IN Endpoint 8 Control Register              */
  __IM  uint32_t  RESERVED16;
  __IOM uint32_t  DIEPINT8;                     /*!< (@ 0x00000108) Device IN Endpoint 8 Interrupt Register                    */
  __IM  uint32_t  RESERVED17;
  __IOM uint32_t  DIEPTSIZ8;                    /*!< (@ 0x00000110) Device IN Endpoint 8 Transfer Size Register                */
  __IOM uint32_t  DIEPDMA8;                     /*!< (@ 0x00000114) Device IN Endpoint 8 DMA Address Register                  */
  __IM  uint32_t  DTXFSTS8;                     /*!< (@ 0x00000118) Device IN Endpoint 8 Transmit FIFO Status Register         */
  __IOM uint32_t  DIEPDMAB8;                    /*!< (@ 0x0000011C) Device IN Endpoint 8 Buffer Address Register               */
  __IOM uint32_t  DIEPCTL9;                     /*!< (@ 0x00000120) Device Control IN Endpoint 9 Control Register              */
  __IM  uint32_t  RESERVED18;
  __IOM uint32_t  DIEPINT9;                     /*!< (@ 0x00000128) Device IN Endpoint 9 Interrupt Register                    */
  __IM  uint32_t  RESERVED19;
  __IOM uint32_t  DIEPTSIZ9;                    /*!< (@ 0x00000130) Device IN Endpoint 9 Transfer Size Register                */
  __IOM uint32_t  DIEPDMA9;                     /*!< (@ 0x00000134) Device IN Endpoint 9 DMA Address Register                  */
  __IM  uint32_t  DTXFSTS9;                     /*!< (@ 0x00000138) Device IN Endpoint 9 Transmit FIFO Status Register         */
  __IOM uint32_t  DIEPDMAB9;                    /*!< (@ 0x0000013C) Device IN Endpoint 9 Buffer Address Register               */
  __IOM uint32_t  DIEPCTL10;                    /*!< (@ 0x00000140) Device Control IN Endpoint 10 Control Register             */
  __IM  uint32_t  RESERVED20;
  __IOM uint32_t  DIEPINT10;                    /*!< (@ 0x00000148) Device IN Endpoint 10 Interrupt Register                   */
  __IM  uint32_t  RESERVED21;
  __IOM uint32_t  DIEPTSIZ10;                   /*!< (@ 0x00000150) Device IN Endpoint 10 Transfer Size Register               */
  __IOM uint32_t  DIEPDMA10;                    /*!< (@ 0x00000154) Device IN Endpoint 10 DMA Address Register                 */
  __IM  uint32_t  DTXFSTS10;                    /*!< (@ 0x00000158) Device IN Endpoint 10 Transmit FIFO Status Register        */
  __IOM uint32_t  DIEPDMAB10;                   /*!< (@ 0x0000015C) Device IN Endpoint 10 Buffer Address Register              */
  __IOM uint32_t  DIEPCTL11;                    /*!< (@ 0x00000160) Device Control IN Endpoint 11 Control Register             */
  __IM  uint32_t  RESERVED22;
  __IOM uint32_t  DIEPINT11;                    /*!< (@ 0x00000168) Device IN Endpoint 11 Interrupt Register                   */
  __IM  uint32_t  RESERVED23;
  __IOM uint32_t  DIEPTSIZ11;                   /*!< (@ 0x00000170) Device IN Endpoint 11 Transfer Size Register               */
  __IOM uint32_t  DIEPDMA11;                    /*!< (@ 0x00000174) Device IN Endpoint 11 DMA Address Register                 */
  __IM  uint32_t  DTXFSTS11;                    /*!< (@ 0x00000178) Device IN Endpoint 11 Transmit FIFO Status Register        */
  __IOM uint32_t  DIEPDMAB11;                   /*!< (@ 0x0000017C) Device IN Endpoint 11 Buffer Address Register              */
  __IOM uint32_t  DIEPCTL12;                    /*!< (@ 0x00000180) Device Control IN Endpoint 12 Control Register             */
  __IM  uint32_t  RESERVED24;
  __IOM uint32_t  DIEPINT12;                    /*!< (@ 0x00000188) Device IN Endpoint 12 Interrupt Register                   */
  __IM  uint32_t  RESERVED25;
  __IOM uint32_t  DIEPTSIZ12;                   /*!< (@ 0x00000190) Device IN Endpoint 12 Transfer Size Register               */
  __IOM uint32_t  DIEPDMA12;                    /*!< (@ 0x00000194) Device IN Endpoint 12 DMA Address Register                 */
  __IM  uint32_t  DTXFSTS12;                    /*!< (@ 0x00000198) Device IN Endpoint 12 Transmit FIFO Status Register        */
  __IOM uint32_t  DIEPDMAB12;                   /*!< (@ 0x0000019C) Device IN Endpoint 12 Buffer Address Register              */
  __IOM uint32_t  DIEPCTL13;                    /*!< (@ 0x000001A0) Device Control IN Endpoint 13 Control Register             */
  __IM  uint32_t  RESERVED26;
  __IOM uint32_t  DIEPINT13;                    /*!< (@ 0x000001A8) Device IN Endpoint 13 Interrupt Register                   */
  __IM  uint32_t  RESERVED27;
  __IOM uint32_t  DIEPTSIZ13;                   /*!< (@ 0x000001B0) Device IN Endpoint 13 Transfer Size Register               */
  __IOM uint32_t  DIEPDMA13;                    /*!< (@ 0x000001B4) Device IN Endpoint 13 DMA Address Register                 */
  __IM  uint32_t  DTXFSTS13;                    /*!< (@ 0x000001B8) Device IN Endpoint 13 Transmit FIFO Status Register        */
  __IOM uint32_t  DIEPDMAB13;                   /*!< (@ 0x000001BC) Device IN Endpoint 13 Buffer Address Register              */
  __IOM uint32_t  DIEPCTL14;                    /*!< (@ 0x000001C0) Device Control IN Endpoint 14 Control Register             */
  __IM  uint32_t  RESERVED28;
  __IOM uint32_t  DIEPINT14;                    /*!< (@ 0x000001C8) Device IN Endpoint 14 Interrupt Register                   */
  __IM  uint32_t  RESERVED29;
  __IOM uint32_t  DIEPTSIZ14;                   /*!< (@ 0x000001D0) Device IN Endpoint 14 Transfer Size Register               */
  __IOM uint32_t  DIEPDMA14;                    /*!< (@ 0x000001D4) Device IN Endpoint 14 DMA Address Register                 */
  __IM  uint32_t  DTXFSTS14;                    /*!< (@ 0x000001D8) Device IN Endpoint 14 Transmit FIFO Status Register        */
  __IOM uint32_t  DIEPDMAB14;                   /*!< (@ 0x000001DC) Device IN Endpoint 14 Buffer Address Register              */
  __IOM uint32_t  DIEPCTL15;                    /*!< (@ 0x000001E0) Device Control IN Endpoint 15 Control Register             */
  __IM  uint32_t  RESERVED30;
  __IOM uint32_t  DIEPINT15;                    /*!< (@ 0x000001E8) Device IN Endpoint 15 Interrupt Register                   */
  __IM  uint32_t  RESERVED31;
  __IOM uint32_t  DIEPTSIZ15;                   /*!< (@ 0x000001F0) Device IN Endpoint 15 Transfer Size Register               */
  __IOM uint32_t  DIEPDMA15;                    /*!< (@ 0x000001F4) Device IN Endpoint 15 DMA Address Register                 */
  __IM  uint32_t  DTXFSTS15;                    /*!< (@ 0x000001F8) Device IN Endpoint 15 Transmit FIFO Status Register        */
  __IOM uint32_t  DIEPDMAB15;                   /*!< (@ 0x000001FC) Device IN Endpoint 15 Buffer Address Register              */
} USB_OTG_IN_EP_Type;                           /*!< Size = 512 (0x200)                                                        */



/* =========================================================================================================================== */
/* ================                                        USB_OUT_EP                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief USB OTG Out-Endpoint Controller (USB_OUT_EP)
  */

typedef struct {                                /*!< (@ 0x40040B00) USB_OUT_EP Structure                                       */
  __IOM uint32_t  DOEPCTL0;                     /*!< (@ 0x00000000) Device Control OUT Endpoint 0 Control Register             */
  __IM  uint32_t  RESERVED;
  __IOM uint32_t  DOEPINT0;                     /*!< (@ 0x00000008) Device OUT Endpoint 0 Interrupt Register                   */
  __IM  uint32_t  RESERVED1;
  __IOM uint32_t  DOEPTSIZ0;                    /*!< (@ 0x00000010) Device OUT Endpoint 0 Transfer Size Register               */
  __IOM uint32_t  DOEPDMA0;                     /*!< (@ 0x00000014) Device OUT Endpoint 0 DMA Address Register                 */
  __IM  uint32_t  RESERVED2;
  __IOM uint32_t  DOEPDMAB0;                    /*!< (@ 0x0000001C) Device OUT Endpoint 0 DMA Buffer Address Register          */
  __IOM uint32_t  DOEPCTL1;                     /*!< (@ 0x00000020) Device Control OUT Endpoint 1 Control Register             */
  __IM  uint32_t  RESERVED3;
  __IOM uint32_t  DOEPINT1;                     /*!< (@ 0x00000028) Device OUT Endpoint 1 Interrupt Register                   */
  __IM  uint32_t  RESERVED4;
  __IOM uint32_t  DOEPTSIZ1;                    /*!< (@ 0x00000030) Device OUT Endpoint 1 Transfer Size Register               */
  __IOM uint32_t  DOEPDMA1;                     /*!< (@ 0x00000034) Device OUT Endpoint 1 DMA Address Register                 */
  __IM  uint32_t  RESERVED5;
  __IM  uint32_t  DOEPDMAB1;                    /*!< (@ 0x0000003C) Device OUT Endpoint 1 Buffer Address Register              */
  __IOM uint32_t  DOEPCTL2;                     /*!< (@ 0x00000040) Device Control OUT Endpoint 2 Control Register             */
  __IM  uint32_t  RESERVED6;
  __IOM uint32_t  DOEPINT2;                     /*!< (@ 0x00000048) Device OUT Endpoint 2 Interrupt Register                   */
  __IM  uint32_t  RESERVED7;
  __IOM uint32_t  DOEPTSIZ2;                    /*!< (@ 0x00000050) Device OUT Endpoint 2 Transfer Size Register               */
  __IOM uint32_t  DOEPDMA2;                     /*!< (@ 0x00000054) Device OUT Endpoint 2 DMA Address Register                 */
  __IM  uint32_t  RESERVED8;
  __IM  uint32_t  DOEPDMAB2;                    /*!< (@ 0x0000005C) Device OUT Endpoint 2 Buffer Address Register              */
  __IOM uint32_t  DOEPCTL3;                     /*!< (@ 0x00000060) Device Control OUT Endpoint 3 Control Register             */
  __IM  uint32_t  RESERVED9;
  __IOM uint32_t  DOEPINT3;                     /*!< (@ 0x00000068) Device OUT Endpoint 3 Interrupt Register                   */
  __IM  uint32_t  RESERVED10;
  __IOM uint32_t  DOEPTSIZ3;                    /*!< (@ 0x00000070) Device OUT Endpoint 3 Transfer Size Register               */
  __IOM uint32_t  DOEPDMA3;                     /*!< (@ 0x00000074) Device OUT Endpoint 3 DMA Address Register                 */
  __IM  uint32_t  RESERVED11;
  __IM  uint32_t  DOEPDMAB3;                    /*!< (@ 0x0000007C) Device OUT Endpoint 3 Buffer Address Register              */
  __IOM uint32_t  DOEPCTL4;                     /*!< (@ 0x00000080) Device Control OUT Endpoint 4 Control Register             */
  __IM  uint32_t  RESERVED12;
  __IOM uint32_t  DOEPINT4;                     /*!< (@ 0x00000088) Device OUT Endpoint 4 Interrupt Register                   */
  __IM  uint32_t  RESERVED13;
  __IOM uint32_t  DOEPTSIZ4;                    /*!< (@ 0x00000090) Device OUT Endpoint 4 Transfer Size Register               */
  __IOM uint32_t  DOEPDMA4;                     /*!< (@ 0x00000094) Device OUT Endpoint 4 DMA Address Register                 */
  __IM  uint32_t  RESERVED14;
  __IM  uint32_t  DOEPDMAB4;                    /*!< (@ 0x0000009C) Device OUT Endpoint 4 Buffer Address Register              */
  __IOM uint32_t  DOEPCTL5;                     /*!< (@ 0x000000A0) Device Control OUT Endpoint 5 Control Register             */
  __IM  uint32_t  RESERVED15;
  __IOM uint32_t  DOEPINT5;                     /*!< (@ 0x000000A8) Device OUT Endpoint 5 Interrupt Register                   */
  __IM  uint32_t  RESERVED16;
  __IOM uint32_t  DOEPTSIZ5;                    /*!< (@ 0x000000B0) Device OUT Endpoint 5 Transfer Size Register               */
  __IOM uint32_t  DOEPDMA5;                     /*!< (@ 0x000000B4) Device OUT Endpoint 5 DMA Address Register                 */
  __IM  uint32_t  RESERVED17;
  __IM  uint32_t  DOEPDMAB5;                    /*!< (@ 0x000000BC) Device OUT Endpoint 5 Buffer Address Register              */
  __IOM uint32_t  DOEPCTL6;                     /*!< (@ 0x000000C0) Device Control OUT Endpoint 6 Control Register             */
  __IM  uint32_t  RESERVED18;
  __IOM uint32_t  DOEPINT6;                     /*!< (@ 0x000000C8) Device OUT Endpoint 6 Interrupt Register                   */
  __IM  uint32_t  RESERVED19;
  __IOM uint32_t  DOEPTSIZ6;                    /*!< (@ 0x000000D0) Device OUT Endpoint 6 Transfer Size Register               */
  __IOM uint32_t  DOEPDMA6;                     /*!< (@ 0x000000D4) Device OUT Endpoint 6 DMA Address Register                 */
  __IM  uint32_t  RESERVED20;
  __IM  uint32_t  DOEPDMAB6;                    /*!< (@ 0x000000DC) Device OUT Endpoint 6 Buffer Address Register              */
  __IOM uint32_t  DOEPCTL7;                     /*!< (@ 0x000000E0) Device Control OUT Endpoint 7 Control Register             */
  __IM  uint32_t  RESERVED21;
  __IOM uint32_t  DOEPINT7;                     /*!< (@ 0x000000E8) Device OUT Endpoint 7 Interrupt Register                   */
  __IM  uint32_t  RESERVED22;
  __IOM uint32_t  DOEPTSIZ7;                    /*!< (@ 0x000000F0) Device OUT Endpoint 7 Transfer Size Register               */
  __IOM uint32_t  DOEPDMA7;                     /*!< (@ 0x000000F4) Device OUT Endpoint 7 DMA Address Register                 */
  __IM  uint32_t  RESERVED23;
  __IM  uint32_t  DOEPDMAB7;                    /*!< (@ 0x000000FC) Device OUT Endpoint 7 Buffer Address Register              */
  __IOM uint32_t  DOEPCTL8;                     /*!< (@ 0x00000100) Device Control OUT Endpoint 8 Control Register             */
  __IM  uint32_t  RESERVED24;
  __IOM uint32_t  DOEPINT8;                     /*!< (@ 0x00000108) Device OUT Endpoint 8 Interrupt Register                   */
  __IM  uint32_t  RESERVED25;
  __IOM uint32_t  DOEPTSIZ8;                    /*!< (@ 0x00000110) Device OUT Endpoint 8 Transfer Size Register               */
  __IOM uint32_t  DOEPDMA8;                     /*!< (@ 0x00000114) Device OUT Endpoint 8 DMA Address Register                 */
  __IM  uint32_t  RESERVED26;
  __IM  uint32_t  DOEPDMAB8;                    /*!< (@ 0x0000011C) Device OUT Endpoint 8 Buffer Address Register              */
  __IOM uint32_t  DOEPCTL9;                     /*!< (@ 0x00000120) Device Control OUT Endpoint 9 Control Register             */
  __IM  uint32_t  RESERVED27;
  __IOM uint32_t  DOEPINT9;                     /*!< (@ 0x00000128) Device OUT Endpoint 9 Interrupt Register                   */
  __IM  uint32_t  RESERVED28;
  __IOM uint32_t  DOEPTSIZ9;                    /*!< (@ 0x00000130) Device OUT Endpoint 9 Transfer Size Register               */
  __IOM uint32_t  DOEPDMA9;                     /*!< (@ 0x00000134) Device OUT Endpoint 9 DMA Address Register                 */
  __IM  uint32_t  RESERVED29;
  __IM  uint32_t  DOEPDMAB9;                    /*!< (@ 0x0000013C) Device OUT Endpoint 9 Buffer Address Register              */
  __IOM uint32_t  DOEPCTL10;                    /*!< (@ 0x00000140) Device Control OUT Endpoint 10 Control Register            */
  __IM  uint32_t  RESERVED30;
  __IOM uint32_t  DOEPINT10;                    /*!< (@ 0x00000148) Device OUT Endpoint 10 Interrupt Register                  */
  __IM  uint32_t  RESERVED31;
  __IOM uint32_t  DOEPTSIZ10;                   /*!< (@ 0x00000150) Device OUT Endpoint 10 Transfer Size Register              */
  __IOM uint32_t  DOEPDMA10;                    /*!< (@ 0x00000154) Device OUT Endpoint 10 DMA Address Register                */
  __IM  uint32_t  RESERVED32;
  __IM  uint32_t  DOEPDMAB10;                   /*!< (@ 0x0000015C) Device OUT Endpoint 10 Buffer Address Register             */
  __IOM uint32_t  DOEPCTL11;                    /*!< (@ 0x00000160) Device Control OUT Endpoint 11 Control Register            */
  __IM  uint32_t  RESERVED33;
  __IOM uint32_t  DOEPINT11;                    /*!< (@ 0x00000168) Device OUT Endpoint 11 Interrupt Register                  */
  __IM  uint32_t  RESERVED34;
  __IOM uint32_t  DOEPTSIZ11;                   /*!< (@ 0x00000170) Device OUT Endpoint 11 Transfer Size Register              */
  __IOM uint32_t  DOEPDMA11;                    /*!< (@ 0x00000174) Device OUT Endpoint 11 DMA Address Register                */
  __IM  uint32_t  RESERVED35;
  __IM  uint32_t  DOEPDMAB11;                   /*!< (@ 0x0000017C) Device OUT Endpoint 11 Buffer Address Register             */
  __IOM uint32_t  DOEPCTL12;                    /*!< (@ 0x00000180) Device Control OUT Endpoint 12 Control Register            */
  __IM  uint32_t  RESERVED36;
  __IOM uint32_t  DOEPINT12;                    /*!< (@ 0x00000188) Device OUT Endpoint 12 Interrupt Register                  */
  __IM  uint32_t  RESERVED37;
  __IOM uint32_t  DOEPTSIZ12;                   /*!< (@ 0x00000190) Device OUT Endpoint 12 Transfer Size Register              */
  __IOM uint32_t  DOEPDMA12;                    /*!< (@ 0x00000194) Device OUT Endpoint 12 DMA Address Register                */
  __IM  uint32_t  RESERVED38;
  __IM  uint32_t  DOEPDMAB12;                   /*!< (@ 0x0000019C) Device OUT Endpoint 12 Buffer Address Register             */
  __IOM uint32_t  DOEPCTL13;                    /*!< (@ 0x000001A0) Device Control OUT Endpoint 13 Control Register            */
  __IM  uint32_t  RESERVED39;
  __IOM uint32_t  DOEPINT13;                    /*!< (@ 0x000001A8) Device OUT Endpoint 13 Interrupt Register                  */
  __IM  uint32_t  RESERVED40;
  __IOM uint32_t  DOEPTSIZ13;                   /*!< (@ 0x000001B0) Device OUT Endpoint 13 Transfer Size Register              */
  __IOM uint32_t  DOEPDMA13;                    /*!< (@ 0x000001B4) Device OUT Endpoint 13 DMA Address Register                */
  __IM  uint32_t  RESERVED41;
  __IM  uint32_t  DOEPDMAB13;                   /*!< (@ 0x000001BC) Device OUT Endpoint 13 Buffer Address Register             */
  __IOM uint32_t  DOEPCTL14;                    /*!< (@ 0x000001C0) Device Control OUT Endpoint 14 Control Register            */
  __IM  uint32_t  RESERVED42;
  __IOM uint32_t  DOEPINT14;                    /*!< (@ 0x000001C8) Device OUT Endpoint 14 Interrupt Register                  */
  __IM  uint32_t  RESERVED43;
  __IOM uint32_t  DOEPTSIZ14;                   /*!< (@ 0x000001D0) Device OUT Endpoint 14 Transfer Size Register              */
  __IOM uint32_t  DOEPDMA14;                    /*!< (@ 0x000001D4) Device OUT Endpoint 14 DMA Address Register                */
  __IM  uint32_t  RESERVED44;
  __IM  uint32_t  DOEPDMAB14;                   /*!< (@ 0x000001DC) Device OUT Endpoint 14 Buffer Address Register             */
  __IOM uint32_t  DOEPCTL15;                    /*!< (@ 0x000001E0) Device Control OUT Endpoint 15 Control Register            */
  __IM  uint32_t  RESERVED45;
  __IOM uint32_t  DOEPINT15;                    /*!< (@ 0x000001E8) Device OUT Endpoint 15 Interrupt Register                  */
  __IM  uint32_t  RESERVED46;
  __IOM uint32_t  DOEPTSIZ15;                   /*!< (@ 0x000001F0) Device OUT Endpoint 15 Transfer Size Register              */
  __IOM uint32_t  DOEPDMA15;                    /*!< (@ 0x000001F4) Device OUT Endpoint 15 DMA Address Register                */
  __IM  uint32_t  RESERVED47;
  __IM  uint32_t  DOEPDMAB15;                   /*!< (@ 0x000001FC) Device OUT Endpoint 15 Buffer Address Register             */
} USB_OTG_OUT_EP_Type;                          /*!< Size = 512 (0x200)                                                        */



/* =========================================================================================================================== */
/* ================                                          SYSTEM                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief System Controller (SYSTEM)
  */

typedef struct {                                /*!< (@ 0x40100000) SYSTEM Structure                                           */
  
  union {
    __IOM uint32_t PERICLKPWRTOP;               /*!< (@ 0x00000000) Peripheral Power Clock Control Register 0                  */
    
    struct {
      __IOM uint32_t USB_DPHY_TOP : 1;          /*!< [0..0] USB DPHY Clock Power Control                                       */
      __IOM uint32_t GPIO_TOP   : 1;            /*!< [1..1] IO Clock Power Control                                             */
      __IOM uint32_t RC24MREF_TOP : 1;          /*!< [2..2] RC 24M Ref Clock Power Control                                     */
      __IOM uint32_t RC24MCAL_TOP : 1;          /*!< [3..3] RC 24M Cal Clock Power Control                                     */
      __IOM uint32_t TACHO_TOP  : 1;            /*!< [4..4] Tachometer Clock Power Control                                     */
      __IOM uint32_t RC32KREF_TOP : 1;          /*!< [5..5] RC 32K Ref Clock Power Control                                     */
      __IOM uint32_t RC32KCAL_TOP : 1;          /*!< [6..6] RC 32K Cal Clock Power Control                                     */
      __IOM uint32_t WDT_TOP    : 1;            /*!< [7..7] Watchdog Timer Clock Power Control                                 */
      __IOM uint32_t PWM_TOP    : 1;            /*!< [8..8] PWM Clock Power Control                                            */
      __IOM uint32_t TMR_TOP    : 1;            /*!< [9..9] Timer Clock Power Control                                          */
      __IOM uint32_t CRC_TOP    : 1;            /*!< [10..10] CRC Clock Power Control                                          */
      __IOM uint32_t MATRIX_TOP : 1;            /*!< [11..11] Matrix Clock Power Control                                       */
      __IOM uint32_t UART_TOP   : 1;            /*!< [12..12] UART Clock Power Control                                         */
      __IOM uint32_t ADC_TOP    : 1;            /*!< [13..13] ADC Clock Power Control                                          */
      __IOM uint32_t STRIP_TOP  : 1;            /*!< [14..14] Strip Clock Power Control                                        */
      __IOM uint32_t I2C_TOP    : 1;            /*!< [15..15] I2C Clock Power Control                                          */
      __IOM uint32_t SPIS_TOP   : 1;            /*!< [16..16] SPI Slave Clock Power Control                                    */
      __IOM uint32_t SPIM_TOP   : 1;            /*!< [17..17] SPI Master Clock Power Control                                   */
      __IOM uint32_t I3C_TOP    : 1;            /*!< [18..18] I3C Clock Power Control                                          */
      __IOM uint32_t APB_TOP    : 1;            /*!< [19..19] APB Clock Power Control                                          */
      __IOM uint32_t USB_TOP    : 1;            /*!< [20..20] USB Clock Power Control                                          */
      __IOM uint32_t SYS_TOP    : 1;            /*!< [21..21] System Clock Power Control                                       */
            uint32_t            : 8;
      __IOM uint32_t SOFTRST_GATING : 1;        /*!< [30..30] Software Reset External Gating                                   */
      __IOM uint32_t SOFTRST    : 1;            /*!< [31..31] Software Reset (Write 1 to Clear)                                */
    } PERICLKPWRTOP_b;
  } ;
  
  union {
    __IOM uint32_t PERICLKSEL0;                 /*!< (@ 0x00000004) PERICLKSEL0 register                                       */
    
    struct {
      __IOM uint32_t TACH_SRC   : 2;            /*!< [1..0] TACH Clock Source Select                                           */
      __IOM uint32_t TMR_SRC    : 2;            /*!< [3..2] TMR Clock Source Select                                            */
      __IOM uint32_t CRC_SRC    : 2;            /*!< [5..4] CRC Source Select                                                  */
      __IOM uint32_t MATRIX_SRC : 2;            /*!< [7..6] Dot Matrix LED Clock Source Select                                 */
      __IOM uint32_t UART_SRC   : 2;            /*!< [9..8] UART Clock Source Select                                           */
      __IOM uint32_t ADC_SRC    : 2;            /*!< [11..10] ADC Clock Source Select                                          */
      __IOM uint32_t STRIP      : 2;            /*!< [13..12] STRIP Clock Source Select                                        */
      __IOM uint32_t I2C_SRC    : 2;            /*!< [15..14] I2C Clock Source Select                                          */
      __IOM uint32_t SPIS_SRC   : 2;            /*!< [17..16] SPI Slave Clock Source Select                                    */
      __IOM uint32_t SPIM_SRC   : 2;            /*!< [19..18] SPI Master Clock Source Select                                   */
      __IOM uint32_t PWM_SRC    : 2;            /*!< [21..20] PWM Clock Source Select                                          */
      __IOM uint32_t APB_SRC    : 2;            /*!< [23..22] Async Bus Clock Source Select                                    */
      __IOM uint32_t SYS_SRC    : 2;            /*!< [25..24] System Clock Source Select                                       */
            uint32_t            : 6;
    } PERICLKSEL0_b;
  } ;
  
  union {
    __IOM uint32_t PERICLKPWR0;                 /*!< (@ 0x00000008) Peripheral Clock Power Control Register 0                  */
    
    struct {
      __IOM uint32_t STRIP0_IP  : 1;            /*!< [0..0] STRIP0 clock enable: 0=Disable, 1=Enable                           */
      __IOM uint32_t STRIP1_IP  : 1;            /*!< [1..1] STRIP1 clock enable: 0=Disable, 1=Enable                           */
      __IOM uint32_t STRIP2_IP  : 1;            /*!< [2..2] STRIP2 clock enable: 0=Disable, 1=Enable                           */
      __IOM uint32_t STRIP3_IP  : 1;            /*!< [3..3] STRIP3 clock enable: 0=Disable, 1=Enable                           */
      __IOM uint32_t STRIP4_IP  : 1;            /*!< [4..4] STRIP4 clock enable: 0=Disable, 1=Enable                           */
      __IOM uint32_t STRIP5_IP  : 1;            /*!< [5..5] STRIP5 clock enable: 0=Disable, 1=Enable                           */
      __IOM uint32_t STRIP6_IP  : 1;            /*!< [6..6] STRIP6 clock enable: 0=Disable, 1=Enable                           */
      __IOM uint32_t STRIP7_IP  : 1;            /*!< [7..7] STRIP7 clock enable: 0=Disable, 1=Enable                           */
      __IOM uint32_t STRIP8_IP  : 1;            /*!< [8..8] STRIP8 clock enable: 0=Disable, 1=Enable                           */
      __IOM uint32_t I2C0_IP    : 1;            /*!< [9..9] I2C0 clock enable: 0=Disable, 1=Enable                             */
      __IOM uint32_t I2C1_IP    : 1;            /*!< [10..10] I2C1 clock enable: 0=Disable, 1=Enable                           */
      __IOM uint32_t I2C2_IP    : 1;            /*!< [11..11] I2C2 clock enable: 0=Disable, 1=Enable                           */
      __IOM uint32_t I2CDBG_IP  : 1;            /*!< [12..12] I2C Debug clock enable: 0=Disable, 1=Enable                      */
      __IOM uint32_t SWD_IP     : 1;            /*!< [13..13] SWD clock enable: 0=Disable, 1=Enable                            */
      __IOM uint32_t SPIS_IP    : 1;            /*!< [14..14] SPIS clock enable: 0=Disable, 1=Enable                           */
      __IOM uint32_t SPIM_IP    : 1;            /*!< [15..15] SPIM clock enable: 0=Disable, 1=Enable                           */
      __IOM uint32_t I3C_IP     : 1;            /*!< [16..16] I3C clock enable: 0=Disable, 1=Enable                            */
      __IOM uint32_t USB_IP     : 1;            /*!< [17..17] USB clock enable: 0=Disable, 1=Enable                            */
      __IOM uint32_t EXTR_SPIC_IP : 1;          /*!< [18..18] EXTR SPIC clock enable: 0=Disable, 1=Enable                      */
      __IOM uint32_t INTR_SPIC_IP : 1;          /*!< [19..19] INTR SPIC clock enable: 0=Disable, 1=Enable                      */
      __IOM uint32_t DMA_IP     : 1;            /*!< [20..20] DMA clock enable: 0=Disable, 1=Enable                            */
      __IOM uint32_t CPU_IP     : 1;            /*!< [21..21] CPU clock enable: 0=Disable, 1=Enable                            */
            uint32_t            : 10;
    } PERICLKPWR0_b;
  } ;
  
  union {
    __IOM uint32_t PERICLKPWR1;                 /*!< (@ 0x0000000C) Peripheral Clock Power Control Register 1                  */
    
    struct {
      __IOM uint32_t RC24REF_IP : 1;            /*!< [0..0] RC24REF clock enable: 0=Disable, 1=Enable                          */
      __IOM uint32_t RC24CAL_IP : 1;            /*!< [1..1] RC24CAL clock enable: 0=Disable, 1=Enable                          */
      __IOM uint32_t RC32REF_IP : 1;            /*!< [2..2] RC32REF clock enable: 0=Disable, 1=Enable                          */
      __IOM uint32_t RC32CAL_IP : 1;            /*!< [3..3] RC32CAL clock enable: 0=Disable, 1=Enable                          */
      __IOM uint32_t TACHO0_IP  : 1;            /*!< [4..4] TACHO0 clock enable: 0=Disable, 1=Enable                           */
      __IOM uint32_t TACHO1_IP  : 1;            /*!< [5..5] TACHO1 clock enable: 0=Disable, 1=Enable                           */
      __IOM uint32_t TACHO2_IP  : 1;            /*!< [6..6] TACHO2 clock enable: 0=Disable, 1=Enable                           */
      __IOM uint32_t TACHO3_IP  : 1;            /*!< [7..7] TACHO3 clock enable: 0=Disable, 1=Enable                           */
      __IOM uint32_t TMR0_IP    : 1;            /*!< [8..8] TMR0 clock enable: 0=Disable, 1=Enable                             */
      __IOM uint32_t TMR1_IP    : 1;            /*!< [9..9] TMR1 clock enable: 0=Disable, 1=Enable                             */
      __IOM uint32_t TMR2_IP    : 1;            /*!< [10..10] TMR2 clock enable: 0=Disable, 1=Enable                           */
      __IOM uint32_t TMR3_IP    : 1;            /*!< [11..11] TMR3 clock enable: 0=Disable, 1=Enable                           */
      __IOM uint32_t USB_DPHY_IP : 1;           /*!< [12..12] USB_DPHY clock enable: 0=Disable, 1=Enable                       */
      __IOM uint32_t GPIO_IP    : 1;            /*!< [13..13] IO clock enable: 0=Disable, 1=Enable                             */
      __IOM uint32_t WDT_IP     : 1;            /*!< [14..14] WDT clock enable: 0=Disable, 1=Enable                            */
      __IOM uint32_t UART_IP    : 1;            /*!< [15..15] URAT clock enable: 0=Disable, 1=Enable                           */
      __IOM uint32_t ADC_IP     : 1;            /*!< [16..16] ADC clock enable: 0=Disable, 1=Enable                            */
      __IOM uint32_t CRC_IP     : 1;            /*!< [17..17] CRC clock enable: 0=Disable, 1=Enable                            */
      __IOM uint32_t MATRIX_IP  : 1;            /*!< [18..18] MATRIX clock enable: 0=Disable, 1=Enable                         */
      __IOM uint32_t EFUSE_IP   : 1;            /*!< [19..19] EFUSE clock enable: 0=Disable, 1=Enable                          */
            uint32_t            : 12;
    } PERICLKPWR1_b;
  } ;
  
  union {
    __IOM uint32_t PERICLKPWR2;                 /*!< (@ 0x00000010) Peripheral Clock Power Control Register 2                  */
    
    struct {
      __IOM uint32_t LEDPWM0_IP : 1;            /*!< [0..0] LEDPWM0 clock enable: 0=Disable, 1=Enable                          */
      __IOM uint32_t LEDPWM1_IP : 1;            /*!< [1..1] LEDPWM1 clock enable: 0=Disable, 1=Enable                          */
      __IOM uint32_t LEDPWM2_IP : 1;            /*!< [2..2] LEDPWM2 clock enable: 0=Disable, 1=Enable                          */
      __IOM uint32_t LEDPWM3_IP : 1;            /*!< [3..3] LEDPWM3 clock enable: 0=Disable, 1=Enable                          */
      __IOM uint32_t LEDPWM4_IP : 1;            /*!< [4..4] LEDPWM4 clock enable: 0=Disable, 1=Enable                          */
      __IOM uint32_t LEDPWM5_IP : 1;            /*!< [5..5] LEDPWM5 clock enable: 0=Disable, 1=Enable                          */
      __IOM uint32_t LEDPWM6_IP : 1;            /*!< [6..6] LEDPWM6 clock enable: 0=Disable, 1=Enable                          */
      __IOM uint32_t LEDPWM7_IP : 1;            /*!< [7..7] LEDPWM7 clock enable: 0=Disable, 1=Enable                          */
      __IOM uint32_t LEDPWM8_IP : 1;            /*!< [8..8] LEDPWM8 clock enable: 0=Disable, 1=Enable                          */
      __IOM uint32_t LEDPWM9_IP : 1;            /*!< [9..9] LEDPWM9 clock enable: 0=Disable, 1=Enable                          */
      __IOM uint32_t LEDPWM10_IP : 1;           /*!< [10..10] LEDPWM10 clock enable: 0=Disable, 1=Enable                       */
      __IOM uint32_t LEDPWM11_IP : 1;           /*!< [11..11] LEDPWM11 clock enable: 0=Disable, 1=Enable                       */
      __IOM uint32_t LEDPWM12_IP : 1;           /*!< [12..12] LEDPWM12 clock enable: 0=Disable, 1=Enable                       */
      __IOM uint32_t LEDPWM13_IP : 1;           /*!< [13..13] LEDPWM13 clock enable: 0=Disable, 1=Enable                       */
      __IOM uint32_t LEDPWM14_IP : 1;           /*!< [14..14] LEDPWM14 clock enable: 0=Disable, 1=Enable                       */
      __IOM uint32_t LEDPWM15_IP : 1;           /*!< [15..15] LEDPWM15 clock enable: 0=Disable, 1=Enable                       */
      __IOM uint32_t LEDPWM16_IP : 1;           /*!< [16..16] LEDPWM16 clock enable: 0=Disable, 1=Enable                       */
      __IOM uint32_t LEDPWM17_IP : 1;           /*!< [17..17] LEDPWM17 clock enable: 0=Disable, 1=Enable                       */
      __IOM uint32_t LEDPWM18_IP : 1;           /*!< [18..18] LEDPWM18 clock enable: 0=Disable, 1=Enable                       */
      __IOM uint32_t LEDPWM19_IP : 1;           /*!< [19..19] LEDPWM19 clock enable: 0=Disable, 1=Enable                       */
      __IOM uint32_t LEDPWM20_IP : 1;           /*!< [20..20] LEDPWM20 clock enable: 0=Disable, 1=Enable                       */
      __IOM uint32_t LEDPWM21_IP : 1;           /*!< [21..21] LEDPWM21 clock enable: 0=Disable, 1=Enable                       */
      __IOM uint32_t LEDPWM22_IP : 1;           /*!< [22..22] LEDPWM22 clock enable: 0=Disable, 1=Enable                       */
      __IOM uint32_t LEDPWM23_IP : 1;           /*!< [23..23] LEDPWM23 clock enable: 0=Disable, 1=Enable                       */
      __IOM uint32_t LEDPWM24_IP : 1;           /*!< [24..24] LEDPWM24 clock enable: 0=Disable, 1=Enable                       */
      __IOM uint32_t LEDPWM25_IP : 1;           /*!< [25..25] LEDPWM25 clock enable: 0=Disable, 1=Enable                       */
      __IOM uint32_t LEDPWM26_IP : 1;           /*!< [26..26] LEDPWM26 clock enable: 0=Disable, 1=Enable                       */
      __IOM uint32_t LEDPWM27_IP : 1;           /*!< [27..27] LEDPWM27 clock enable: 0=Disable, 1=Enable                       */
      __IOM uint32_t LEDPWM28_IP : 1;           /*!< [28..28] LEDPWM28 clock enable: 0=Disable, 1=Enable                       */
      __IOM uint32_t LEDPWM29_IP : 1;           /*!< [29..29] LEDPWM29 clock enable: 0=Disable, 1=Enable                       */
      __IOM uint32_t LEDPWM30_IP : 1;           /*!< [30..30] LEDPWM30 clock enable: 0=Disable, 1=Enable                       */
      __IOM uint32_t LEDPWM31_IP : 1;           /*!< [31..31] LEDPWM31 clock enable: 0=Disable, 1=Enable                       */
    } PERICLKPWR2_b;
  } ;
  
  union {
    __IOM uint32_t APBCLKPWR0;                  /*!< (@ 0x00000014) APB Clock Power Control Register 0                         */
    
    struct {
      __IOM uint32_t TACHO0_APB : 1;            /*!< [0..0] TACHO0 clock enable: 0=Disable, 1=Enable                           */
      __IOM uint32_t TACHO1_APB : 1;            /*!< [1..1] TACHO1 clock enable: 0=Disable, 1=Enable                           */
      __IOM uint32_t TACHO2_APB : 1;            /*!< [2..2] TACHO2 clock enable: 0=Disable, 1=Enable                           */
      __IOM uint32_t TACHO3_APB : 1;            /*!< [3..3] TACHO3 clock enable: 0=Disable, 1=Enable                           */
      __IOM uint32_t TMR0_APB   : 1;            /*!< [4..4] TMR0 clock enable: 0=Disable, 1=Enable                             */
      __IOM uint32_t TMR1_APB   : 1;            /*!< [5..5] TMR1 clock enable: 0=Disable, 1=Enable                             */
      __IOM uint32_t TMR2_APB   : 1;            /*!< [6..6] TMR2 clock enable: 0=Disable, 1=Enable                             */
      __IOM uint32_t TMR3_APB   : 1;            /*!< [7..7] TMR3 clock enable: 0=Disable, 1=Enable                             */
      __IOM uint32_t GPIO_APB   : 1;            /*!< [8..8] IO clock enable: 0=Disable, 1=Enable                               */
      __IOM uint32_t WDT_APB    : 1;            /*!< [9..9] WDT clock enable: 0=Disable, 1=Enable                              */
      __IOM uint32_t UART_APB   : 1;            /*!< [10..10] UART clock enable: 0=Disable, 1=Enable                           */
      __IOM uint32_t ADC_APB    : 1;            /*!< [11..11] ADC clock enable: 0=Disable, 1=Enable                            */
      __IOM uint32_t STRIP0_APB : 1;            /*!< [12..12] STRIP0 clock enable: 0=Disable, 1=Enable                         */
      __IOM uint32_t STRIP1_APB : 1;            /*!< [13..13] STRIP1 clock enable: 0=Disable, 1=Enable                         */
      __IOM uint32_t STRIP2_APB : 1;            /*!< [14..14] STRIP2 clock enable: 0=Disable, 1=Enable                         */
      __IOM uint32_t STRIP3_APB : 1;            /*!< [15..15] STRIP3 clock enable: 0=Disable, 1=Enable                         */
      __IOM uint32_t STRIP4_APB : 1;            /*!< [16..16] STRIP4 clock enable: 0=Disable, 1=Enable                         */
      __IOM uint32_t STRIP5_APB : 1;            /*!< [17..17] STRIP5 clock enable: 0=Disable, 1=Enable                         */
      __IOM uint32_t STRIP6_APB : 1;            /*!< [18..18] STRIP6 clock enable: 0=Disable, 1=Enable                         */
      __IOM uint32_t STRIP7_APB : 1;            /*!< [19..19] STRIP7 clock enable: 0=Disable, 1=Enable                         */
      __IOM uint32_t STRIP8_APB : 1;            /*!< [20..20] STRIP8 clock enable: 0=Disable, 1=Enable                         */
      __IOM uint32_t I2C0_APB   : 1;            /*!< [21..21] I2C0 clock enable: 0=Disable, 1=Enable                           */
      __IOM uint32_t I2C1_APB   : 1;            /*!< [22..22] I2C1 clock enable: 0=Disable, 1=Enable                           */
      __IOM uint32_t I2C2_APB   : 1;            /*!< [23..23] I2C2 clock enable: 0=Disable, 1=Enable                           */
      __IOM uint32_t I2CDBG_APB : 1;            /*!< [24..24] I2C Debug clock enable: 0=Disable, 1=Enable                      */
      __IOM uint32_t SPIS_APB   : 1;            /*!< [25..25] SPIS clock enable: 0=Disable, 1=Enable                           */
      __IOM uint32_t SPIM_APB   : 1;            /*!< [26..26] SPIM clock enable: 0=Disable, 1=Enable                           */
      __IOM uint32_t CRC_APB    : 1;            /*!< [27..27] CRC clock enable: 0=Disable, 1=Enable                            */
      __IOM uint32_t MATRIX_APB : 1;            /*!< [28..28] MATRIX clock enable: 0=Disable, 1=Enable                         */
      __IOM uint32_t USB_APB    : 1;            /*!< [29..29] USB clock enable: 0=Disable, 1=Enable                            */
            uint32_t            : 2;
    } APBCLKPWR0_b;
  } ;
  
  union {
    __IOM uint32_t APBCLKPWR1;                  /*!< (@ 0x00000018) APB Clock Power Control Register 1                         */
    
    struct {
      __IOM uint32_t LEDPWM0_APB : 1;           /*!< [0..0] LEDPWM0 clock enable: 0=Disable, 1=Enable                          */
      __IOM uint32_t LEDPWM1_APB : 1;           /*!< [1..1] LEDPWM1 clock enable: 0=Disable, 1=Enable                          */
      __IOM uint32_t LEDPWM2_APB : 1;           /*!< [2..2] LEDPWM2 clock enable: 0=Disable, 1=Enable                          */
      __IOM uint32_t LEDPWM3_APB : 1;           /*!< [3..3] LEDPWM3 clock enable: 0=Disable, 1=Enable                          */
      __IOM uint32_t LEDPWM4_APB : 1;           /*!< [4..4] LEDPWM4 clock enable: 0=Disable, 1=Enable                          */
      __IOM uint32_t LEDPWM5_APB : 1;           /*!< [5..5] LEDPWM5 clock enable: 0=Disable, 1=Enable                          */
      __IOM uint32_t LEDPWM6_APB : 1;           /*!< [6..6] LEDPWM6 clock enable: 0=Disable, 1=Enable                          */
      __IOM uint32_t LEDPWM7_APB : 1;           /*!< [7..7] LEDPWM7 clock enable: 0=Disable, 1=Enable                          */
      __IOM uint32_t LEDPWM8_APB : 1;           /*!< [8..8] LEDPWM8 clock enable: 0=Disable, 1=Enable                          */
      __IOM uint32_t LEDPWM9_APB : 1;           /*!< [9..9] LEDPWM9 clock enable: 0=Disable, 1=Enable                          */
      __IOM uint32_t LEDPWM10_APB : 1;          /*!< [10..10] LEDPWM10 clock enable: 0=Disable, 1=Enable                       */
      __IOM uint32_t LEDPWM11_APB : 1;          /*!< [11..11] LEDPWM11 clock enable: 0=Disable, 1=Enable                       */
      __IOM uint32_t LEDPWM12_APB : 1;          /*!< [12..12] LEDPWM12 clock enable: 0=Disable, 1=Enable                       */
      __IOM uint32_t LEDPWM13_APB : 1;          /*!< [13..13] LEDPWM13 clock enable: 0=Disable, 1=Enable                       */
      __IOM uint32_t LEDPWM14_APB : 1;          /*!< [14..14] LEDPWM14 clock enable: 0=Disable, 1=Enable                       */
      __IOM uint32_t LEDPWM15_APB : 1;          /*!< [15..15] LEDPWM15 clock enable: 0=Disable, 1=Enable                       */
      __IOM uint32_t LEDPWM16_APB : 1;          /*!< [16..16] LEDPWM16 clock enable: 0=Disable, 1=Enable                       */
      __IOM uint32_t LEDPWM17_APB : 1;          /*!< [17..17] LEDPWM17 clock enable: 0=Disable, 1=Enable                       */
      __IOM uint32_t LEDPWM18_APB : 1;          /*!< [18..18] LEDPWM18 clock enable: 0=Disable, 1=Enable                       */
      __IOM uint32_t LEDPWM19_APB : 1;          /*!< [19..19] LEDPWM19 clock enable: 0=Disable, 1=Enable                       */
      __IOM uint32_t LEDPWM20_APB : 1;          /*!< [20..20] LEDPWM20 clock enable: 0=Disable, 1=Enable                       */
      __IOM uint32_t LEDPWM21_APB : 1;          /*!< [21..21] LEDPWM21 clock enable: 0=Disable, 1=Enable                       */
      __IOM uint32_t LEDPWM22_APB : 1;          /*!< [22..22] LEDPWM22 clock enable: 0=Disable, 1=Enable                       */
      __IOM uint32_t LEDPWM23_APB : 1;          /*!< [23..23] LEDPWM23 clock enable: 0=Disable, 1=Enable                       */
      __IOM uint32_t LEDPWM24_APB : 1;          /*!< [24..24] LEDPWM24 clock enable: 0=Disable, 1=Enable                       */
      __IOM uint32_t LEDPWM25_APB : 1;          /*!< [25..25] LEDPWM25 clock enable: 0=Disable, 1=Enable                       */
      __IOM uint32_t LEDPWM26_APB : 1;          /*!< [26..26] LEDPWM26 clock enable: 0=Disable, 1=Enable                       */
      __IOM uint32_t LEDPWM27_APB : 1;          /*!< [27..27] LEDPWM27 clock enable: 0=Disable, 1=Enable                       */
      __IOM uint32_t LEDPWM28_APB : 1;          /*!< [28..28] LEDPWM28 clock enable: 0=Disable, 1=Enable                       */
      __IOM uint32_t LEDPWM29_APB : 1;          /*!< [29..29] LEDPWM29 clock enable: 0=Disable, 1=Enable                       */
      __IOM uint32_t LEDPWM30_APB : 1;          /*!< [30..30] LEDPWM30 clock enable: 0=Disable, 1=Enable                       */
      __IOM uint32_t LEDPWM31_APB : 1;          /*!< [31..31] LEDPWM31 clock enable: 0=Disable, 1=Enable                       */
    } APBCLKPWR1_b;
  } ;
  
  union {
    __IOM uint32_t PERICLKSEL1;                 /*!< (@ 0x0000001C) Clock Source Select for CTS1 IP                            */
    
    struct {
      __IOM uint32_t sel_clk_spi_s_ip_0 : 2;    /*!< [1..0] SPI Slave IP 0 Clock Source Select                                 */
      __IOM uint32_t sel_clk_spi_s_ip_0_async_bus : 1;/*!< [2..2] SPI Slave IP 0 Async Bus Clock Source Select                 */
            uint32_t            : 1;
      __IOM uint32_t sel_clk_spi_m_ip_0 : 2;    /*!< [5..4] SPI Master IP 0 Clock Source Select                                */
      __IOM uint32_t sel_clk_spi_m_ip_0_async_bus : 1;/*!< [6..6] SPI Master IP 0 Async Bus Clock Source Select                */
            uint32_t            : 1;
      __IOM uint32_t sel_clk_i2c_ip_0 : 2;      /*!< [9..8] I2C IP 0 Clock Source Select                                       */
      __IOM uint32_t sel_clk_i2c_ip_0_async_bus : 1;/*!< [10..10] I2C IP 0 Async Bus Clock Source Select                       */
            uint32_t            : 1;
      __IOM uint32_t sel_clk_i2c_ip_1 : 2;      /*!< [13..12] I2C IP 1 Clock Source Select                                     */
      __IOM uint32_t sel_clk_i2c_ip_1_async_bus : 1;/*!< [14..14] I2C IP 1 Async Bus Clock Source Select                       */
            uint32_t            : 1;
      __IOM uint32_t sel_clk_i2c_ip_2 : 2;      /*!< [17..16] I2C IP 2 Clock Source Select                                     */
      __IOM uint32_t sel_clk_i2c_ip_2_async_bus : 1;/*!< [18..18] I2C IP 2 Async Bus Clock Source Select                       */
            uint32_t            : 1;
      __IOM uint32_t sel_clk_i2c_dbg : 2;       /*!< [21..20] I2C Debug Clock Source Select                                    */
      __IOM uint32_t sel_clk_i2c_dbg_async_bus : 1;/*!< [22..22] I2C Debug Async Bus Clock Source Select                       */
            uint32_t            : 1;
      __IOM uint32_t sel_clk_dot_matrix_led_ip : 2;/*!< [25..24] Dot Matrix LED IP Clock Source Select                         */
      __IOM uint32_t sel_clk_dot_matrix_led_async_bus : 1;/*!< [26..26] Dot Matrix LED Async Bus Clock Source Select           */
            uint32_t            : 1;
      __IOM uint32_t sel_clk_adc_ctrl : 2;      /*!< [29..28] ADC Control Clock Source Select                                  */
      __IOM uint32_t ADC_APB_SRC : 1;           /*!< [30..30] ADC Async Bus Clock Source Select                                */
            uint32_t            : 1;
    } PERICLKSEL1_b;
  } ;
  
  union {
    __IOM uint32_t PERICLKSEL2;                 /*!< (@ 0x00000020) Peripheral Clock Select Register 2                         */
    
    struct {
      __IOM uint32_t sel_clk_cpu : 1;           /*!< [0..0] CPU Clock Source Select                                            */
      __IOM uint32_t sel_clk_dma : 1;           /*!< [1..1] DMA Clock Source Select                                            */
      __IOM uint32_t sel_clk_spic_intr : 1;     /*!< [2..2] SPIC INTR Clock Source Select                                      */
      __IOM uint32_t sel_clk_spic_extr : 1;     /*!< [3..3] SPIC EXTR Clock Source Select                                      */
      __IOM uint32_t sel_clk_swd : 2;           /*!< [5..4] SWD Clock Source Select                                            */
      __IOM uint32_t sel_clk_i3c_ip : 2;        /*!< [7..6] I3C IP Clock Source Select                                         */
      __IOM uint32_t sel_clk_usb_dphy_ip : 1;   /*!< [8..8] USB DPHY IP Clock Source Select                                    */
      __IOM uint32_t sel_clk_wdt_async_bus : 1; /*!< [9..9] WDT Async Bus Clock Source Select                                  */
      __IOM uint32_t sel_clk_gpio_async_bus : 1;/*!< [10..10] GPIO Async Bus Clock Source Select                               */
      __IOM uint32_t sel_clk_efuse : 1;         /*!< [11..11] eFuse Clock Source Select                                        */
      __IOM uint32_t sel_clk_tach_ip_0_async_bus : 1;/*!< [12..12] TACH IP 0 Async Bus Clock Source Select                     */
      __IOM uint32_t sel_clk_tach_ip_1_async_bus : 1;/*!< [13..13] TACH IP 1 Async Bus Clock Source Select                     */
      __IOM uint32_t sel_clk_tach_ip_2_async_bus : 1;/*!< [14..14] TACH IP 2 Async Bus Clock Source Select                     */
      __IOM uint32_t sel_clk_tach_ip_3_async_bus : 1;/*!< [15..15] TACH IP 3 Async Bus Clock Source Select                     */
      __IOM uint32_t sel_clk_tach_ip_0 : 1;     /*!< [16..16] TACH IP 0 Clock Source Select                                    */
      __IOM uint32_t sel_clk_tach_ip_1 : 1;     /*!< [17..17] TACH IP 1 Clock Source Select                                    */
      __IOM uint32_t sel_clk_tach_ip_2 : 1;     /*!< [18..18] TACH IP 2 Clock Source Select                                    */
      __IOM uint32_t sel_clk_tach_ip_3 : 1;     /*!< [19..19] TACH IP 3 Clock Source Select                                    */
      __IOM uint32_t sel_clk_turbo_mem_comp_ip : 2;/*!< [21..20] Turbo Memory Comparator IP Clock Source Select                */
      __IOM uint32_t sel_clk_turbo_mem_comp_async_bus : 1;/*!< [22..22] Turbo Memory Comparator Async Bus Clock Source Select  */
            uint32_t            : 1;
      __IOM uint32_t sel_clk_tmr_ip_0 : 2;      /*!< [25..24] Timer IP 0 Clock Source Select                                   */
      __IOM uint32_t sel_clk_tmr_ip_0_async_bus : 1;/*!< [26..26] Timer IP 0 Async Bus Clock Source Select                     */
            uint32_t            : 1;
      __IOM uint32_t sel_clk_tmr_ip_1 : 2;      /*!< [29..28] Timer IP 1 Clock Source Select                                   */
      __IOM uint32_t sel_clk_tmr_ip_1_async_bus : 1;/*!< [30..30] Timer IP 1 Async Bus Clock Source Select                     */
            uint32_t            : 1;
    } PERICLKSEL2_b;
  } ;
  __IOM uint32_t  APBCLKPWR2;                   /*!< (@ 0x00000024) APB CLOCK POWER REGISTER #2                                */
  __IOM uint32_t  PERICLKCTRL3;                 /*!< (@ 0x00000028) PERIPHERAL CLOCK CONTROL REGISTER #3                       */
  __IOM uint32_t  PERICLKCTRL4;                 /*!< (@ 0x0000002C) PERIPHERAL CLOCK CONTROL REGISTER #4                       */
  __IOM uint32_t  PERIRST0;                     /*!< (@ 0x00000030) PERIPHERAL RESET CONTROL REGISTER #0                       */
  __IOM uint32_t  PERIRST1;                     /*!< (@ 0x00000034) PERIPHERAL RESET CONTROL REGISTER #1                       */
  __IOM uint32_t  PERIRST2;                     /*!< (@ 0x00000038) PERIPHERAL RESET CONTROL REGISTER #2                       */
  __IOM uint32_t  PERIRST3;                     /*!< (@ 0x0000003C) PERIPHERAL RESET CONTROL REGISTER #3                       */
  __IOM uint32_t  PERIRST4;                     /*!< (@ 0x00000040) PERIPHERAL RESET CONTROL REGISTER #4                       */
  __IOM uint32_t  PERIRST5;                     /*!< (@ 0x00000044) PERIPHERAL RESET CONTROL REGISTER #5                       */
  __IOM uint32_t  PERIRST6;                     /*!< (@ 0x00000048) PERIPHERAL RESET CONTROL REGISTER #6                       */
  __IOM uint32_t  PERIRST7;                     /*!< (@ 0x0000004C) PERIPHERAL RESET CONTROL REGISTER #7                       */
  __IOM uint32_t  PERIRST8;                     /*!< (@ 0x00000050) PERIPHERAL RESET CONTROL REGISTER #8                       */
  __IOM uint32_t  CPUINITADDR0;                 /*!< (@ 0x00000054) CPU INITIAL ADDRESS REGISTER #0                            */
  __IOM uint32_t  CPUINITADDR1;                 /*!< (@ 0x00000058) CPU INITIAL ADDRESS REGISTER #1                            */
  __IOM uint32_t  SLEEPCTRL;                    /*!< (@ 0x0000005C) SLEEP CONTROL REGISTER                                     */
  __IOM uint32_t  ADCCLKCTRL;                   /*!< (@ 0x00000060) ADC CLOCK CONTROL REGISTER                                 */
  __IOM uint32_t  USBCTRL;                      /*!< (@ 0x00000064) FPGA USB CONTROL REGISTER                                  */
} SYSTEM_Type;                                  /*!< Size = 104 (0x68)                                                         */



/* =========================================================================================================================== */
/* ================                                           RCCAL                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief RC Calibration Controller (RCCAL)
  */

typedef struct {                                /*!< (@ 0x40100100) RCCAL Structure                                            */
  __IOM uint32_t  CTRLR0;                       /*!< (@ 0x00000000) Control Register 0                                         */
  __IOM uint32_t  RC25RESULT;                   /*!< (@ 0x00000004) RC25M Result Register                                      */
  __IOM uint32_t  RC32RESULT;                   /*!< (@ 0x00000008) RC32K Result Register                                      */
  __IOM uint32_t  RCDIFF;                       /*!< (@ 0x0000000C) RC25M/RC32K Diff Register                                  */
  __IOM uint32_t  RC25CTRL;                     /*!< (@ 0x00000010) RC25M Analog Control Register                              */
  __IOM uint32_t  RC32CTRL;                     /*!< (@ 0x00000014) RC32K Analog Control Register                              */
} RCCAL_Type;                                   /*!< Size = 24 (0x18)                                                          */



/* =========================================================================================================================== */
/* ================                                           SPIM                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief SPI Master Controller (SPIM)
  */

typedef struct {                                /*!< (@ 0x40100300) SPIM Structure                                             */
  
  union {
    __IOM uint32_t CTRLR0;                      /*!< (@ 0x00000000) Control Register 0                                         */
    
    struct {
      __IOM uint32_t DFS        : 4;            /*!< [3..0] Data Frame Size. Determines the size of the data transfer
                                                     in serial frames.                                                         */
            uint32_t            : 2;
      __IOM uint32_t SCPH       : 1;            /*!< [6..6] Serial Clock Phase. Determines the capture edge of the
                                                     serial clock in relation to the slave select signal.                      */
      __IOM uint32_t SCP        : 1;            /*!< [7..7] Used to select the polarity of the inactive serial clock.          */
      __IOM uint32_t TM         : 2;            /*!< [9..8] Transmit Mode                                                      */
      __IOM uint32_t SLV_OE     : 1;            /*!< [10..10] Slave Output Enable                                              */
      __IOM uint32_t SRL        : 1;            /*!< [11..11] Shift Register Loop                                              */
      __IOM uint32_t CFS        : 4;            /*!< [15..12] Control Frame Size                                               */
      __IOM uint32_t DFS_32     : 5;            /*!< [20..16] Varies Data Frame Size up to 32 bits.                            */
      __IOM uint32_t SPI_FRF    : 2;            /*!< [22..21] Selects the serial protocol frame format. Valid when
                                                     the frame format is set to Motorola SPI.                                  */
            uint32_t            : 9;
    } CTRLR0_b;
  } ;
  
  union {
    __IOM uint32_t CTRLR1;                      /*!< (@ 0x00000004) Control Register 1                                         */
    
    struct {
      __IOM uint32_t NDF        : 16;           /*!< [15..0] Number of Data Frames. Represents the total number of
                                                     data frames for the transaction.                                          */
            uint32_t            : 16;
    } CTRLR1_b;
  } ;
  
  union {
    __IOM uint32_t SSIENR;                      /*!< (@ 0x00000008) SSI Enable Register                                        */
    
    struct {
      __IOM uint32_t SSI_EN     : 1;            /*!< [0..0] SSI Enable.                                                        */
            uint32_t            : 31;
    } SSIENR_b;
  } ;
  
  union {
    __IOM uint32_t MWCR;                        /*!< (@ 0x0000000C) Microwire Control Register                                 */
    
    struct {
      __IOM uint32_t MWMOD      : 1;            /*!< [0..0] Microwire Transfer Mode. Configures the transfer mode
                                                     of the Microwire.                                                         */
      __IOM uint32_t MDD        : 1;            /*!< [1..1] Microwire Control. Specifies the direction of data flow
                                                     for SSI.                                                                  */
      __IOM uint32_t MHS        : 1;            /*!< [2..2] Microwire Handshaking. Controls the handshaking interface
                                                     of the Microwire.                                                         */
            uint32_t            : 29;
    } MWCR_b;
  } ;
  __IOM uint32_t  SER;                          /*!< (@ 0x00000010) Slave Enable Register                                      */
  
  union {
    __IOM uint32_t BAUDR;                       /*!< (@ 0x00000014) Baud Rate Register                                         */
    
    struct {
      __IOM uint32_t SCKDV      : 16;           /*!< [15..0] SSI Clock Divider. Determines the output serial clock
                                                     frequency.  The formula for the output clock: Fsclk_out
                                                     = Fssi_clk / SCKDV.                                                       */
            uint32_t            : 16;
    } BAUDR_b;
  } ;
  __IOM uint32_t  TXFTLR;                       /*!< (@ 0x00000018) Transmit FIFO Threshold Level Register                     */
  __IOM uint32_t  RXFTLR;                       /*!< (@ 0x0000001C) Receive FIFO Threshold Level Register                      */
  __IM  uint32_t  TXFLR;                        /*!< (@ 0x00000020) Transmit FIFO Level Register                               */
  __IM  uint32_t  RXFLR;                        /*!< (@ 0x00000024) Receive FIFO Level Register                                */
  
  union {
    __IM  uint32_t SR;                          /*!< (@ 0x00000028) Status Register                                            */
    
    struct {
      __IM  uint32_t BUSY       : 1;            /*!< [0..0] SSI Busy Flag. Indicates if the SSI is actively transferring
                                                     data.                                                                     */
      __IM  uint32_t TFNF       : 1;            /*!< [1..1] Transmit FIFO Not Full. Indicates if the transmit FIFO
                                                     is not full.                                                              */
      __IM  uint32_t TFE        : 1;            /*!< [2..2] Transmit FIFO Empty. Indicates if the transmit FIFO is
                                                     empty.                                                                    */
      __IM  uint32_t RFNE       : 1;            /*!< [3..3] Receive FIFO Not Empty. Indicates if the receive FIFO
                                                     contains data.                                                            */
      __IM  uint32_t RFF        : 1;            /*!< [4..4] Receive FIFO Full. Indicates the status of the receive
                                                     FIFO.                                                                     */
      __IM  uint32_t TXE        : 1;            /*!< [5..5] Transmission Error. Indicates an error occurred during
                                                     transmission.                                                             */
      __IM  uint32_t DCOL       : 1;            /*!< [6..6] Data Collision Error. Indicates a collision occurred
                                                     during transmission.                                                      */
            uint32_t            : 25;
    } SR_b;
  } ;
  
  union {
    __IOM uint32_t IMR;                         /*!< (@ 0x0000002C) Interrupt Mask Register                                    */
    
    struct {
      __IOM uint32_t TXEIM      : 1;            /*!< [0..0] Transmit FIFO Empty Interrupt Mask. Controls the masking
                                                     of the ssi_txe_intr interrupt.                                            */
      __IOM uint32_t TXOIM      : 1;            /*!< [1..1] Transmit FIFO Overflow Interrupt Mask. Controls the masking
                                                     of the ssi_txo_intr interrupt.                                            */
      __IOM uint32_t RXUIM      : 1;            /*!< [2..2] Receive FIFO Underflow Interrupt Mask. Controls the masking
                                                     of the ssi_rxu_intr interrupt.                                            */
      __IOM uint32_t RXOIM      : 1;            /*!< [3..3] Receive FIFO Overflow Interrupt Mask. Controls the masking
                                                     of the ssi_rxo_intr interrupt.                                            */
      __IOM uint32_t RXFIM      : 1;            /*!< [4..4] Receive FIFO Full Interrupt Mask. Controls the masking
                                                     of the ssi_rxf_intr interrupt.                                            */
      __IOM uint32_t MSTIM      : 1;            /*!< [5..5] Multi-Master Contention Interrupt Mask. Controls the
                                                     masking of the ssi_mst_intr interrupt.                                    */
            uint32_t            : 26;
    } IMR_b;
  } ;
  
  union {
    __IM  uint32_t ISR;                         /*!< (@ 0x00000030) Interrupt Status Register                                  */
    
    struct {
      __IM  uint32_t TXEIS      : 1;            /*!< [0..0] Transmit FIFO Empty Interrupt Status. Indicates the status
                                                     of the ssi_txe_intr interrupt after masking.                              */
      __IM  uint32_t TXOIS      : 1;            /*!< [1..1] Transmit FIFO Overflow Interrupt Status. Indicates the
                                                     status of the ssi_txo_intr interrupt after masking.                       */
      __IM  uint32_t RXUIS      : 1;            /*!< [2..2] Receive FIFO Underflow Interrupt Status. Indicates the
                                                     status of the ssi_rxu_intr interrupt after masking.                       */
      __IM  uint32_t RXOIS      : 1;            /*!< [3..3] Receive FIFO Overflow Interrupt Status. Indicates the
                                                     status of the ssi_rxo_intr interrupt after masking.                       */
      __IM  uint32_t RXFIS      : 1;            /*!< [4..4] Receive FIFO Full Interrupt Status. Indicates the status
                                                     of the ssi_rxf_intr interrupt after masking.                              */
      __IM  uint32_t MSTIS      : 1;            /*!< [5..5] Multi-Master Contention Interrupt Status. Indicates the
                                                     status of the ssi_mst_intr interrupt after masking.                       */
            uint32_t            : 26;
    } ISR_b;
  } ;
  
  union {
    __IM  uint32_t RISR;                        /*!< (@ 0x00000034) Raw Interrupt Status Register                              */
    
    struct {
      __IM  uint32_t TXEIR      : 1;            /*!< [0..0] Transmit FIFO Empty Raw Interrupt Status. Indicates the
                                                     status of the ssi_txe_intr interrupt prior to masking.                    */
      __IM  uint32_t TXOIR      : 1;            /*!< [1..1] Transmit FIFO Overflow Raw Interrupt Status. Indicates
                                                     the status of the ssi_txo_intr interrupt prior to masking.                */
      __IM  uint32_t RXUIR      : 1;            /*!< [2..2] Receive FIFO Underflow Raw Interrupt Status. Indicates
                                                     the status of the ssi_rxu_intr interrupt prior to masking.                */
      __IM  uint32_t RXOIR      : 1;            /*!< [3..3] Receive FIFO Overflow Raw Interrupt Status. Indicates
                                                     the status of the ssi_rxo_intr interrupt prior to masking.                */
      __IM  uint32_t RXFIR      : 1;            /*!< [4..4] Receive FIFO Full Raw Interrupt Status. Indicates the
                                                     status of the ssi_rxf_intr interrupt prior to masking.                    */
      __IM  uint32_t MSTIR      : 1;            /*!< [5..5] Multi-Master Contention Raw Interrupt Status. Indicates
                                                     the status of the ssi_mst_intr interrupt prior to masking.                */
            uint32_t            : 26;
    } RISR_b;
  } ;
  __OM  uint32_t  TXOICR;                       /*!< (@ 0x00000038) Transmit FIFO Overflow Interrupt Clear Register            */
  __OM  uint32_t  RXOICR;                       /*!< (@ 0x0000003C) Receive FIFO Overflow Interrupt Clear Register             */
  __OM  uint32_t  RXUICR;                       /*!< (@ 0x00000040) Receive FIFO Underflow Interrupt Clear Register            */
  __OM  uint32_t  MSTICR;                       /*!< (@ 0x00000044) Multi-Master Interrupt Clear Register                      */
  __OM  uint32_t  ICR;                          /*!< (@ 0x00000048) Interrupt Clear Register                                   */
  
  union {
    __IOM uint32_t DMACR;                       /*!< (@ 0x0000004C) DMA Control Register                                       */
    
    struct {
      __IOM uint32_t RDMAE      : 1;            /*!< [0..0] Receive DMA Enable. Controls the enable status of the
                                                     receive DMA operation.                                                    */
      __IOM uint32_t TDMAE      : 1;            /*!< [1..1] Transmit DMA Enable. Controls the enable status of the
                                                     transmit DMA operation.                                                   */
            uint32_t            : 30;
    } DMACR_b;
  } ;
  __IOM uint32_t  DMATDLR;                      /*!< (@ 0x00000050) DMA Transmit Data Level Register                           */
  __IOM uint32_t  DMARDLR;                      /*!< (@ 0x00000054) DMA Receive Data Level Register                            */
  __IM  uint32_t  IDR;                          /*!< (@ 0x00000058) Identification Register                                    */
  __IM  uint32_t  SSI_VERSION_ID;               /*!< (@ 0x0000005C) SSI Version ID Register                                    */
  __IOM uint32_t  DR;                           /*!< (@ 0x00000060) Data Register                                              */
  __IM  uint32_t  RESERVED[35];
  __IOM uint32_t  RX_SAMPLE_DLY;                /*!< (@ 0x000000F0) Receive Sample Delay Register                              */
  
  union {
    __IOM uint32_t SPI_CTRLR0;                  /*!< (@ 0x000000F4) SPI Control Register                                       */
    
    struct {
      __IOM uint32_t TRANS_TYPE : 2;            /*!< [1..0] Address and instruction transfer format.                           */
      __IOM uint32_t ADDR_L     : 4;            /*!< [5..2] Address Length.                                                    */
            uint32_t            : 2;
      __IOM uint32_t INST_L     : 2;            /*!< [9..8] Instruction Length.                                                */
            uint32_t            : 1;
      __IOM uint32_t WAIT_CYCLES : 5;           /*!< [15..11] Wait cycles.                                                     */
      __IOM uint32_t SPI_DDR_EN : 1;            /*!< [16..16] SPI DDR Enable bit.                                              */
      __IOM uint32_t INST_DDR_EN : 1;           /*!< [17..17] Instruction DDR Enable bit.                                      */
      __IOM uint32_t SPI_RXDS_EN : 1;           /*!< [18..18] Read data strobe enable bit.                                     */
            uint32_t            : 13;
    } SPI_CTRLR0_b;
  } ;
  __IOM uint32_t  TXD_DRIVE_EDGE;               /*!< (@ 0x000000F8) Transmit Drive Edge Register                               */
} DW_SPI_Type;                                  /*!< Size = 252 (0xfc)                                                         */



/* =========================================================================================================================== */
/* ================                                           UART                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief UART Controller (UART)
  */

typedef struct {                                /*!< (@ 0x40100700) UART Structure                                             */
  
  union {
    __IM  uint32_t RBR;                         /*!< (@ 0x00000000) RECEIVE BUFFER REGISTER                                    */
    __IOM uint32_t THR;                         /*!< (@ 0x00000000) TRANSMIT HOLDING REGISTER                                  */
    __IOM uint32_t DLL;                         /*!< (@ 0x00000000) DIVISOR LATCH LOW REGISTER                                 */
  };
  
  union {
    __IOM uint32_t DLH;                         /*!< (@ 0x00000004) DIVISOR LATCH HIGH REGISTER                                */
    
    union {
      __IOM uint32_t IER;                       /*!< (@ 0x00000004) INTRRRUPT ENABLE REGISTER                                  */
      
      struct {
        __IOM uint32_t ERBFI    : 1;            /*!< [0..0] Enable Received Data Available Interrupt                           */
        __IOM uint32_t ETBEI    : 1;            /*!< [1..1] Enable Transmit Holding Register Empty Interrupt                   */
        __IOM uint32_t ELSI     : 1;            /*!< [2..2] Enable Receiver Line Status Interrupt                              */
        __IOM uint32_t EDSSI    : 1;            /*!< [3..3] Enable Modem Status Interrupt                                      */
              uint32_t          : 3;
        __IOM uint32_t PTIME    : 1;            /*!< [7..7] Programmable THRE Interrupt Mode Enable                            */
              uint32_t          : 24;
      } IER_b;
    } ;
  };
  
  union {
    union {
      __IM  uint32_t IIR;                       /*!< (@ 0x00000008) INTERRUPT IDENTIFICATION                                   */
      
      struct {
        __IM  uint32_t IID      : 4;            /*!< [3..0] Interrupt ID                                                       */
              uint32_t          : 2;
        __IM  uint32_t FIFOSE   : 2;            /*!< [7..6] FIFOs Enabled                                                      */
              uint32_t          : 24;
      } IIR_b;
    } ;
    
    union {
      __IOM uint32_t FCR;                       /*!< (@ 0x00000008) FIFO CONTROL REGISTER                                      */
      
      struct {
        __IOM uint32_t FIFOE    : 1;            /*!< [0..0] FIFO Enabled                                                       */
        __IOM uint32_t RFIFOR   : 1;            /*!< [1..1] Rx FIFO Reset                                                      */
        __IOM uint32_t XFIFOR   : 1;            /*!< [2..2] Tx FIFO Reset                                                      */
        __IOM uint32_t DMAM     : 1;            /*!< [3..3] DMA Mode                                                           */
        __IOM uint32_t TET      : 2;            /*!< [5..4] TX Empty Trigger Level                                             */
        __IOM uint32_t RCVR     : 2;            /*!< [7..6] Rx Trigger Level                                                   */
              uint32_t          : 24;
      } FCR_b;
    } ;
  };
  
  union {
    __IOM uint32_t LCR;                         /*!< (@ 0x0000000C) LINE CONTROL REGISTER                                      */
    
    struct {
      __IOM uint32_t DLS        : 2;            /*!< [1..0] Data Length Select                                                 */
      __IOM uint32_t STOP       : 1;            /*!< [2..2] Number of Stop Bits                                                */
      __IOM uint32_t PEN        : 1;            /*!< [3..3] Parity Enable                                                      */
      __IOM uint32_t EPS        : 1;            /*!< [4..4] Even Parity Select                                                 */
      __IOM uint32_t STP        : 1;            /*!< [5..5] Stick Parity                                                       */
      __IOM uint32_t BC         : 1;            /*!< [6..6] Break Control Bit                                                  */
      __IOM uint32_t DLAB       : 1;            /*!< [7..7] Divisor Latch Access Bit                                           */
            uint32_t            : 24;
    } LCR_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IM  uint32_t LSR;                         /*!< (@ 0x00000014) LINE STATUS REGISTER                                       */
    
    struct {
      __IM  uint32_t DR         : 1;            /*!< [0..0] Data Ready Bit                                                     */
      __IM  uint32_t OE         : 1;            /*!< [1..1] Overrun Error bit                                                  */
      __IM  uint32_t PE         : 1;            /*!< [2..2] Parity Error bit                                                   */
      __IM  uint32_t FE         : 1;            /*!< [3..3] Framing Error bit                                                  */
      __IM  uint32_t BI         : 1;            /*!< [4..4] Break Interrupt bit                                                */
      __IM  uint32_t THRE       : 1;            /*!< [5..5] Transmit Holding Register Empty bit                                */
      __IM  uint32_t TEMT       : 1;            /*!< [6..6] Transmitter Empty Bit                                              */
      __IM  uint32_t RFE        : 1;            /*!< [7..7] Receiver FIFO Error                                                */
            uint32_t            : 24;
    } LSR_b;
  } ;
  __IM  uint32_t  RESERVED1[25];
  
  union {
    __IM  uint32_t USR;                         /*!< (@ 0x0000007C) UART Status Register                                       */
    
    struct {
      __IM  uint32_t BUSY       : 1;            /*!< [0..0] UART Busy                                                          */
      __IM  uint32_t TFNF       : 1;            /*!< [1..1] Transmit FIFO Not Full                                             */
      __IM  uint32_t TFE        : 1;            /*!< [2..2] Transmit FIFO Empty                                                */
      __IM  uint32_t RFNE       : 1;            /*!< [3..3] Receive FIFO Not Empty                                             */
      __IM  uint32_t RFF        : 1;            /*!< [4..4] Receive FIFO Full                                                  */
            uint32_t            : 27;
    } USR_b;
  } ;
  __IM  uint32_t  TFL;                          /*!< (@ 0x00000080) UART TRANSMIT FIFO LEVEL                                   */
  __IM  uint32_t  RFL;                          /*!< (@ 0x00000084) UART RECEIVE FIFO LEVEL                                    */
  
  union {
    __OM  uint32_t SRR;                         /*!< (@ 0x00000088) UART SOFTWARE RESET REGISTER                               */
    
    struct {
      __OM  uint32_t UR         : 1;            /*!< [0..0] UART Reset                                                         */
      __OM  uint32_t RFR        : 1;            /*!< [1..1] RCVR FIFO Reset                                                    */
      __OM  uint32_t XFR        : 1;            /*!< [2..2] XMIT FIFO Reset                                                    */
            uint32_t            : 29;
    } SRR_b;
  } ;
} DW_UART_Type;                                 /*!< Size = 140 (0x8c)                                                         */



/* =========================================================================================================================== */
/* ================                                          TACHO0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Tachometer Controller (TACHO0)
  */

typedef struct {                                /*!< (@ 0x40100900) TACHO0 Structure                                           */
  
  union {
    __IOM uint32_t CTRL;                        /*!< (@ 0x00000000) CONTROL REGISTER                                           */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Enable Tachometer Controller                                       */
      __IOM uint32_t FILTEREN   : 1;            /*!< [1..1] Enable Filter of Tachometer                                        */
      __IOM uint32_t SELEDGE    : 2;            /*!< [3..2] Select Edges of Tachometer                                         */
      __IOM uint32_t READMODE   : 1;            /*!< [4..4] Select Reading Mode of Tachometer                                  */
            uint32_t            : 11;
      __IM  uint32_t CNT        : 16;           /*!< [31..16] Counter of Tachometer                                            */
    } CTRL_b;
  } ;
  
  union {
    __IOM uint32_t STS;                         /*!< (@ 0x00000004) STATUS REGISTER                                            */
    
    struct {
      __IOM uint32_t LIMIT      : 1;            /*!< [0..0] Limit status of Tachometer                                         */
      __IM  uint32_t PIN        : 1;            /*!< [1..1] Pin Status of Tachometer                                           */
      __IOM uint32_t CHG        : 1;            /*!< [2..2] Tachometer Input Changes Its Status                                */
      __IOM uint32_t CNTRDY     : 1;            /*!< [3..3] Status of Count Ready                                              */
      __IOM uint32_t FAIL       : 1;            /*!< [4..4] Status of Count Ready                                              */
            uint32_t            : 27;
    } STS_b;
  } ;
  
  union {
    __IOM uint32_t LIMITH;                      /*!< (@ 0x00000008) HIGH-LIMIT REGISTER                                        */
    
    struct {
      __IOM uint32_t VAL        : 16;           /*!< [15..0] High limit value                                                  */
            uint32_t            : 16;
    } LIMITH_b;
  } ;
  
  union {
    __IOM uint32_t LIMITL;                      /*!< (@ 0x0000000C) LOW-LIMIT REGISTER                                         */
    
    struct {
      __IOM uint32_t VAL        : 16;           /*!< [15..0] Low limit value                                                   */
            uint32_t            : 16;
    } LIMITL_b;
  } ;
  
  union {
    __IOM uint32_t INTEN;                       /*!< (@ 0x00000010) INTERRUPT ENABLE REGISTER                                  */
    
    struct {
      __IOM uint32_t LIMITEN    : 1;            /*!< [0..0] Limit Interrupt Enable                                             */
      __IOM uint32_t CNTRDYEN   : 1;            /*!< [1..1] Ready to count Interrupt Enable                                    */
      __IOM uint32_t CHGEN      : 1;            /*!< [2..2] Input Change Interrupt Enable                                      */
      __IOM uint32_t FAILEN     : 1;            /*!< [3..3] Fail Interrupt Enable                                              */
            uint32_t            : 28;
    } INTEN_b;
  } ;
  __IOM uint32_t  THRESHOLD;                    /*!< (@ 0x00000014) THRESHOLD REGISTER                                         */
  __IOM uint32_t  TIMEOUT;                      /*!< (@ 0x00000018) TIMEOUT REGISTER                                           */
} TACHO_Type;                                   /*!< Size = 28 (0x1c)                                                          */



/* =========================================================================================================================== */
/* ================                                            WDT                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief WDT Controller (WDT)
  */

typedef struct {                                /*!< (@ 0x40100980) WDT Structure                                              */
  
  union {
    __IOM uint32_t CTRL;                        /*!< (@ 0x00000000) CONTROL REGISTER                                           */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Enable WDT                                                         */
      __IOM uint32_t RSTEN      : 1;            /*!< [1..1] Enable WDT to Reset System                                         */
      __IOM uint32_t RELOAD     : 1;            /*!< [2..2] Reload WDT Counter                                                 */
      __IOM uint32_t CLRRSTFLAG : 1;            /*!< [3..3] Clear WDT reset flag                                               */
            uint32_t            : 28;
    } CTRL_b;
  } ;
  
  union {
    __IM  uint32_t STS;                         /*!< (@ 0x00000004) STATUS REGISTER                                            */
    
    struct {
      __IM  uint32_t RSTFLAG    : 1;            /*!< [0..0] Reset Flag                                                         */
            uint32_t            : 31;
    } STS_b;
  } ;
  __IOM uint32_t  CNT;                          /*!< (@ 0x00000008) INITIAL COUNTER REGISTER                                   */
  __IOM uint32_t  DIV;                          /*!< (@ 0x0000000C) DIVIDER REGISTER                                           */
  
  union {
    __IOM uint32_t INTEN;                       /*!< (@ 0x00000010) INTERRUPT ENABLE REGISTER                                  */
    
    struct {
      __IOM uint32_t WDTINTEN   : 1;            /*!< [0..0] Enable WDT Interrupt                                               */
            uint32_t            : 31;
    } INTEN_b;
  } ;
} WDT_Type;                                     /*!< Size = 20 (0x14)                                                          */



/* =========================================================================================================================== */
/* ================                                           I2C0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief DW I2C Controller (I2C0)
  */

typedef struct {                                /*!< (@ 0x40101000) I2C0 Structure                                             */
  
  union {
    __IOM uint32_t CON;                         /*!< (@ 0x00000000) CONTROL REGISTER                                           */
    
    struct {
      __IOM uint32_t MATSER     : 1;            /*!< [0..0] Enable/Disable Master Mode                                         */
      __IOM uint32_t SPEED      : 2;            /*!< [2..1] Speed Mode                                                         */
      __IOM uint32_t SLV10BIT   : 1;            /*!< [3..3] Slave Responds To 7-bit Or 10-bit Addresses                        */
      __IOM uint32_t MST10BIT   : 1;            /*!< [4..4] Master Is 7-bit Or 10-bit Addressing Mode                          */
      __IOM uint32_t RESTREN    : 1;            /*!< [5..5] Enable/Disable Master Restart                                      */
      __IOM uint32_t SLVDISABLE : 1;            /*!< [6..6] Enable/Disable Slave Mode                                          */
      __IOM uint32_t STPDET     : 1;            /*!< [7..7] How Slave Issues Stop Detection Interrupt                          */
      __IOM uint32_t TXEMPTYCTRL : 1;           /*!< [8..8] Controls the Generation Of The Tx Empty Interrupt                  */
      __IOM uint32_t RXFULLHLDC : 1;            /*!< [9..9] Hold the Bus When The Rx FIFO Is Full Or Not                       */
      __IOM uint32_t STPMSTACTIVE : 1;          /*!< [10..10] How I2c Controller Issues The Stop Detection Interrupt           */
      __IOM uint32_t BUSCLREN   : 1;            /*!< [11..11] Enables the Bus Clear Feature                                    */
            uint32_t            : 20;
    } CON_b;
  } ;
  
  union {
    __IOM uint32_t TAR;                         /*!< (@ 0x00000004) TARGET ADDRESS REGISTER                                    */
    
    struct {
      __IOM uint32_t TAR        : 10;           /*!< [9..0] Target Address For Any Master Transaction                          */
      __IOM uint32_t GCORSTR    : 1;            /*!< [10..10] Indicates Whether A General Call Or Start Byte Command           */
      __IOM uint32_t SPECIAL    : 1;            /*!< [11..11] Indicates Whether Software Performs A Device-id Or
                                                     General Call Or Start Byte Command                                        */
            uint32_t            : 20;
    } TAR_b;
  } ;
  
  union {
    __IOM uint32_t SAR;                         /*!< (@ 0x00000008) SLAVE ADDRESS REGISTER                                     */
    
    struct {
      __IOM uint32_t SAR        : 10;           /*!< [9..0] Holds The Slave Address When The I2c Is Operating As
                                                     A Slave                                                                   */
            uint32_t            : 22;
    } SAR_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t DATACMD;                     /*!< (@ 0x00000010) DATA BUFFER AND COMMAND REGISTER                           */
    
    struct {
      __IOM uint32_t DATA       : 8;            /*!< [7..0] The Data To Be Transmitted Or Received On The I2C Bus              */
      __OM  uint32_t CMD        : 1;            /*!< [8..8] Controls Whether A Read Or A Write Is Performed                    */
      __OM  uint32_t STOP       : 1;            /*!< [9..9] Controls Whether A Stop Is Issued After The Byte Is Sent
                                                     Or Received                                                               */
      __OM  uint32_t RESTART    : 1;            /*!< [10..10] Controls Whether a RESTART Is Issued Before The Byte
                                                     Is Sent Or Received                                                       */
      __IM  uint32_t FIRSTDATA  : 1;            /*!< [11..11] Indicates The First Data Byte Received After The Address
                                                     Phase                                                                     */
            uint32_t            : 20;
    } DATACMD_b;
  } ;
  
  union {
    __IOM uint32_t SCLHCNT;                     /*!< (@ 0x00000014) STANDARD SPEED I2C CLOCK SCL HIGH COUNT REGISTER           */
    
    struct {
      __IOM uint32_t HCNT       : 16;           /*!< [15..0] Sets the SCL Clock High-period Count For Standard Speed           */
            uint32_t            : 16;
    } SCLHCNT_b;
  } ;
  
  union {
    __IOM uint32_t SCLLCNT;                     /*!< (@ 0x00000018) STANDARD SPEED I2C CLOCK SCL LOW COUNT REGISTER            */
    
    struct {
      __IOM uint32_t LCNT       : 16;           /*!< [15..0] Sets the SCL Clock Low-period Count For Standard Speed            */
            uint32_t            : 16;
    } SCLLCNT_b;
  } ;
  
  union {
    __IOM uint32_t FSSCLHCNT;                   /*!< (@ 0x0000001C) FAST MODE SCL HIGH COUNT REGISTER                          */
    
    struct {
      __IOM uint32_t HCNT       : 16;           /*!< [15..0] Sets the SCL Clock High-period Count For Fast Speed               */
            uint32_t            : 16;
    } FSSCLHCNT_b;
  } ;
  
  union {
    __IOM uint32_t FSSCLLCNT;                   /*!< (@ 0x00000020) FAST MODE SCL LOW COUNT REGISTER                           */
    
    struct {
      __IOM uint32_t LCNT       : 16;           /*!< [15..0] Sets the SCL Clock Low-period Count For Fast Speed                */
            uint32_t            : 16;
    } FSSCLLCNT_b;
  } ;
  __IM  uint32_t  RESERVED1[2];
  
  union {
    __IM  uint32_t INTSTAT;                     /*!< (@ 0x0000002C) I2C INTERRUPT STATUS REGISTER                              */
    
    struct {
      __IM  uint32_t RXUNDER    : 1;            /*!< [0..0] RX_UNDER Interrupt                                                 */
      __IM  uint32_t RXOVER     : 1;            /*!< [1..1] RX_OVER Interrupt                                                  */
      __IM  uint32_t RXFULL     : 1;            /*!< [2..2] RX_FULL Interrupt                                                  */
      __IM  uint32_t TXOVER     : 1;            /*!< [3..3] TX_OVER Interrupt                                                  */
      __IM  uint32_t TXEMPTY    : 1;            /*!< [4..4] TX_EMPTY Interrupt                                                 */
      __IM  uint32_t RDREQ      : 1;            /*!< [5..5] RD_REQ interrupt                                                   */
      __IM  uint32_t TXABRT     : 1;            /*!< [6..6] TX_ABRT Interrupt                                                  */
      __IM  uint32_t RXDONE     : 1;            /*!< [7..7] RX_DONE Interrupt                                                  */
      __IM  uint32_t ACTIVITY   : 1;            /*!< [8..8] ACTIVITY Interrupt                                                 */
      __IM  uint32_t STOPDET    : 1;            /*!< [9..9] STOP_DET Interrupt                                                 */
      __IM  uint32_t STARTDET   : 1;            /*!< [10..10] START_DET Interrupt                                              */
      __IM  uint32_t GENCALL    : 1;            /*!< [11..11] GEN_CALL Interrupt                                               */
      __IM  uint32_t RESTARTDET : 1;            /*!< [12..12] RESTART_DET Interrupt                                            */
      __IM  uint32_t MSTONHOLD  : 1;            /*!< [13..13] MASTER_ON_HOLD Interrupt                                         */
      __IM  uint32_t SCLSTUCKLOW : 1;           /*!< [14..14] SCL_STUCK_AT_LOW Interrupt                                       */
      __IM  uint32_t WRREQ      : 1;            /*!< [15..15] WR_REQ Interrupt                                                 */
            uint32_t            : 16;
    } INTSTAT_b;
  } ;
  
  union {
    __IOM uint32_t INTMASK;                     /*!< (@ 0x00000030) INTERRUPT MASK REGISTER                                    */
    
    struct {
      __IOM uint32_t RXUNDERMSK : 1;            /*!< [0..0] RX_UNDER Interrupt Mask                                            */
      __IOM uint32_t RXOVERMSK  : 1;            /*!< [1..1] RX_OVER Interrupt Mask                                             */
      __IOM uint32_t RXFULLMSK  : 1;            /*!< [2..2] RX_FULL Interrupt Mask                                             */
      __IOM uint32_t TXOVERMSK  : 1;            /*!< [3..3] TX_OVER Interrupt Mask                                             */
      __IOM uint32_t TXEMPTYMSK : 1;            /*!< [4..4] TX_EMPTY Interrupt Mask                                            */
      __IOM uint32_t RDREQMSK   : 1;            /*!< [5..5] RD_REQ Interrupt Mask                                              */
      __IOM uint32_t TXABRTMSK  : 1;            /*!< [6..6] TX_ABRT Interrupt Mask                                             */
      __IOM uint32_t RXDONEMSK  : 1;            /*!< [7..7] RX_DONE Interrupt Mask                                             */
      __IOM uint32_t ACTIVITYMSK : 1;           /*!< [8..8] ACTIVITY Interrupt Mask                                            */
      __IOM uint32_t STOPDETMSK : 1;            /*!< [9..9] STOP_DET Interrupt Mask                                            */
      __IOM uint32_t STARTDETMSK : 1;           /*!< [10..10] START_DET Interrupt Mask                                         */
      __IOM uint32_t GENCALLMSK : 1;            /*!< [11..11] GEN_CALL Interrupt Mask                                          */
      __IOM uint32_t RESTARTDETMSK : 1;         /*!< [12..12] RESTART_DET Interrupt Mask                                       */
      __IOM uint32_t MSTONHOLDMSK : 1;          /*!< [13..13] MASTER_ON_HOLD Interrupt Mask                                    */
      __IOM uint32_t SCLSTUCKLOWMSK : 1;        /*!< [14..14] SCL_STUCK_AT_LOW Interrupt Mask                                  */
      __IOM uint32_t WRREQMSK   : 1;            /*!< [15..15] WR_REQ Interrupt Mask                                            */
            uint32_t            : 16;
    } INTMASK_b;
  } ;
  
  union {
    __IOM uint32_t RAWINTSTAT;                  /*!< (@ 0x00000034) INTERRUPT STATUS REGISTER                                  */
    
    struct {
      __IM  uint32_t RXUNDERRAW : 1;            /*!< [0..0] RX_UNDER Interrupt Status                                          */
      __IM  uint32_t RXOVERRAW  : 1;            /*!< [1..1] RX_UNDER Interrupt Status                                          */
      __IM  uint32_t RXFULLRAW  : 1;            /*!< [2..2] RX_UNDER Interrupt Status                                          */
      __IM  uint32_t TXOVERRAW  : 1;            /*!< [3..3] TX_OVER Interrupt Status                                           */
      __IM  uint32_t TXEMPTYRAW : 1;            /*!< [4..4] TX_EMPTY Interrupt Status                                          */
      __IM  uint32_t RDREQRAW   : 1;            /*!< [5..5] RD_REQ Interrupt Status                                            */
      __IM  uint32_t TXABRTRAW  : 1;            /*!< [6..6] TX_ABRT Interrupt Status                                           */
      __IM  uint32_t RXDONERAW  : 1;            /*!< [7..7] RX_DONE Interrupt Status                                           */
      __IM  uint32_t ACTIVITYRAW : 1;           /*!< [8..8] I2C Controller Activity                                            */
      __IM  uint32_t STOPDETRAW : 1;            /*!< [9..9] STOP_DET Interrupt Status                                          */
      __IM  uint32_t STARTDETRAW : 1;           /*!< [10..10] START_DET Interrupt Status                                       */
      __IM  uint32_t GENCALLRAW : 1;            /*!< [11..11] GEN_CALL Interrupt Status                                        */
      __IM  uint32_t RESTARTDETRAW : 1;         /*!< [12..12] RESTART_DET Interrupt Status                                     */
      __IM  uint32_t MSTONHOLDRAW : 1;          /*!< [13..13] MASTER_ON_HOLD Interrupt Status                                  */
      __IM  uint32_t SCLSTUCKLOWRAW : 1;        /*!< [14..14] SCL_STUCK_AT_LOW Interrupt Status                                */
      __IM  uint32_t WRREQRAW   : 1;            /*!< [15..15] WR_REQ Interrupt Status                                          */
            uint32_t            : 16;
    } RAWINTSTAT_b;
  } ;
  
  union {
    __IOM uint32_t RXTL;                        /*!< (@ 0x00000038) I2C RECEIVE FIFO THRESHOLD REGISTER                        */
    
    struct {
      __IOM uint32_t THRES      : 8;            /*!< [7..0] Receive FIFO Threshold Level                                       */
            uint32_t            : 24;
    } RXTL_b;
  } ;
  
  union {
    __IOM uint32_t TXTL;                        /*!< (@ 0x0000003C) I2C TRANSMIT FIFO THRESHOLD REGISTER                       */
    
    struct {
      __IOM uint32_t THRES      : 8;            /*!< [7..0] Transmit FIFO Threshold Level                                      */
            uint32_t            : 24;
    } TXTL_b;
  } ;
  __IM  uint32_t  CLRINT;                       /*!< (@ 0x00000040) CLEAR COMBINED AND INDIVIDUAL INTERRUPT REGISTER           */
  __IM  uint32_t  CLRRXUNDER;                   /*!< (@ 0x00000044) Clear RX_UNDER Interrupt                                   */
  __IM  uint32_t  CLRRXOVER;                    /*!< (@ 0x00000048) Clear RX_OVER Interrupt Register                           */
  __IM  uint32_t  CLRTXOVER;                    /*!< (@ 0x0000004C) Clear TX_OVER Interrupt Register                           */
  __IM  uint32_t  CLRRDREQ;                     /*!< (@ 0x00000050) Clear RD_REQ Interrupt Register                            */
  __IM  uint32_t  CLRTXABRT;                    /*!< (@ 0x00000054) Clear TX_ABRT Interrupt Register                           */
  __IM  uint32_t  CLRRXDONE;                    /*!< (@ 0x00000058) Clear RX_DONE Interrupt Register                           */
  __IM  uint32_t  CLRACTIVITY;                  /*!< (@ 0x0000005C) Clear ACTIVITY Interrupt Register                          */
  __IM  uint32_t  CLRSTOPDET;                   /*!< (@ 0x00000060) Clear STOP_DET Interrupt Register                          */
  __IM  uint32_t  CLRSTARTDET;                  /*!< (@ 0x00000064) Clear START_DET Interrupt Register                         */
  __IM  uint32_t  CLRGENCALL;                   /*!< (@ 0x00000068) Clear GEN_CALL Interrupt Register                          */
  
  union {
    __IOM uint32_t ENABLE;                      /*!< (@ 0x0000006C) ENABLE REGISTER                                            */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Controls Whether The I2C Controller Is Enabled                     */
      __IOM uint32_t ABORT      : 1;            /*!< [1..1] Initiates The Transfer Abort                                       */
      __IOM uint32_t TXCMDBLOCK : 1;            /*!< [2..2] Blocks The Transmission Of Data On I2c Bus Or Not                  */
      __IOM uint32_t SDARECOVEN : 1;            /*!< [3..3] Control Knob To Initiate The SDA Recovery Mechanism                */
            uint32_t            : 28;
    } ENABLE_b;
  } ;
  
  union {
    __IM  uint32_t STATUS;                      /*!< (@ 0x00000070) I2C STATUS Register                                        */
    
    struct {
      __IM  uint32_t ACTIVITY   : 1;            /*!< [0..0] I2C Activity Status                                                */
      __IM  uint32_t TFNF       : 1;            /*!< [1..1] Transmit FIFO Not Full                                             */
      __IM  uint32_t TFE        : 1;            /*!< [2..2] Transmit FIFO Completely Empty                                     */
      __IM  uint32_t RFNE       : 1;            /*!< [3..3] Receive FIFO Not Empty                                             */
      __IM  uint32_t RFF        : 1;            /*!< [4..4] Receive FIFO Completely Full                                       */
      __IM  uint32_t MSTACTIVITY : 1;           /*!< [5..5] Master FSM Activity Status                                         */
      __IM  uint32_t SLVACTIVITY : 1;           /*!< [6..6] Slave FSM Activity Status                                          */
      __IM  uint32_t MSTHOLDTXEMPTY : 1;        /*!< [7..7] Indicates The Bus Hold When The Master Holds The Bus
                                                     Because Of The Tx FIFO Being Empty                                        */
      __IM  uint32_t MSTHOLDRXFULL : 1;         /*!< [8..8] INdicates The Bus Hold In Master Mode Due To Rx FIFO
                                                     Is Full And Additional Byte Has Been Received                             */
      __IM  uint32_t SLVHOLDTXEMPTY : 1;        /*!< [9..9] Indicates The Bus Hold In Slave Mode Due To Rx FIFO Is
                                                     Full And Additional Byte Has Been Received                                */
      __IM  uint32_t SLVHOLDRXFULL : 1;         /*!< [10..10] Indicates The Bus Hold In Slave Mode Due To Rx FIFO
                                                     Is Full And Additional Byte Has Been Received                             */
      __IM  uint32_t SDANOTRECOV : 1;           /*!< [11..11] Indicates That SDA Stuck At Low Is Not Recovered After
                                                     The Recovery Mechanism                                                    */
            uint32_t            : 20;
    } STATUS_b;
  } ;
  __IOM uint32_t  TXFLR;                        /*!< (@ 0x00000074) I2C TRANSMIT FIFO LEVEL REGISTER                           */
  __IOM uint32_t  RXFLR;                        /*!< (@ 0x00000078) I2C RECEIVE FIFO LEVEL REGISTER                            */
  
  union {
    __IOM uint32_t SDAHOLD;                     /*!< (@ 0x0000007C) I2C SDA HOLD TIME LENGTH REGISTER                          */
    
    struct {
      __IOM uint32_t SDATXHOLD  : 16;           /*!< [15..0] Sets The Required SDA Hold Time In Units Of clk Period            */
      __IOM uint32_t SDARXHOLD  : 8;            /*!< [23..16] Sets the required SDA hold time in units of I2C clk
                                                     period                                                                    */
            uint32_t            : 8;
    } SDAHOLD_b;
  } ;
  
  union {
    __IOM uint32_t TXABRTSRC;                   /*!< (@ 0x00000080) I2C TRANSMIT ABORT SOURCE REGISTER                         */
    
    struct {
      __IM  uint32_t ADDR7BNAK  : 1;            /*!< [0..0] Indicates That The Master Is In 7-bit Addressing Mode
                                                     And The Address Sent Was Not Acknowledged By Any Slave                    */
      __IM  uint32_t ADDR10BNAK1 : 1;           /*!< [1..1] Indicates That The Master Is In 10-bit Address Mode And
                                                     The First 10-bit Address Byte Was Not Acknowledged By Any
                                                     Slave                                                                     */
      __IM  uint32_t ADDR10BNACK2 : 1;          /*!< [2..2] Indicates That The Master Is In 10-bit Address Mode And
                                                     The Second 10-bit Address Byte Was Not Acknowledged By
                                                     Any Slave                                                                 */
      __IM  uint32_t TXDATANAK  : 1;            /*!< [3..3] Indicates The Master-mode Only Bit. When Themaster Receives
                                                     An Acknowledgement For The Address                                        */
      __IM  uint32_t GCALLNAK   : 1;            /*!< [4..4] Indicates That I2C Controller In Master Mode Has Sent
                                                     A General Call And No Slave On The Bus Acknowledged The
                                                     General Call                                                              */
      __IM  uint32_t GCALLREAD  : 1;            /*!< [5..5] Indicates That Dw_apb_i2c In The Master Mode Has Sent
                                                     A General Call But The User Programmed The Byte Following
                                                     The General Call To Be A Read From The Bus                                */
      __IM  uint32_t HSACKDET   : 1;            /*!< [6..6] Indicates That The Master Is In High Speed Mode And The
                                                     High Speed Master Code Was Acknowledged                                   */
      __IM  uint32_t SBYTEACKET : 1;            /*!< [7..7] Indicates That The Master Has Sent A START Byte And The
                                                     START Byte Was Acknowledged                                               */
      __IM  uint32_t HSNORSTRT  : 1;            /*!< [8..8] Indicates That The Restart Is Disabled                             */
      __IM  uint32_t SBYTENORSTRT : 1;          /*!< [9..9] Indicates That The Restart Is Disabled                             */
      __IM  uint32_t ADDR10BRDNORSTRT : 1;      /*!< [10..10] Indicates That The Restart Is Disabled                           */
      __IM  uint32_t MASTERIDS  : 1;            /*!< [11..11] Indicates That The User Tries To Initiate A Master
                                                     Operation With The Master Mode Disabled                                   */
      __IM  uint32_t ARBLOST    : 1;            /*!< [12..12] This Field Specifies That The Master Has Lost Arbitration        */
      __IM  uint32_t SLVFLUSHTXFIFO : 1;        /*!< [13..13] This Field Specifies That The Slave Has Received A
                                                     Read Command And Some Data Exists In The TX FIFO                          */
      __IM  uint32_t SLVARBLOST : 1;            /*!< [14..14] This Field Indicates That A Slave Has Lost The Bus
                                                     While Transmitting Data To A Remote Master                                */
      __IM  uint32_t SLVRDINTX  : 1;            /*!< [15..15] When The Processor Side Responds To A Slave Mode Request
                                                     For Data To Be Transmitted To A Remote Master And User
                                                     Writes A 1 In Cmd (bit 8) Of Ic_data_cmd Register                         */
      __IM  uint32_t USRABRT    : 1;            /*!< [16..16] This Is A Master-mode-only Bit. Master Has Detected
                                                     The Transfer Abort                                                        */
      __IM  uint32_t SDASTUCKLOW : 1;           /*!< [17..17] This Is A Master-mode-only Bit. Master Detects The
                                                     SDA Stuck At Low                                                          */
      __IM  uint32_t DEVNAK     : 1;            /*!< [18..18] Master Is Initiating The DEVICE_ID Transfer And The
                                                     Device Id Sent Was Not Acknowledged By Any Slave                          */
      __IM  uint32_t DEVSLVADDRNAK : 1;         /*!< [19..19] Master Is Initiating The DEVICE_ID Transfer And The
                                                     Slave Address Sent Was Not Acknowledged By Any Slave                      */
      __IM  uint32_t DEVWRITE   : 1;            /*!< [20..20] Master Is Initiating The DEVICE_ID Transfer And The
                                                     Tx-FIFO Consists Of Write Commands                                        */
            uint32_t            : 2;
      __IM  uint32_t TXFLUSHCNT : 9;            /*!< [31..23] Indicates The Number Of Tx FIFO Data Commands Which
                                                     Are Flushed Due To TX_ABRT Interrupt                                      */
    } TXABRTSRC_b;
  } ;
  
  union {
    __IOM uint32_t SLVDATANACKONLY;             /*!< (@ 0x00000084) GENERATE SLAVE DATA NACK REGISTER                          */
    
    struct {
      __IOM uint32_t NAK        : 1;            /*!< [0..0] Generate Nack. This Nack Generation Only Occurs When
                                                     I2C Controller Is A Slave-receiver                                        */
            uint32_t            : 31;
    } SLVDATANACKONLY_b;
  } ;
  __IM  uint32_t  RESERVED2[3];
  
  union {
    __IOM uint32_t SDASETUP;                    /*!< (@ 0x00000094) I2C SDA SETUP REGISTER                                     */
    
    struct {
      __IOM uint32_t SETUP      : 8;            /*!< [7..0] SDA Setup (tSU:DAT)                                                */
            uint32_t            : 24;
    } SDASETUP_b;
  } ;
  
  union {
    __IOM uint32_t ACKGENCALL;                  /*!< (@ 0x00000098) I2C ACK GENERAL CALL REGISTER                              */
    
    struct {
      __IOM uint32_t ACK        : 1;            /*!< [0..0] ACK General Call                                                   */
            uint32_t            : 31;
    } ACKGENCALL_b;
  } ;
  
  union {
    __IM  uint32_t ENSTS;                       /*!< (@ 0x0000009C) I2C ENABLE STATUS REGISTER                                 */
    
    struct {
      __IM  uint32_t ENABLE     : 1;            /*!< [0..0] IC Enable Status                                                   */
      __IM  uint32_t SLVDISBUSY : 1;            /*!< [1..1] Slave Disabled While Busy (Transmit, Receive)                      */
      __IM  uint32_t SLVRXDATALOST : 1;         /*!< [2..2] Slave Received Data Lost                                           */
            uint32_t            : 29;
    } ENSTS_b;
  } ;
  
  union {
    __IOM uint32_t SPKLEN;                      /*!< (@ 0x000000A0) I2C SS, FS OR FM+ RO UFM SPIKE SUPPRESSION LIMIT           */
    
    struct {
      __IOM uint32_t LEN        : 8;            /*!< [7..0] Sets the Duration, Measured In Clk Cycle                           */
            uint32_t            : 24;
    } SPKLEN_b;
  } ;
  __IM  uint32_t  RESERVED3;
  __IOM uint32_t  CLRRESTARTDET;                /*!< (@ 0x000000A8) CLEAR RESTART_DET INTERRUPT REGISTER                       */
  __IOM uint32_t  SCLLOWTO;                     /*!< (@ 0x000000AC) I2C SCL STUCK AT LOW TIMEOUT REGISTER                      */
  __IOM uint32_t  SDALOWTO;                     /*!< (@ 0x000000B0) I2C SDA STUCK AT LOW TIMEOUT REGISTER                      */
  __IOM uint32_t  CLRSCLSTUCKDET;               /*!< (@ 0x000000B4) CLEAR SCL STUCK AT LOW DETECT INTERRUPT REGISTER           */
} DW_I2C_Type;                                  /*!< Size = 184 (0xb8)                                                         */



/* =========================================================================================================================== */
/* ================                                          STRIP0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief ARGB LED STRIP Controller (STRIP0)
  */

typedef struct {                                /*!< (@ 0x40101600) STRIP0 Structure                                           */
  
  union {
    __IOM uint32_t CONTROL;                     /*!< (@ 0x00000000) LED STRIP CONTROL REGISTER                                 */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] LED STRIP ENABLE                                                   */
      __IOM uint32_t START      : 1;            /*!< [1..1] LED STRIP START. 1=Start data buffer transmit. W1C clears          */
      __IOM uint32_t STOP       : 1;            /*!< [2..2] LED STRIP STOP. 1=stop after this transmit cycle is complete       */
      __IOM uint32_t PENDEN     : 1;            /*!< [3..3] LED STRIP PENDING CODE ENABLE                                      */
      __IOM uint32_t MDSEL      : 2;            /*!< [5..4] LED MODE SELECT                                                    */
      __IOM uint32_t FINISHINTEN : 1;           /*!< [6..6] LED STRIP FINISH INTERRUPT ENABLE                                  */
      __IOM uint32_t FINISHINTSTS : 1;          /*!< [7..7] LED STRIP BUSY INTERRUPT STATUS. W1C clears to 0. 1=Busy
                                                     flag from 1 to 0                                                          */
      __IOM uint32_t FINISHSTS  : 1;            /*!< [8..8] LED STRIP FINISH STATUS: 1=Data transfer is finished;
                                                     0=interface is idle                                                       */
            uint32_t            : 7;
      __IOM uint32_t REPCY      : 8;            /*!< [23..16] LED STRIP REPEAT CYCLE. Output strip data size is [REPCY
                                                     * (TRANSLEN +1)]                                                          */
            uint32_t            : 8;
    } CONTROL_b;
  } ;
  
  union {
    __IOM uint32_t CODE0;                       /*!< (@ 0x00000004) LED STRIP 0 CODE                                           */
    
    struct {
      __IOM uint32_t ZCLW       : 6;            /*!< [5..0] LED STRIP 0 CODE LOW WIDTH. Output 0 low time = (ZCLW
                                                     + 2) * period of clk_fnd (40ns)                                           */
            uint32_t            : 2;
      __IOM uint32_t ZCHW       : 6;            /*!< [13..8] LED STRIP 0 CODE HIGH WIDTH. Output 0 high time = (ZCHW
                                                     + 2) * period of clk_fnd (40ns)                                           */
            uint32_t            : 18;
    } CODE0_b;
  } ;
  
  union {
    __IOM uint32_t CODE1;                       /*!< (@ 0x00000008) LED STRIP 1 CODE                                           */
    
    struct {
      __IOM uint32_t OCLW       : 6;            /*!< [5..0] LED STRIP 1 CODE LOW WIDTH. Output 1 low time = (OCLW
                                                     + 2) * period of clk_fnd (40ns)                                           */
            uint32_t            : 2;
      __IOM uint32_t OCHW       : 6;            /*!< [13..8] LED STRIP 1 CODE HIGH WIDTH. Output 1 high time = (OCHW
                                                     + 2) * period of clk_fnd (40ns)                                           */
            uint32_t            : 18;
    } CODE1_b;
  } ;
  
  union {
    __IOM uint32_t RSTW;                        /*!< (@ 0x0000000C) LED STRIP RESET WIDTH REGISTER                             */
    
    struct {
      __IOM uint32_t RSTW       : 32;           /*!< [31..0] LED strip reset time = (RSTW + 1) * period of clk_fnd
                                                     (40ns).  RSTLW [5:0] is treated as 1_11111b internally.                   */
    } RSTW_b;
  } ;
  
  union {
    __IOM uint32_t PENDW;                       /*!< (@ 0x00000010) Pending Width Control Register                             */
    
    struct {
      __IOM uint32_t PENDW      : 6;            /*!< [5..0] These bits control pending time before the next LED strip
                                                     data is transferred.                                                      */
            uint32_t            : 26;
    } PENDW_b;
  } ;
  
  union {
    __IOM uint32_t DSRC;                        /*!< (@ 0x00000014) LED STRIP Data Source Address                              */
    
    struct {
      __IOM uint32_t TRANSADD   : 32;           /*!< [31..0] Before starting an LED STRIP Transmit, this field must
                                                     be initialized to contain the Base Address of the buffer
                                                     in SRAM.                                                                  */
    } DSRC_b;
  } ;
  
  union {
    __IOM uint32_t TRANSLEN;                    /*!< (@ 0x00000018) Transmit Length Register                                   */
    
    struct {
      __IOM uint32_t TRANSLEN   : 14;           /*!< [13..0] Specifies how many bytes are to be transmitted from
                                                     the Transmit Buffer memory.                                               */
            uint32_t            : 18;
    } TRANSLEN_b;
  } ;
  
  union {
    __IOM uint32_t ADVCMD;                      /*!< (@ 0x0000001C) Advanced Command Register                                  */
    
    struct {
      __IOM uint32_t ADVEN      : 1;            /*!< [0..0] Enable advanced command execution                                  */
      __IOM uint32_t ADVCMD     : 3;            /*!< [3..1] Advanced command selector.  0x00: AVD_TH50 0x01: AVD_TH20
                                                     0x02: AVD_SLEEP 0x03: AVD_WAKEUP 0x04: AVD_SET_ID 0x05:
                                                     AVD_CLEAN_ID 0x06: AVD_CHECK_ID 0x07: AVD_SPECIFY_ID                      */
            uint32_t            : 28;
    } ADVCMD_b;
  } ;
  
  union {
    __IOM uint32_t TH50CTRL0;                   /*!< (@ 0x00000020) ADV_TH50 Command Timing Register                           */
    
    struct {
      __IOM uint32_t TH50H1T    : 12;           /*!< [11..0] Indicate the 1st high pulse width (number of count base
                                                     on 24MHz) of ADV_TH50 command.                                            */
            uint32_t            : 4;
      __IOM uint32_t TH50L1T    : 12;           /*!< [27..16] Indicate the 1st low pulse width (number of count base
                                                     on 24MHz) of ADV_TH50 command.                                            */
            uint32_t            : 4;
    } TH50CTRL0_b;
  } ;
  
  union {
    __IOM uint32_t TH50CTRL1;                   /*!< (@ 0x00000024) ADV_TH50 2nd Pulse Timing Register                         */
    
    struct {
      __IOM uint32_t TH50H2T    : 12;           /*!< [11..0] Indicate the 2nd high pulse width (number of count based
                                                     on 24MHz) of ADV_TH50 command.                                            */
            uint32_t            : 4;
      __IOM uint32_t TH50L2T    : 12;           /*!< [27..16] Indicate the 2nd low pulse width (number of count based
                                                     on 24MHz) of ADV_TH50 command.                                            */
            uint32_t            : 4;
    } TH50CTRL1_b;
  } ;
  
  union {
    __IOM uint32_t TH50RX;                      /*!< (@ 0x00000028) TH50 Receive Register                                      */
    
    struct {
      __IOM uint32_t RX_TH50_PRE : 8;           /*!< [7..0] TH50 pre-received data (bits 7:0).                                 */
      __IOM uint32_t RX_TH50    : 8;            /*!< [15..8] Received TH50 data (bits 15:8).                                   */
            uint32_t            : 16;
    } TH50RX_b;
  } ;
  
  union {
    __IOM uint32_t TH50TO;                      /*!< (@ 0x0000002C) ADV_TH50 Timeout Register                                  */
    
    struct {
      __IOM uint32_t TH50TO     : 12;           /*!< [11..0] Indicate the timeout pulse width (number of count based
                                                     on 24MHz) of ADV_TH50 command.  Exit ADV_TH50 mode when
                                                     there is no response pulse within the time of TH50TO.                     */
            uint32_t            : 20;
    } TH50TO_b;
  } ;
  
  union {
    __IOM uint32_t AVDPRLCTRL0;                 /*!< (@ 0x00000030) ARGB Gen2 Parallel Control Register 0                      */
    
    struct {
      __IOM uint32_t TH20HT     : 12;           /*!< [11..0] High pulse width (counts, 24MHz) of ADV_TH20 command              */
      __IOM uint32_t ADVWKLT    : 8;            /*!< [19..12] Low pulse width (counts, 24MHz/1024) of ADV_WAKUP command,
                                                     default ~1ms                                                              */
      __IOM uint32_t ADVWKHT    : 8;            /*!< [27..20] High pulse width (counts, 24MHz) of ADV_WAKUP command            */
      __IOM uint32_t ADVID      : 4;            /*!< [31..28] Dynamic ID number for ARGB gen2 parallel mode                    */
    } AVDPRLCTRL0_b;
  } ;
  
  union {
    __IOM uint32_t AVDPRLCTRL1;                 /*!< (@ 0x00000034) ARGB Gen2 Parallel Control Register 1                      */
    
    struct {
      __IOM uint32_t PRLHT      : 12;           /*!< [11..0] High pulse width (counts, 24MHz) of ADV_SET_ID command            */
            uint32_t            : 4;
      __IOM uint32_t PRLLT      : 12;           /*!< [27..16] Low pulse width (counts, 24MHz) of ADV_SET_ID command            */
            uint32_t            : 4;
    } AVDPRLCTRL1_b;
  } ;
  
  union {
    __IOM uint32_t AVDPRLTO;                    /*!< (@ 0x00000038) ADV_SET_ID Timeout Register                                */
    
    struct {
      __IOM uint32_t PRLTO      : 12;           /*!< [11..0] Timeout low pulse width (counts, 24MHz) of ADV_SET_ID
                                                     command                                                                   */
            uint32_t            : 20;
    } AVDPRLTO_b;
  } ;
  
  union {
    __IOM uint32_t RECVADDR;                    /*!< (@ 0x0000003C) SRAM Address for Receiving Gen2 ARGB Data                  */
    
    struct {
      __IOM uint32_t RECVADDR   : 32;           /*!< [31..0] SRAM address for receiving Gen2 ARGB data                         */
    } RECVADDR_b;
  } ;
  
  union {
    __IOM uint32_t RECVCNT;                     /*!< (@ 0x00000040) Receive Data Count Register                                */
    
    struct {
      __IOM uint32_t RECVCNT    : 8;            /*!< [7..0] Receive data count                                                 */
            uint32_t            : 24;
    } RECVCNT_b;
  } ;
  
  union {
    __IOM uint32_t ADVSTS;                      /*!< (@ 0x00000044) Status Register                                            */
    
    struct {
      __IOM uint32_t ADVTO      : 1;            /*!< [0..0] Timeout Flag (W1C)                                                 */
      __IOM uint32_t ID_ACK     : 1;            /*!< [1..1] ID Acknowledge (W1C)                                               */
            uint32_t            : 30;
    } ADVSTS_b;
  } ;
  
  union {
    __IOM uint32_t ADVINT;                      /*!< (@ 0x00000048) ADV Interrupt Enable Register                              */
    
    struct {
      __IOM uint32_t ADVTOINT_EN : 1;           /*!< [0..0] ADV Timeout Interrupt Enable                                       */
            uint32_t            : 31;
    } ADVINT_b;
  } ;
} STRIP_Type;                                   /*!< Size = 76 (0x4c)                                                          */



/* =========================================================================================================================== */
/* ================                                           GPIO                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief GPIO Controller (GPIO)
  */

typedef struct {                                /*!< (@ 0x40110000) GPIO Structure                                             */
  
  union {
    __IOM uint32_t GCR[61];                     /*!< (@ 0x00000000) CONTROL REGISTER                                           */
    
    struct {
      __IOM uint32_t DIR        : 1;            /*!< [0..0] Direction                                                          */
      __IOM uint32_t INDETEN    : 1;            /*!< [1..1] Input Detection Enable                                             */
      __IOM uint32_t INVOLMD    : 1;            /*!< [2..2] Input Voltage Mode                                                 */
      __IM  uint32_t PINSTS     : 1;            /*!< [3..3] Status of GPIO Pin                                                 */
            uint32_t            : 4;
      __IOM uint32_t MFCTRL     : 3;            /*!< [10..8] Multiple Function Control                                         */
      __IOM uint32_t OUTDRV     : 1;            /*!< [11..11] Driving Current Selection                                        */
      __IOM uint32_t SLEWRATE   : 1;            /*!< [12..12] Slew Rate Selection                                              */
      __IOM uint32_t PULLDWEN   : 1;            /*!< [13..13] Internal Pull-Down Resistor Enable                               */
      __IOM uint32_t PULLUPEN   : 1;            /*!< [14..14] Internal Pull-Up Resistor Enable                                 */
      __IOM uint32_t SCHEN      : 1;            /*!< [15..15] Schmitter-Trigger Enable                                         */
      __IOM uint32_t OUTMD      : 1;            /*!< [16..16] Output Mode Selection                                            */
      __IOM uint32_t OUTCTRL    : 1;            /*!< [17..17] Output Control                                                   */
            uint32_t            : 6;
      __IOM uint32_t INTCTRL    : 3;            /*!< [26..24] Type of GPIO Interrupt                                           */
            uint32_t            : 1;
      __IOM uint32_t INTEN      : 1;            /*!< [28..28] Interrupt Enable                                                 */
            uint32_t            : 2;
      __IOM uint32_t INTSTS     : 1;            /*!< [31..31] Interrupt Status                                                 */
    } GCR_b[61];
  } ;
} GPIO_Type;                                    /*!< Size = 244 (0xf4)                                                         */



/* =========================================================================================================================== */
/* ================                                          PWMLED0                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief PWM LED Controller (PWMLED0)
  */

typedef struct {                                /*!< (@ 0x40121000) PWMLED0 Structure                                          */
  
  union {
    __IOM uint32_t MODE;                        /*!< (@ 0x00000000) MODE REGISTER                                              */
    
    struct {
      __IOM uint32_t SEL        : 2;            /*!< [1..0] Mode Selection                                                     */
            uint32_t            : 30;
    } MODE_b;
  } ;
  
  union {
    __IOM uint32_t DL;                          /*!< (@ 0x00000004) DUTY LIMIT REGISTER                                        */
    
    struct {
      __IOM uint32_t MINV       : 8;            /*!< [7..0] Minimum Duty Cycle                                                 */
      __IOM uint32_t MAXV       : 8;            /*!< [15..8] Maximum Duty Cycle                                                */
            uint32_t            : 16;
    } DL_b;
  } ;
  
  union {
    __IOM uint32_t WT;                          /*!< (@ 0x00000008) WAIT TIME REGISTER                                         */
    
    struct {
      __IOM uint32_t LKV        : 12;           /*!< [11..0] Low wait-time                                                     */
            uint32_t            : 4;
      __IOM uint32_t HKV        : 12;           /*!< [27..16] High wait-time                                                   */
            uint32_t            : 4;
    } WT_b;
  } ;
  
  union {
    __IOM uint32_t SD;                          /*!< (@ 0x0000000C) STEP DUTY REGISTER                                         */
    
    struct {
      __IOM uint32_t STEP0DV    : 4;            /*!< [3..0] Step0 Duty Value                                                   */
      __IOM uint32_t STEP1DV    : 4;            /*!< [7..4] Step1 Duty Value                                                   */
      __IOM uint32_t STEP2DV    : 4;            /*!< [11..8] Step2 Duty Value                                                  */
      __IOM uint32_t STEP3DV    : 4;            /*!< [15..12] Step3 Duty Value                                                 */
      __IOM uint32_t STEP4DV    : 4;            /*!< [19..16] Step4 Duty Value                                                 */
      __IOM uint32_t STEP5DV    : 4;            /*!< [23..20] Step5 Duty Value                                                 */
      __IOM uint32_t STEP6DV    : 4;            /*!< [27..24] Step6 Duty Value                                                 */
      __IOM uint32_t STEP7DV    : 4;            /*!< [31..28] Step7 Duty Value                                                 */
    } SD_b;
  } ;
  
  union {
    __IOM uint32_t ST;                          /*!< (@ 0x00000010) STEP TIME REGISTER                                         */
    
    struct {
      __IOM uint32_t STEP0TV    : 4;            /*!< [3..0] Step0 Time Value                                                   */
      __IOM uint32_t STEP1TV    : 4;            /*!< [7..4] Step1 Time Value                                                   */
      __IOM uint32_t STEP2TV    : 4;            /*!< [11..8] Step2 Time Value                                                  */
      __IOM uint32_t STEP3TV    : 4;            /*!< [15..12] Step3 Time Value                                                 */
      __IOM uint32_t STEP4TV    : 4;            /*!< [19..16] Step4 Time Value                                                 */
      __IOM uint32_t STEP5TV    : 4;            /*!< [23..20] Step5 Time Value                                                 */
      __IOM uint32_t STEP6TV    : 4;            /*!< [27..24] Step6 Time Value                                                 */
      __IOM uint32_t STEP7TV    : 4;            /*!< [31..28] Step7 Time Value                                                 */
    } ST_b;
  } ;
  
  union {
    __IOM uint32_t CTRL;                        /*!< (@ 0x00000014) CONTROL REGISTER                                           */
    
    struct {
            uint32_t            : 16;
      __IOM uint32_t CYCLE      : 8;            /*!< [23..16] The number of output cycle                                       */
            uint32_t            : 4;
      __IOM uint32_t OUTPUT     : 1;            /*!< [28..28] Control the output method                                        */
      __IOM uint32_t INVT       : 1;            /*!< [29..29] Output Inverter Control                                          */
      __IOM uint32_t RST        : 1;            /*!< [30..30] Reset PWM LED Controller                                         */
      __IOM uint32_t EN         : 1;            /*!< [31..31] Enable PWMLED Controller                                         */
    } CTRL_b;
  } ;
} PWMLED_Type;                                  /*!< Size = 24 (0x18)                                                          */



/* =========================================================================================================================== */
/* ================                                           TMR0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Timer Controller (TMR0)
  */

typedef struct {                                /*!< (@ 0x40121400) TMR0 Structure                                             */
  __IOM uint32_t  LDCNT;                        /*!< (@ 0x00000000) LOAD COUNTER REGISTER                                      */
  __IOM uint32_t  CNT;                          /*!< (@ 0x00000004) CURRENT COUNTER REGISTER                                   */
  
  union {
    __IOM uint32_t CTRL;                        /*!< (@ 0x00000008) CONTROL REGISTER                                           */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Enable Timer Contoller                                             */
      __IOM uint32_t MDSEL      : 1;            /*!< [1..1] Timer Operating Mode Selection                                     */
      __IOM uint32_t INTEN      : 1;            /*!< [2..2] Enable Timer Interrupt                                             */
      __IOM uint32_t STOP       : 1;            /*!< [3..3] Stop timer                                                         */
            uint32_t            : 28;
    } CTRL_b;
  } ;
  
  union {
    __IOM uint32_t INTSTS;                      /*!< (@ 0x0000000C) INTERRUPT STATUS REGISTER                                  */
    
    struct {
      __IOM uint32_t STS        : 1;            /*!< [0..0] Timer Interrupt Status                                             */
            uint32_t            : 31;
    } INTSTS_b;
  } ;
} TMR_Type;                                     /*!< Size = 16 (0x10)                                                          */



/* =========================================================================================================================== */
/* ================                                           CRC32                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief CRC32 Engine (CRC32)
  */

typedef struct {                                /*!< (@ 0x40122000) CRC32 Structure                                            */
  
  union {
    __IOM uint32_t CTRL;                        /*!< (@ 0x00000000) Control register                                           */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Enable CRC32. Controls whether CRC32 is enabled or disabled.       */
      __IOM uint32_t INIT       : 1;            /*!< [1..1] Initialize checksum. Resets CHKSUM to 0xFFFFFFFF and
                                                     auto-clears to '0'.                                                       */
            uint32_t            : 30;
    } CTRL_b;
  } ;
  
  union {
    __IOM uint32_t INPUT;                       /*!< (@ 0x00000004) Data input register for CRC32 computation.                 */
    
    struct {
      __IOM uint32_t INPUT      : 32;           /*!< [31..0] Data input for CRC32.                                             */
    } INPUT_b;
  } ;
  __IOM uint32_t  RESULT;                       /*!< (@ 0x00000008) CRC32 Result Register                                      */
  __IOM uint32_t  CHKSUM;                       /*!< (@ 0x0000000C) Checksum Result Register                                   */
} CRC_Type;                                     /*!< Size = 16 (0x10)                                                          */



/* =========================================================================================================================== */
/* ================                                          DOTMTX0                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Dot Matrix Controller (DOTMTX0)
  */

typedef struct {                                /*!< (@ 0x40122100) DOTMTX0 Structure                                          */
  
  union {
    __IOM uint32_t DATASRC;                     /*!< (@ 0x00000000) Register indicating the source address for PWM
                                                                    data.                                                      */
    
    struct {
      __IOM uint32_t DSRC       : 32;           /*!< [31..0] Source address for PWM data.                                      */
    } DATASRC_b;
  } ;
  
  union {
    __IOM uint32_t CTRL;                        /*!< (@ 0x00000004) Control register for matrix operations including
                                                                    interrupts and scan control.                               */
    
    struct {
      __IOM uint32_t START      : 1;            /*!< [0..0] Control matrix scan start or stop.                                 */
      __IOM uint32_t INTEN      : 1;            /*!< [1..1] Enable matrix interrupt.                                           */
      __IOM uint32_t INTTYPE    : 1;            /*!< [2..2] Interrupt type. Determines interrupt behavior for matrix
                                                     scans.                                                                    */
            uint32_t            : 29;
    } CTRL_b;
  } ;
  
  union {
    __IOM uint32_t COLCTRL;                     /*!< (@ 0x00000008) Column control register for matrix PWM and reference
                                                                    setup.                                                     */
    
    struct {
      __IOM uint32_t CHEN       : 16;           /*!< [15..0] Indicates which PWM channels are used for the matrix.             */
      __IOM uint32_t REFCH      : 4;            /*!< [19..16] Indicates which PWM channel is the reference source.             */
      __IOM uint32_t ROUND      : 8;            /*!< [27..20] Number of PWM cycles to run during the same row before
                                                     switching.                                                                */
            uint32_t            : 4;
    } COLCTRL_b;
  } ;
  
  union {
    __IOM uint32_t ROWCTRL;                     /*!< (@ 0x0000000C) Row control register for setting polarity and
                                                                    scan timing for dot matrix.                                */
    
    struct {
      __IOM uint32_t PSWNUM     : 4;            /*!< [3..0] Indicate how many scan rows the matrix uses.                       */
      __IOM uint32_t SWDELAY    : 8;            /*!< [11..4] Sets delay time before/after row scan switch.                     */
      __IOM uint32_t PSWODEN    : 10;           /*!< [21..12] Enable open-drain configuration on PSWn.                         */
      __IOM uint32_t PSWPOL     : 10;           /*!< [31..22] Setting active polarity for PSWn.                                */
    } ROWCTRL_b;
  } ;
  
  union {
    __IOM uint32_t ROWORD0;                     /*!< (@ 0x00000010) Register specifying scan order for matrix rows.            */
    
    struct {
      __IOM uint32_t PSWORD0    : 4;            /*!< [3..0] Indicate scan order for PSW0 row.                                  */
      __IOM uint32_t PSWORD1    : 4;            /*!< [7..4] Reference PSWORD0.                                                 */
      __IOM uint32_t PSWORD2    : 4;            /*!< [11..8] Reference PSWORD0.                                                */
      __IOM uint32_t PSWORD3    : 4;            /*!< [15..12] Reference PSWORD0.                                               */
      __IOM uint32_t PSWORD4    : 4;            /*!< [19..16] Reference PSWORD0.                                               */
      __IOM uint32_t PSWORD5    : 4;            /*!< [23..20] Reference PSWORD0.                                               */
      __IOM uint32_t PSWORD6    : 4;            /*!< [27..24] Reference PSWORD0.                                               */
      __IOM uint32_t PSWORD7    : 4;            /*!< [31..28] Reference PSWORD0.                                               */
    } ROWORD0_b;
  } ;
  
  union {
    __IOM uint32_t ROWORD1;                     /*!< (@ 0x00000014) Additional row control specifying scan order
                                                                    for remaining rows.                                        */
    
    struct {
      __IOM uint32_t PSWORD8    : 4;            /*!< [3..0] Reference PSWORD0.                                                 */
      __IOM uint32_t PSWORD9    : 4;            /*!< [7..4] Reference PSWORD0.                                                 */
            uint32_t            : 24;
    } ROWORD1_b;
  } ;
  
  union {
    __IOM uint32_t STS;                         /*!< (@ 0x00000018) Status control register for matrix operations.             */
    
    struct {
      __IM  uint32_t CURROUND   : 8;            /*!< [7..0] Indicates current PWM cycle round for the matrix.                  */
      __IM  uint32_t CURROW     : 4;            /*!< [11..8] Indicates current scan row for matrix operation.                  */
      __IOM uint32_t INTSTS     : 1;            /*!< [12..12] Interrupt flag for matrix operation.                             */
      __IOM uint32_t INTRDRDY   : 1;            /*!< [13..13] Interrupt flag for APB read without response.                    */
      __IOM uint32_t INTWRRDY   : 1;            /*!< [14..14] Interrupt flag for APB write without response.                   */
            uint32_t            : 17;
    } STS_b;
  } ;
  __IOM uint32_t  PWMADDR;                      /*!< (@ 0x0000001C) Indicate the written address for PWM data.                 */
} DOTMTX_Type;                                  /*!< Size = 32 (0x20)                                                          */


/** @} */ /* End of group Device_Peripheral_peripherals */


/* =========================================================================================================================== */
/* ================                          Device Specific Peripheral Address Map                           ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_peripheralAddr
  * @{
  */

#define ITR_SPIC_BASE               0x40000000UL
#define ETR_SPIC_BASE               0x40001000UL
#define DMA_BASE                    0x40002000UL
#define USB_CORE_BASE               0x40040000UL
#define USB_HOST_BASE               0x40040400UL
#define USB_DEVICE_BASE             0x40040800UL
#define USB_IN_EP_BASE              0x40040900UL
#define USB_OUT_EP_BASE             0x40040B00UL
#define SYSTEM_BASE                 0x40100000UL
#define RCCAL_BASE                  0x40100100UL
#define SPIM_BASE                   0x40100300UL
#define SPIS_BASE                   0x40100400UL
#define UART_BASE                   0x40100700UL
#define TACHO0_BASE                 0x40100900UL
#define TACHO1_BASE                 0x40100920UL
#define TACHO2_BASE                 0x40100940UL
#define TACHO3_BASE                 0x40100960UL
#define WDT_BASE                    0x40100980UL
#define I2C0_BASE                   0x40101000UL
#define I2C1_BASE                   0x40101200UL
#define I2C2_BASE                   0x40101400UL
#define STRIP0_BASE                 0x40101600UL
#define STRIP1_BASE                 0x40101700UL
#define STRIP2_BASE                 0x40101800UL
#define STRIP3_BASE                 0x40101900UL
#define STRIP4_BASE                 0x40101A00UL
#define STRIP5_BASE                 0x40101B00UL
#define STRIP6_BASE                 0x40101C00UL
#define STRIP7_BASE                 0x40101D00UL
#define STRIP8_BASE                 0x40101E00UL
#define GPIO_BASE                   0x40110000UL
#define PWMLED0_BASE                0x40121000UL
#define PWMLED1_BASE                0x40121020UL
#define PWMLED2_BASE                0x40121040UL
#define PWMLED3_BASE                0x40121060UL
#define PWMLED4_BASE                0x40121080UL
#define PWMLED5_BASE                0x401210A0UL
#define PWMLED6_BASE                0x401210C0UL
#define PWMLED7_BASE                0x401210E0UL
#define PWMLED8_BASE                0x40121100UL
#define PWMLED9_BASE                0x40121120UL
#define PWMLED10_BASE               0x40121140UL
#define PWMLED11_BASE               0x40121160UL
#define PWMLED12_BASE               0x40121180UL
#define PWMLED13_BASE               0x401211A0UL
#define PWMLED14_BASE               0x401211C0UL
#define PWMLED15_BASE               0x401211E0UL
#define PWMLED16_BASE               0x40121200UL
#define PWMLED17_BASE               0x40121220UL
#define PWMLED18_BASE               0x40121240UL
#define PWMLED19_BASE               0x40121260UL
#define PWMLED20_BASE               0x40121280UL
#define PWMLED21_BASE               0x401212A0UL
#define PWMLED22_BASE               0x401212C0UL
#define PWMLED23_BASE               0x401212E0UL
#define PWMLED24_BASE               0x40121300UL
#define PWMLED25_BASE               0x40121320UL
#define PWMLED26_BASE               0x40121340UL
#define PWMLED27_BASE               0x40121360UL
#define PWMLED28_BASE               0x40121380UL
#define PWMLED29_BASE               0x401213A0UL
#define PWMLED30_BASE               0x401213C0UL
#define PWMLED31_BASE               0x401213E0UL
#define TMR0_BASE                   0x40121400UL
#define TMR1_BASE                   0x40121410UL
#define TMR2_BASE                   0x40121420UL
#define TMR3_BASE                   0x40121430UL
#define CRC32_BASE                  0x40122000UL
#define DOTMTX0_BASE                0x40122100UL
#define DOTMTX1_BASE                0x40122120UL

/** @} */ /* End of group Device_Peripheral_peripheralAddr */


/* =========================================================================================================================== */
/* ================                                  Peripheral declaration                                   ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_declaration
  * @{
  */

#define ITR_SPIC                    ((SPIC_Type*)              ITR_SPIC_BASE)
#define ETR_SPIC                    ((SPIC_Type*)              ETR_SPIC_BASE)
#define DMA                         ((DMAC_Type*)              DMA_BASE)
#define USB_CORE                    ((USB_OTG_CORE_Type*)      USB_CORE_BASE)
#define USB_HOST                    ((USB_OTG_HOST_Type*)      USB_HOST_BASE)
#define USB_DEVICE                  ((USB_OTG_DEVICE_Type*)    USB_DEVICE_BASE)
#define USB_IN_EP                   ((USB_OTG_IN_EP_Type*)     USB_IN_EP_BASE)
#define USB_OUT_EP                  ((USB_OTG_OUT_EP_Type*)    USB_OUT_EP_BASE)
#define SYSTEM                      ((SYSTEM_Type*)            SYSTEM_BASE)
#define RCCAL                       ((RCCAL_Type*)             RCCAL_BASE)
#define SPIM                        ((DW_SPI_Type*)            SPIM_BASE)
#define SPIS                        ((DW_SPI_Type*)            SPIS_BASE)
#define UART                        ((DW_UART_Type*)           UART_BASE)
#define TACHO0                      ((TACHO_Type*)             TACHO0_BASE)
#define TACHO1                      ((TACHO_Type*)             TACHO1_BASE)
#define TACHO2                      ((TACHO_Type*)             TACHO2_BASE)
#define TACHO3                      ((TACHO_Type*)             TACHO3_BASE)
#define WDT                         ((WDT_Type*)               WDT_BASE)
#define I2C0                        ((DW_I2C_Type*)            I2C0_BASE)
#define I2C1                        ((DW_I2C_Type*)            I2C1_BASE)
#define I2C2                        ((DW_I2C_Type*)            I2C2_BASE)
#define STRIP0                      ((STRIP_Type*)             STRIP0_BASE)
#define STRIP1                      ((STRIP_Type*)             STRIP1_BASE)
#define STRIP2                      ((STRIP_Type*)             STRIP2_BASE)
#define STRIP3                      ((STRIP_Type*)             STRIP3_BASE)
#define STRIP4                      ((STRIP_Type*)             STRIP4_BASE)
#define STRIP5                      ((STRIP_Type*)             STRIP5_BASE)
#define STRIP6                      ((STRIP_Type*)             STRIP6_BASE)
#define STRIP7                      ((STRIP_Type*)             STRIP7_BASE)
#define STRIP8                      ((STRIP_Type*)             STRIP8_BASE)
#define GPIO                        ((GPIO_Type*)              GPIO_BASE)
#define PWMLED0                     ((PWMLED_Type*)            PWMLED0_BASE)
#define PWMLED1                     ((PWMLED_Type*)            PWMLED1_BASE)
#define PWMLED2                     ((PWMLED_Type*)            PWMLED2_BASE)
#define PWMLED3                     ((PWMLED_Type*)            PWMLED3_BASE)
#define PWMLED4                     ((PWMLED_Type*)            PWMLED4_BASE)
#define PWMLED5                     ((PWMLED_Type*)            PWMLED5_BASE)
#define PWMLED6                     ((PWMLED_Type*)            PWMLED6_BASE)
#define PWMLED7                     ((PWMLED_Type*)            PWMLED7_BASE)
#define PWMLED8                     ((PWMLED_Type*)            PWMLED8_BASE)
#define PWMLED9                     ((PWMLED_Type*)            PWMLED9_BASE)
#define PWMLED10                    ((PWMLED_Type*)            PWMLED10_BASE)
#define PWMLED11                    ((PWMLED_Type*)            PWMLED11_BASE)
#define PWMLED12                    ((PWMLED_Type*)            PWMLED12_BASE)
#define PWMLED13                    ((PWMLED_Type*)            PWMLED13_BASE)
#define PWMLED14                    ((PWMLED_Type*)            PWMLED14_BASE)
#define PWMLED15                    ((PWMLED_Type*)            PWMLED15_BASE)
#define PWMLED16                    ((PWMLED_Type*)            PWMLED16_BASE)
#define PWMLED17                    ((PWMLED_Type*)            PWMLED17_BASE)
#define PWMLED18                    ((PWMLED_Type*)            PWMLED18_BASE)
#define PWMLED19                    ((PWMLED_Type*)            PWMLED19_BASE)
#define PWMLED20                    ((PWMLED_Type*)            PWMLED20_BASE)
#define PWMLED21                    ((PWMLED_Type*)            PWMLED21_BASE)
#define PWMLED22                    ((PWMLED_Type*)            PWMLED22_BASE)
#define PWMLED23                    ((PWMLED_Type*)            PWMLED23_BASE)
#define PWMLED24                    ((PWMLED_Type*)            PWMLED24_BASE)
#define PWMLED25                    ((PWMLED_Type*)            PWMLED25_BASE)
#define PWMLED26                    ((PWMLED_Type*)            PWMLED26_BASE)
#define PWMLED27                    ((PWMLED_Type*)            PWMLED27_BASE)
#define PWMLED28                    ((PWMLED_Type*)            PWMLED28_BASE)
#define PWMLED29                    ((PWMLED_Type*)            PWMLED29_BASE)
#define PWMLED30                    ((PWMLED_Type*)            PWMLED30_BASE)
#define PWMLED31                    ((PWMLED_Type*)            PWMLED31_BASE)
#define TMR0                        ((TMR_Type*)               TMR0_BASE)
#define TMR1                        ((TMR_Type*)               TMR1_BASE)
#define TMR2                        ((TMR_Type*)               TMR2_BASE)
#define TMR3                        ((TMR_Type*)               TMR3_BASE)
#define CRC32                       ((CRC_Type*)               CRC32_BASE)
#define DOTMTX0                     ((DOTMTX_Type*)            DOTMTX0_BASE)
#define DOTMTX1                     ((DOTMTX_Type*)            DOTMTX1_BASE)

/** @} */ /* End of group Device_Peripheral_declaration */


/* =========================================  End of section using anonymous unions  ========================================= */
#if defined (__CC_ARM)
  #pragma pop
#elif defined (__ICCARM__)
  /* leave anonymous unions enabled */
#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  #pragma clang diagnostic pop
#elif defined (__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined (__TMS470__)
  /* anonymous unions are enabled by default */
#elif defined (__TASKING__)
  #pragma warning restore
#elif defined (__CSMC__)
  /* anonymous unions are enabled by default */
#endif


#ifdef __cplusplus
}
#endif

#endif /* RTS5921_H */


/** @} */ /* End of group RTS5921 */

/** @} */ /* End of group Realtek Semiconductor Corp. */
